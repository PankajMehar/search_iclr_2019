Under review as a conference paper at ICLR 2019
UNIVERSAL SUCCESSOR FEATURES APPROXIMATORS
Anonymous authors Paper under double-blind review
ABSTRACT
The ability of a reinforcement learning (RL) agent to learn about many reward functions at the same time has many potential benefits, such as the decomposition of complex tasks into simpler ones, the exchange of information between tasks, and the reuse of skills. We focus on one aspect in particular, namely the ability to generalise to unseen tasks. Parametric generalisation relies on the interpolation power of a function approximator that is given the task description as input; one of its most common form are universal value function approximators (UVFAs). Another way to generalise to new tasks is to exploit structure in the RL problem itself. Generalised policy improvement (GPI) combines solutions of previous tasks into a policy for the unseen task; this relies on instantaneous policy evaluation of old policies under the new reward function, which is made possible through successor features (SFs). Our proposed universal successor features approximators (USFAs) combine the advantages of all of these, namely the scalability of UVFAs, the instant inference of SFs, and the strong generalisation of GPI. We discuss the challenges involved in training a USFA, its generalisation properties and demonstrate its practical benefits and transfer abilities on a large-scale domain in which the agent has to navigate in a first-person perspective three-dimensional environment.
1 INTRODUCTION
Reinforcement learning (RL) provides a general framework to model sequential decision-making problems with sparse evaluative feedback in the form of rewards. The recent successes in deep RL have prompted interest in increasingly more complex tasks and a shift in focus towards scenarios in which a single agent must solve multiple related problems, either simultaneously or sequentially. This paradigm is formally known as multitask RL (Taylor and Stone, 2009; Teh et al., 2017). One of the benefits of learning about multiple tasks at the same time is the possibility of transferring knowledge across tasks; in essence, this means that by jointly learning about a set of tasks one should be able to exploit their common structure to speed up learning and induce better generalisation (Taylor and Stone, 2009; Lazaric, 2012). A particularly interesting instance of transfer is the generalisation to new, unseen tasks. This potentially allows an agent to perform a task with little or no learning by leveraging knowledge from previously learned tasks. In this paper we will be exploring this scenario.
Consider an RL agent in a persistent environment trying to master a number of tasks. In order to generalise to unseen tasks, the agent needs to be able to identify and exploit some common structure underlying the tasks. Two possible sources of structure in this scenario are: i) some similarity between the solutions of the tasks, either in the policy or in the associated value-function space, and ii) the shared dynamics of the environment (e.g., physics). In this paper we will attempt to build an agent that can make use of both types of structure. For this, we will build on two frameworks that exploit these structures in isolation. The first one are Schaul et al.'s (2015) universal value function approximators (UVFAs). UVFAs extend the notion of value functions to also include the description of a task, thus directly exploiting the common structure in the associated optimal value functions. The second framework we build upon exploits the common structure in the environment and capitalises on the power of dynamic programming. Barreto et al.'s (2017) framework is based on two core concepts: successor features (SFs), a representation scheme that allows a policy to be evaluated on any task of a given format, and generalised policy improvement (GPI), a generalisation of dynamic programming's classic operator that uses a set of policies instead of a single one.
UVFAs and SF&GPI generalise to new tasks in quite different, and potentially complementary, ways. UVFAs aim to generalise across the space of tasks by exploiting structure in the underlying space
1

Under review as a conference paper at ICLR 2019

of value functions. In contrast, SF&GPI strategy is to exploit the structure of the RL problem itself. In this paper we propose a model that exhibits both types of generalisation. The basic insight is to note that SFs are multi-dimensional value functions, so we can extend them in the same way a universal value function extends their unidimensional counterparts. We call the resulting model universal successor features approximators, or USFAs for short. USFA is a strict generalisation of its precursors. Specifically, we show that by combining USFAs and GPI we can recover both UVFAs and SF&GPI as particular cases. This opens up a new spectrum of possible approaches in between these two extreme cases. We discuss the challenges involved in training a USFA and demonstrate the practical benefits of doing so on a large-scale domain in which the agent has to navigate in a three-dimensional environment using only images as observations.
2 BACKGROUND
In this section we present some background material, formalise the scenario we are interested in, and briefly describe the methods we build upon.

2.1 MULTITASK REINFORCEMENT LEARNING

We consider the usual RL framework: an agent interacts with an environment and selects actions in
order to maximise the expected amount of reward received in the long run (Sutton and Barto, 1998).
As usual, we assume that such an interaction can be modeled as a Markov decision process (MDP, Puterman, 1994). An MDP is defined as a tuple M  (S, A, p, R, ) where S and A are the state and action spaces, p(·|s, a) gives the next-state distribution upon taking action a in state s, R(s, a, s ) is a random variable representing the reward received at transition s -a s , and   [0, 1) is a discount
factor that gives smaller weights to future rewards.

As mentioned in the introduction, in this paper we are interested in the multitask RL scenario, where
the agent has to solve multiple tasks. Each task is defined by a reward function Rw; thus, instead of a single MDP M , our environment is a set of MDPs that share the same structure except for the reward
function. Following Barreto et al. (2017), we assume that the expected one-step reward associated with transition s -a s is given by

E [Rw(s, a, s )] = rw(s, a, s ) = (s, a, s ) w,

(1)

where (s, a, s )  Rd are features of (s, a, s ) and w  Rd are weights. The features (s, a, s ) can

be thought of as salient events that may be desirable or undesirable to the agent, such as for example

picking up an object, going through a door, or knocking into something. In this paper we assume that

the agent is able to recognise such events--that is,  is observable--, but the solution we propose

can be easily extended to the case where  must be learned (Barreto et al., 2017). Our solution also

applies to the case where (1) is only approximately satisfied, as discussed by Barreto et al. (2018).

Given w  Rd representing a task, the goal of the agent is to find a policy w : S  A that

maximises the expected discounted sum of rewards, also called the return G(wt) =

 i=0

 i Rw(t+i) ,

where Rw(t) = Rw(St, At, St+1) is the reward received at the tth time step. A principled way to

address this problem is to use methods derived from dynamic programming (DP), which heavily rely

on the concept of a value function (Puterman, 1994). The action-value function of a policy  on task

w is defined as Qw (s, a)  E Gw(t) | St = s, At = a , where E[·] denotes expected value when

following policy . Based on Qw we can compute a greedy policy  (s)  argmaxaQw (s, a); one

of the fundamental results in DP guarantees that Qw (s, a)  Qw(s, a) for all (s, a)  S × A. The

computation of Qw(s, a) and  are called policy evaluation and policy improvement; under certain

conditions their successive application leads to derive an optimal policy for task w as w (s) 

tahregompatixmaaQl wva(lsu,eaf)u(nScutitotonnQanwd,

from which one Barto, 1998).

can

As a convention, in this paper we will add a tilde to a symbol to indicate that the associated quantity
is an approximation; we will then refer to the respective tunable parameters as . For example, the agent computes an approximation Q~w  Qw by tuning Q.

2.2 TRANSFER LEARNING

Here we focus on one aspect of multitask RL: how to transfer knowledge to unseen tasks (Taylor and
Stone, 2009; Lazaric, 2012). Specifically, we ask the following question: how can an agent leverage knowledge accumulated on a set of tasks M  Rd to speed up the solution of a new task w / M?

2

Under review as a conference paper at ICLR 2019

In order to investigate the question above we recast it using the formalism commonly adopted in learning. Specifically, we define a distribution Dw over Rd and assume the goal is for the agent to
perform as well as possible under this distribution. As usual, we assume a fixed budget of sample
transitions and define a training set M  Dw that is used by the agent to learn about the tasks of interest. We also define a test set M  Dw and use it to assess the agent's generalisation--that is, how well it performs on the distribution of MDPs induced by Dw.

A natural way to address the learning problem above is to use Schaul et al.'s (2015) universal value-
function approximators (UVFAs). The basic insight behind UVFAs is to note that the concept of
optimal value function can be extended to include as one of its arguments a description of the task; an obvious way to do so in the current context is to define the function Q(s, a, w) : S × A × Rd  R as the optimal value function associated with task w. The function Q(s, a, w) is called a universal value function (UVF); a UVFA is then the corresponding approximation, Q~(s, a, w). When we define
transfer as above it becomes clear that in principle a sufficiently expressive UVFA can identify and exploit structure across the joint space S × A × Rd. In other words, a properly trained UVFA should be able to generalise across the space of tasks.

A different way of generalising across tasks is to use Barreto et al.'s (2017) framework, which builds on assumption (1) and two core concepts: successor features (SFs) and generalised policy improvement (GPI). The SFs of a state-action pair (s, a) under policy  are given by



(s, a)  E

i-ti+1 | St = s, At = a .

i=t

(2)

SFs allow one to immediately compute the value of a policy  on any task w: it is easy to show that, when (1) holds, Qw (s, a) = (s, a) w. It is also easy to see that SFs satisfy a Bellman equation in which  play the role of rewards, so  can be learned using any RL method (Szepesva´ri, 2010).

GPI is a generalisation of the policy improvement step described in Section 2.1. The difference is
that in GPI the improved policy is computed based on a set of value functions rather than on a single one. Suppose that the agent has learned the SFs i of policies 1, 2, ..., n. When exposed to a new task defined by w, the agent can immediately compute Qwi (s, a) = i (s, a) w. Let the GPI policy be defined as (s)  argmaxaQmax(s, a), where Qmax = maxi Qi . The GPI theorem states that Q(s, a)  Qmax(s, a) for all (s, a)  S × A. The result also extends to the scenario where we replace Qi with approximations Q~i (Barreto et al., 2017).

3 UNIVERSAL SUCCESSOR FEATURES APPROXIMATORS
UVFAs and SF&GPI address the transfer problem described in Section 2.2 in quite different ways. With UVFAs, one trains an approximator Q~(s, a, w) by solving the training tasks w  M using any RL algorithm of choice. One can then generalise to a new task by plugging its description w into Q~ and then acting according to the policy (s)  argmaxaQ~(s, a, w ). With SF&GPI one solves each task w  M and computes an approximation of the SFs of the resulting policies w, ~ w (s, a)  w (s, a). The way to generalise to a new task w is to use the GPI policy defined as (s)  argmaxa maxwM ~ w (s, a) w .
The algorithmic differences between UVFAs and SF&GPI reflect the fact that these approaches exploit distinct properties of the transfer problem. UVFAs aim at generalising across the space of tasks by exploiting structure in the function Q(s, a, w). In practice, such strategy materialises in the choice of function approximator, which carries assumptions about the shape of Q(s, a, w). For example, by using a neural network to represent Q~(s, a, w) one is implicitly assuming that Q(s, a, w) is smooth in the space of tasks; roughly speaking, this means that small perturbations to w will result in small changes in Q(s, a, w).
In contrast, SF&GPI's strategy to generalise across tasks is to exploit structure in the RL problem itself. GPI builds on the general fact that a greedy policy with respect to a value function will in general perform better than the policy that originated the value function. SFs, in turn, exploit the structure (1) to make it possible to quickly evaluate policies across tasks--and thus to apply GPI in an efficient way. The difference between the types of generalisation promoted by UVFAs and SF& GPI is perhaps even more clear when we note that the latter is completely agnostic to the way the approximations ~ w are represented, and in fact it can applied even with a tabular representation.

3

Under review as a conference paper at ICLR 2019
Obviously, both UVFAs and GPI have advantages and limitations. In order to illustrate this point, consider two tasks w and w that are "similar", in the sense that ||w - w || is small (|| · || is a norm in Rd). Suppose that we have trained a UVFA on task w and as a result we obtained a good approximation Q~(s, a, w)  Q(s, a, w). If the structural assumptions underlying Q~(s, a, w) hold-- for example, Q~(s, a, w) is smooth with respect to w--, it is likely that Q~(s, a, w ) will be a good approximation of Q(s, a, w ). On the other hand, if such assumptions do not hold, we should not expect UVFA to perform well. A sufficient condition for SF&GPI to generalise well from task w to task w is that the policy (s)  argmaxa~ w (s, a) w does well on task w , where w is a solution for task w. On the downside, SF&GPI will not exploit functional regularities at all, even if they do exist. Let policy w be a solution for tasks w . In principle we cannot say anything about w (s, a), the SFs of w , even if we have a good approximation ~ w (s, a)  w (s, a).
As one can see, the types of generalisation provided by UVFAs and SF&GPI are in some sense complementary. It is then natural to ask if we can simultaneously have the two types of generalisation. In this paper we propose a model that provides exactly that. The main insight is actually simple: since SFs are multi-dimensional value functions, we can extend them in the same way as universal value functions extend regular value functions. In the next section we elaborate on how exactly to do so.
3.1 UNIVERSAL SUCCESSOR FEATURES
As discussed in Section 2.2, UVFs are an extension of standard value functions defined as Q(s, a, w). If w is one of the optimal policies of task w, we can rewrite the definition as Qw (s, a, w). This makes it clear that the argument w plays two roles in the definition of a UVF: it determines both the task w and the policy w (which will be optimal with respect to w). This does not have to be the case, though. Similarly to Sutton et al.'s (2011) general value functions (GVFs), we could in principle define a function Q(s, a, w, ) that "disentangles" the task from the policy. This would provide a model that is even more general than UVFs. In this section we show one way to construct such a model when assumption (1) (approximately) holds.
Note that, when (1) is true, we can revisit the definition of SFs and write Q(s, a, w, ) = (s, a) w. If we want to be able to compute Q(s, a, w, ) for any , we need SFs to span the space of policies . Thus, we define universal successor features as (s, a, )  (s, a). Based on such definition, we call ~ (s, a, )  (s, a, ) a universal successor features approximator (USFA).
In practice, when defining a USFA we need to define a representation for the policies . A natural choice is to embed  onto Rk. Let e : (S  A)  Rk be a policy-encoding mapping, that is, a function that turns policies  into vectors in Rk. We can then see USFs as a function of e(): (s, a, e()). The definition of the policy-encoding mapping e() can have a strong impact on the structure of the resulting USF. We now point out a general equivalence between policies and reward functions that will provide a practical way of defining e(). It is well known that any reward function induces an optimal policy (Puterman, 1994). A point that is perhaps less immediate is that the converse is also true. Given a deterministic policy , one can easily define a reward function r that induces this policy: for example, we can have r(s, (s), ·) = 0 and r(s, a, ·) = -1 for any a = (s). Therefore, we can use rewards to refer to deterministic policies and vice-versa.
Since here we are interested in reward functions of the form (1), if we restrict our attention to policies induced by tasks z  Rd we end up with a conveniently simple encoding function e(z) = z. From this encoding function it follows that Q(s, a, w, z) = Q(s, a, w, z). It should be clear that UVFs are a particular case of this definition when w = z. Going back to the definition of USFs, we can finally write Q(s, a, w, z) = (s, a, z) w. Thus, if we learn a USF (s, a, z), we have a value function that generalises over both tasks and policies, as promised.
3.2 USFA GENERALISATION
We now revisit the question as to why USFAs should provide the benefits associated with both UVFAs and SF&GPI. We will discuss how exactly to train a USFA in the next section, but for now suppose that we have trained one such model ~ (s, a, z) using the training tasks in M. It is then not difficult to see that we can recover the solutions provided by both UVFAs and SF&GPI. Given an unseen task
4

Under review as a conference paper at ICLR 2019

w , let  be the GPI policy defined as

(s)



argmaxa

max
zC

Q~(s,

a,

w

,

z)

=

argmaxa

max
zC

~ (s,

a,

z)

w,

(3)

where C  Rd. Clearly, if we make C = {w }, we get exactly the sort of generalisation associated with UVFAs. On the other hand, setting C = M essentially recovers SF&GPI.

The fact that we can recover both UVFAs and SF&GPI opens up a spectrum of possibilities in
between the two. For example, we could apply GPI over the training set augmented with the current task, C = M  {w }. In fact, USFAs allow us to apply GPI over any set of tasks C  Rd. The
benefits of this flexibility are clear when we look at the theory supporting SF&GPI, as we do next.

Barreto et al. (2017) provide theoretical guarantees on the performance of SF&GPI applied to any task w  M based on a fixed set of SFs. Below we state a slightly more general version of this result that highlights the two types of generalisation promoted by USFAs (proof in Barreto et al.'s (2017) Theorem 2).

Proposition 1 Let w  M and let Qw be the action-value function of executing policy  on task w . Given approximations {Q~wz = ~ (s, a, z) w }zC, let  be the GPI policy defined in 3. Then,

 



Qw - Qw



2

1

-



minzC

 





w - z  + max  w  zC 

d (z)

·

z - ~ (s, a, z)



 

,

 (z)

(4)

where Qw is the optimal value of task w , z is the SFs corresponding to the optimal policy for task z, and f - g  = maxs,a |f (s, a) - g(s, a)|.

When we write the result in this form, it becomes clear that, for each policy z, the right-hand side of (4) involves two terms: i) d(z), the distance between the task of interest w and the task that induced z, and ii) (z), the quality of the approximation of the SFs associated with z.
In order to get the tightest possible bound (4) we want to include in C the policy z that minimises d(z) + (z). This is exactly where the flexibility of choosing C provided by USFAs can come in handy. Note that, if we choose C = M, we recover Barreto et al.'s (2017) bound, which may have an irreducible minzCd(z) even with a perfect approximation of the SFs in M. On the other extreme, we could query our USFA at the test point C = {w }. This would result in d(w ) = 0, but can potentially incur a high cost due to the associated approximation error (w ).

3.3 HOW TO TRAIN A USFA

Now that we have an approximation Q~(s, a, w, z) a natural question is how to train this model. In this section we show that the decoupled nature of Q~ is reflected in the training process, which assigns
clearly distinct roles for tasks w and policies z.

In our scenario, a transition at time t will be (st, at, t+1, st+1). Note that  allows us to compute the reward for any task w, and since our policies are encoded by z, transitions of this form allow
us to learn the value function of any policy z on any task w. To see why this is so, let us define the temporal-difference (TD) error (Sutton and Barto, 1998) used in learning these value functions.
Given transitions in the form above, the n-step TD error associated with policy z on task w will be

t+n-1

wt,nz =

i-trw(si, ai, si+1) + nQ~(st+n, z(st+n), w, z) - Q~(st, at, w, z)

i=t

t+n-1
= i-t(si, ai, si+1) + n~ (st+n, at+n, z) - ~ (st, at, z)
i=t

w

=

(

t,n z

)

w,

(5)

where at+n = argmaxbQ~(st+n, b, z, z) = argmaxb~ (st+n, b, z) z. As well known, the TD error tw,nz allows us to learn the value of policy z on task w; since here wt,nz is a function of z and w only, we can learn about any policy z on any task w by just plugging in the appropriate vectors.

Equation (5) highlights some interesting (and subtle) aspects involved in training a USFA. Since the value function Q~(s, a, w, z) can be decoupled into two components, ~ (s, a, z) and w, the process

5

Under review as a conference paper at ICLR 2019

of evaluating a policy on a task reduces to learning ~ (s, a, z) using the vector-based TD error zt,n showing up in (5). Since zt,n is a function of z only, the updates to Q~(s, a, w, z) will not depend on w. How do the tasks w influence the training of a USFA, then? If sample transitions are collected by a behaviour policy, as is usually the case in online RL, a natural choice is to have this policy be induced by a task w. When this is the case the training tasks w  M will define the distribution used to collect sample transitions. Whenever we want to update (s, a, z) for a different z than the one used in generating the data, we find ourselves under the off-policy regime (Sutton and Barto, 1998).
Assuming that the behaviour policy is induced by the tasks w  M, training a USFA involves two main decisions: how to sample tasks from M and how to sample policies z to be trained through (5) or some variant. As alluded to before, these decisions may have a big impact on the performance of the resulting USFA, and in particular on the trade-offs involved in the choice of the set of policies C used by the GPI policy (3). As a form of illustration, Algorithm 1 shows a possible regime to train a USFA based on particularly simple strategies to select tasks w  M and to sample policies z  Rd. One aspect of Algorithm 1 worth calling attention to is the fact that the distribution Dz used to select policies can depend on the current task w. This allows one to focus on specific regions of the policy space; for example, one can sample policies using a Gaussian distribution centred around w.

Algorithm 1 Learn USFA with -greedy Q-learning

Require: training tasks M, distribution Dz over Rd, num-
ber of policies nz 1: select initial state s  S
2: for ns steps do
3: sample w uniformly at random from M
4: {sample policies, possibly based on current task}
5: for i  1, 2, ..., nz do zi  Dz(·|w) 6: if Bernoulli( )=1 then a  Uniform(A) 7: else a  argmaxb maxi ~ (s, b, zi) w {GPI } 8: Execute action a and observe  and s 9: for i  1, 2, ..., nz do {Update ~ } 10: a  argmaxb~ (s, b, zi) zi {a  i(s )} 11:  -  + ~ (s , a , zi) - ~ (s, a, zi) ~

12: s  s 13: return 

Figure 1: USFA architecture

4 EXPERIMENTS
In this section we describe the experiments conducted to test the proposed architecture in a multitask setting and assess its ability to generalise to unseen tasks.
4.1 ILLUSTRATIVE EXAMPLE: TRIP MDP
We start with a simple illustrative example to provide intuition on the kinds of generalisation provided by UVFAs and SF&GPI. We also show how in this example USFAs can effectively leverage both types of generalisation and outperform its precursors. For this we will consider the simple two-state MDP depicted in Figure 2. To motivate the example, suppose that state s1 of our MDP represents the arrival of a traveler to a new city. The traveler likes coffee and food and wants to try what the new city has to offer. In order to model that, we will use features   R2, with 1 representing the quality of the coffee and 2 representing the quality of the food, both ranging from 0 to 1. The traveler has done some research and identified the places that serve the best coffee and the best food; in our MDP these places are modelled by terminal states associated with actions `C' and `F ' whose respective associated rewards are (·, C) = (C) = [1, 0] and (F ) = [0, 1]. As one can infer from these feature vectors, the best coffee place does not serve food and the best restaurant does not serve coffee (at least not a very good one). Nevertheless, there are other places in town that serve both; as before, we will model these places by actions Pi associated with features (Pi). We assume that (Pi) 2 = 1 and consider N = 5 alternative places Pi evenly spaced on the preference spectrum. We model how much the traveler wants coffee and food on a given day by w  R2. If the traveler

6

Under review as a conference paper at ICLR 2019

S
Arrived in new city
CF

E S
- Explored neighborhood
-

... 1 0 .8 .6 .7 0 1 .6 .8 .7

Optimality Gap

0.00 Optimality Gap across directions

0.05

0.10

0.15

0.20

0.25 USFA over C={w'}

0.30

USFA over C=random(5) UVFA

SF&GPI

0.35 0

20 40 60 80

Training iterations (10 episodes each)

Figure 2: Trip MDP: [Left] Depiction of MDP. [Right] Optimality gap (Difference between optimal return and the return obtained by the different models) at different times in the training process.

happens to want only one of these (i.e. w  {[1, 0], [0, 1]}), she can simply choose actions `C' or `F ' and get a reward r = (·) w = 1. If instead she wants both coffee and food (i.e. if w is not an
"one-hot" vector), it may actually be best to venture out to one of the other places. Unfortunately,
this requires the traveler to spend some time researching the area, which we model by an action `E' associated with feature (E) = [- , - ]. After choosing `E' the traveler lands on state s2 and can now reach any place in town: C, F , P1, ..., PN . Note that, depending on the vector of preferences w, it may be worth paying the cost of (E) w to subsequently get a reward of (Pi) w (here  = 1).

In order to assess the transfer ability of UVFAs, SF&GPI and USFAs, we define a training set

M = {10, 01} and K = 50 test tasks corresponding to directions in the two-dimensional w-space:

M

= {w |w

=

[cos(

k 2K

),

sin(

k 2K

)],

k

=

0,

1,

...,

K }.

We

start

by

analysing

what

SF&GPI

would

do in this scenario. We focus on training task wC = [1, 0], but an analogous reasoning applies

to task wF = [0, 1]. Let C be the optimal policy associated with task wC . It is easy to see that (s1) = (s2) = C. Thus, under C it should be clear that QwC (s1, C) > QwC (s1, E) for all test tasks w . Since the exact same reasoning applies to task wF if we replace action C with action F , the GPI policy (3) computed over {C , F } will be suboptimal for most test tasks in M . Training a

UVFA on the same set M, will not be perfect either due to the very limited number of training tasks.

Nonetheless the smoothness in the approximation allows for a slightly better generalisation in M .

Alternatively, we can use Algorithm 1 to train a USFA on the training set M. In order to do so we sampled nz = 5 policies z  R2 using a uniformly random distribution Dz(·|w) = U ([0, 1]2) (see line 5 in Algorithm 1). When acting on the test tasks w we considered two choices for the candidates set: C = {w } and C = {zi|zi  U ([0, 1]2), i = 1, 2, ..., 5}. Empirical results are provided in Figure 2. As a reference we report the performance of SF&GPI using the true {C , F } ­ no
approximation. We also show the learning curve of a UVFA. As shown in the figure, USFA clearly
outperforms its precursors and quickly achieves near optimal performance. This is due to two factors.
First, contrary to vanilla SF&GPI, USFA can discover and exploit the rich structure in the policy-
space, enjoying the same generalisation properties as UVFAs but now enhanced by the combination of the off-policy and off-task training regime. Second, the ability to sample a candidate set C that
induces some diversity in the policies considered by GPI overcomes the suboptimality associated with the training SFs C and F . We explore this effect in a bit more details in the suppl. material.

4.2 LARGE SCALE EXPERIMENTS
Environment and tasks. We used the DeepMind Lab platform to design a 3D environment consisting of one large room containing four types of objects: TVs, balls, hats, and balloons (Beattie et al., 2016). A depiction of the environment through the eyes of the agent can be seen in Fig. 3. Features i are indicator functions associated with object types, i.e., i(s, a, s ) = 1 if and only if the agent collects an object of type i

(a) Screenshot of environment

M^ 1 1 0 0 0 M^ 2 0 1 0 0 M^ 3 0 0 1 0 M^ 4 0 0 0 1
(b) Training tasks M

Figure 3: Environment.

7

Under review as a conference paper at ICLR 2019

Episode reward

45 Task 000.90.1

40

35

30

25

20

15

10

5

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

0

Episode reward

60 Task 1100

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8
TaEnsvkiro-n1m-1en0t 0frame

1e19.0

25 Task -11-10

2 4 50

Task -11-11

Episode reward
Episode reward

20 6 40

15 8 30

10 10 20

5 12 10

0 14 0

50.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0 160.0

1000..02 En0v.2i0r.oE4nnvmi0r.oe4nnmte0fn.r6t0af.r6mamee 00..88 1e119.e019.0

UVFA UVFA (offpolicy)

USFA (GPI over C = M) USFA (GPI over C = M + {w'})

Episode reward

Episode reward

90 Task 1111

80

70

60

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

60 Task -1101

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

USFA (GPI over C = {w'})

Episode reward

Figure 4: Zero-shot generalisation performance, across different models, on a sample of test tasks w  M after training on M. Shaded areas represent one standard deviation over 10 runs.

(say, a TV) on the transition s -a s . A task is defined by four real numbers w  R4 indicating the rewards attached to each object. Note that these numbers can be negative, in which case the agent has to avoid the corresponding object type. For instance, in task w = [1-100] the agent is interested in objects of the first type and should avoid objects of the second type.
Agent architecture. A depiction of the architecture used for the USFA agent is illustrated in Fig. 1. The architecture has three main modules: i) A fairly standard input processing unit composed of three convolution layers and an LSTM followed by a non-linearity (Schmidhuber, 1996); ii) A policy conditioning module that combines the state embedding coming from the first module, s  f (h), and the policy embedding, z, and produces |A| outputs corresponding to the SFs of policy z, ~ (s, a, z); and iii) The evaluation module, which, given a task w and the SFs ~ (s, a, z), will construct the evaluation of policy z on w, Q~(s, a, w, z) = ~ (s, a, z) w.
Training and baselines. We trained the above architecture end-to-end using a variation of Alg. 1 that uses Watkins's (1989) Q() to apply Q-learning with eligibility traces. As for the distribution Dz used in line 5 of Alg. 1 we adopted a Gaussian centred at w: z  N (w, 0.1 I), where I is the identity matrix. We used the canonical vectors of R4 as the training set, M = {1000, 0100, 0010, 0001}. Once an agent was trained on M we evaluated it on a separate set of unseen tasks, M , using the GPI policy (3) over different sets of policies C. Specifically, we used: C = {w }, which corresponds to a UVFA with an architecture specialised to (1); C = M, which corresponds to doing GPI on the SFs of the training policies (similar to (Barreto et al., 2017)), and C = M  {w }, which is a combination of the previous two. We also included as baselines two standard UVFAs that do not take advantage of the structure (1); one of them was trained on-policy and the other one was trained off-policy (see supplement). The evaluation on the test tasks M was done by "freezing" the agent at different stages of the learning process and using the GPI policy (3) to select actions. To collect and process the data we used an asynchronous scheme similar to IMPALA (Espeholt et al., 2018).
4.3 RESULTS AND DISCUSSION
Fig. 4 shows the results of the agents after being trained on M. One thing that immediately stands out in the figure is the fact that all architectures generalise quite well to the test tasks. This is a surprisingly good result when we consider the difficulty of the scenario considered: recall that the agents are solving the test tasks without any learning taking place. This performance is even more impressive when we note that some test tasks contain negative rewards, something never experienced

8

Under review as a conference paper at ICLR 2019

Episode reward Episode reward Episode reward

60 Task 1100

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

60 Task -1101

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

50 Task -11-11

40

30

20

10

0

100.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

USFA (GPI over C = {w'}),  = 0. 1 USFA (GPI over C = {w'}),  = 0. 5 USFA (GPI over C = M),  = 0. 1 USFA (GPI over C = M),  = 0. 5

Figure 5: Generalisation performance on sample test tasks w  M after training on M, with Dz = N (w,  I), for  = 0.1 and  = 0.5 (larger coverage of the z space). Average over 3 runs.

by the agents during training. When we look at the relative performance of the agents, it is clear that USFAs perform considerably better than the unstructured UVFAs. This is true even for the case where C = {w }, in which USFAs essentially reduce to a structured UVFA that was trained by decoupling tasks and policies. The fact that USFAs outperform UVFAs in the scenario considered here is not particularly surprising, since the former exploit the structure (1) while the latter cannot. In any case, it is reassuring to see that our model can indeed exploit such a structure effectively. This result also illustrates a particular way of turning prior knowledge about a problem into a favourable inductive bias in the UVFA architecture.
It is also interesting to see how the different instantiations of USFAs compare against each other. As shown in Fig. 4, there is a clear advantage in including M to the set of policies C used in GPI (3). This suggests that, in the specific instantiation of this problem, the type of generalisation provided by SF& GPI is more effective than that associated with UVFAs. One result that may seem counter-intuitive at first is the fact that USFAs with C = M + {w } sometimes perform worse than their counterparts using C = M, especially on tasks with negative rewards. Here we note two points. First, although including more tasks to C results in stronger guarantees for the GPI policy, strictly speaking there are no guarantees that the resulting policy will perform better (see Barreto et al.'s Theorem 1, 2017). Another explanation very likely in the current scenario is that errors in the approximations ~ (s, a, z) may have a negative impact on the resulting GPI policy (3). As argued previously, adding a point to C can sometimes increase the upper bound in (4), if the approximation at this point is not reliable. On the other hand, comparing USFA's results using C = M + {w } and C = {w }, we see that by combining the generalisation of UVFAs and GPI we can boost the performance of a model that only relies on one of them. This highlights the fine balance between the two error terms in (4) and emphasizes how critical selecting low-error candidates in C can be.
In the above scenario, SF&GPI on the training set M seems to provide a more effective way of generalising, as compared to UVFAs, even when the latter has a structure specialised to (1). Nevertheless, with less conservative choices of Dz that provide a greater coverage of the z space we expect the structured UVFA (C = {w }) to generalise better. Note that this can be done without changing M and is not possible with conventional UVFAs. One of the strengths of USFAs is exactly that: by disentangling tasks and policies, one can learn about the latter without ever having to actually try them out in the environment. We exploit this possibility to repeat our experiments now using Dz = N (w, 0.5 I). Results are shown in Fig.5. As expected, the generalisation of the structured UVFA improves considerably, almost matching that of GPI. This shows that USFAs can operate in two regimes: i) with limited coverage of the policy space, GPI over M will provide a reliable generalisation; ii) with a broader coverage of the space structured UVFAs will do increasingly better.1

5 RELATED WORK
Multitask RL is an important topic that has generated a large body of literature. Solutions to this problem can result in better performance on the training set (Espeholt et al., 2018), can improve data efficiency (Teh et al., 2017) and enable generalisation to new tasks. For a comprehensive presentation of the subject please see Taylor and Stone (2009) and Lazaric (2012) and references therein.
There exist various techniques that incorporate tasks directly into the definition of the value function for multitask learning (Kaelbling, 1993; Ashar, 1994; Sutton et al., 2011). UVFAs have been used for zero-shot generalisation to combinations of tasks (Mankowitz et al., 2018; Hermann et al., 2017), or to learn a set of fictitious goals previously encountered by the agent (Andrychowicz et al., 2017).
1Videos of USFAs in action on the links https://youtu.be/Pn76cfXbf2Y and https://youtu.be/0afwHJofbB0.

9

Under review as a conference paper at ICLR 2019
Many recent multitask methods have been developed for learning subtasks or skills for a hierarchical controller (Vezhnevets et al., 2017; Andreas et al., 2016; Oh et al., 2017). In this context, Devin et al. (2017) and Heess et al. (2016) proposed reusing and composing sub-networks that are shared across tasks and agents in order to achieve generalisation to unseen configurations. Finn et al. (2017) uses meta-learning to acquire skills that can be fine-tuned effectively. Sequential learning and how to retain previously learned skills has been the focus of a number of investigations (Kirkpatrick et al., 2016; Rusu et al., 2016). All of these works aim to train an agent (or a sub-module) to generalise across many subtasks. All of these can be great use-cases for USFAs.
USFAs use a UVFA to estimate SFs over multiple policies. The main reason to do so is to apply GPI, which provides a superior zero-shot policy in an unseen task. There have been previous attempts to combine SFs and neural networks, but none of them used GPI (Kulkarni et al., 2016; Zhang et al., 2016). Recently, Ma et al. (2018) have also considered combining SFs and UVFAs. Although this work is superficially similar to ours, it differs a lot in the details. Specifically, Ma et al. (2018) do not consider GPI, and restrict the use of UVFAs to building a task-dependent set of SFs. In contrast, in this work we argue and show the benefits of decoupling the task and policy to enable generalisation via GPI when appropriate, while preserving the ability to exploit the structure in the policy space.
6 CONCLUSION
In this paper we presented USFAs, a generalisation of UVFAs through SFs. The combination of USFAs and GPI results in a powerful model capable of exploiting the same types of regularity exploited by its precursors: structure in the value function, like UVFAs, and structure in the problem itself, like SF&GPI. This means that USFAs can not only recover their precursors but also provide a whole new spectrum of possible models in between them. We described the choices involved in training and evaluating a USFA and discussed the trade-offs associated with these alternatives. To make the discussion concrete, we presented two examples aimed to illustrate different regimes of operation. The first example embodies a MDP where the generalisation in the optimal policy space is fairly easy but the number of optimal policies we would want to represent can be large. This is a scenario where UVFAs would strive, while vanilla SF&GPI will struggle due to the large number of policies needed to build a good GPI policy. In this case, we show that USFAs can leverage the sort of parametric generalisation provided by UVFAs and even improve on it, due to its decoupled training regime and the use of GPI in areas where the approximation is not quite perfect. Our second example is in some sense a reciprocal one, where we know from previous work that the generalisation provided via GPI can be very effective even on a small set of policies, while generalising in the space of optimal policies, like UVFAs do, seems to require a lot more data. Here we show that USFAs can recover the type of generalisation provided by SFs when appropriate. This example also highlights some of the complexities involved in training at scale and shows how USFAs are readily applicable to this scenario. Overall, we believe USFAs are a powerful model that can exploit the available structure effectively: i) the structure induced by the shared dynamics (via SFs), ii) the structure in the policy space (like UVFAs) and finally iii) the structure in the RL problem itself (via GPI), and could potentially be useful across a wide range of RL applications that exhibit these properties.
REFERENCES
J. Andreas, D. Klein, and S. Levine. Modular multitask reinforcement learning with policy sketches. arXiv preprint arXiv:1611.01796, 2016.
M. Andrychowicz, F. Wolski, A. Ray, J. Schneider, R. Fong, P. Welinder, B. McGrew, J. Tobin, O. P. Abbeel, and W. Zaremba. Hindsight experience replay. In Advances in Neural Information Processing Systems, pages 5048­5058, 2017.
R. Ashar. Hierarchical learning in stochastic domains. PhD thesis, Citeseer, 1994.
A. Barreto, W. Dabney, R. Munos, J. Hunt, T. Schaul, H. van Hasselt, and D. Silver. Successor features for transfer in reinforcement learning. In Advances in Neural Information Processing Systems (NIPS), 2017.
A. Barreto, D. Borsa, J. Quan, T. Schaul, D. Silver, M. Hessel, D. Mankowitz, A. Zidek, and R. Munos. Transfer in deep reinforcement learning using successor features and generalised policy
10

Under review as a conference paper at ICLR 2019
improvement. In Proceedings of the International Conference on Machine Learning (ICML), pages 501­510, 2018.
C. Beattie, J. Z. Leibo, D. Teplyashin, T. Ward, M. Wainwright, H. Ku¨ttler, A. Lefrancq, S. Green, V. Valde´s, A. Sadik, et al. Deepmind lab. arXiv preprint arXiv:1612.03801, 2016.
C. Devin, A. Gupta, T. Darrell, P. Abbeel, and S. Levine. Learning modular neural network policies for multi-task and multi-robot transfer. In Robotics and Automation (ICRA), 2017 IEEE International Conference on, pages 2169­2176. IEEE, 2017.
L. Espeholt, H. Soyer, R. Munos, K. Simonyan, V. Mnih, T. Ward, Y. Doron, V. Firoiu, T. Harley, I. Dunning, et al. Impala: Scalable distributed deep-rl with importance weighted actor-learner architectures. arXiv preprint arXiv:1802.01561, 2018.
C. Finn, P. Abbeel, and S. Levine. Model-agnostic meta-learning for fast adaptation of deep networks. CoRR, abs/1703.03400, 2017. URL http://arxiv.org/abs/1703.03400.
N. Heess, G. Wayne, Y. Tassa, T. Lillicrap, M. Riedmiller, and D. Silver. Learning and transfer of modulated locomotor controllers. arXiv preprint arXiv:1610.05182, 2016.
K. M. Hermann, F. Hill, S. Green, F. Wang, R. Faulkner, H. Soyer, D. Szepesvari, W. Czarnecki, M. Jaderberg, D. Teplyashin, et al. Grounded language learning in a simulated 3d world. arXiv preprint arXiv:1706.06551, 2017.
L. P. Kaelbling. Learning to achieve goals. In IJCAI, pages 1094­1099. Citeseer, 1993.
J. Kirkpatrick, R. Pascanu, N. C. Rabinowitz, J. Veness, G. Desjardins, A. A. Rusu, K. Milan, J. Quan, T. Ramalho, A. Grabska-Barwinska, D. Hassabis, C. Clopath, D. Kumaran, and R. Hadsell. Overcoming catastrophic forgetting in neural networks. CoRR, abs/1612.00796, 2016. URL http://arxiv.org/abs/1612.00796.
T. D. Kulkarni, A. Saeedi, S. Gautam, and S. J. Gershman. Deep successor reinforcement learning. arXiv preprint arXiv:1606.02396, 2016.
A. Lazaric. Transfer in Reinforcement Learning: A Framework and a Survey, pages 143­173. 2012.
C. Ma, J. Wen, and Y. Bengio. Universal successor representations for transfer reinforcement learning. arXiv preprint arXiv:1804.03758, 2018.
D. J. Mankowitz, A. Z ´idek, A. Barreto, D. Horgan, M. Hessel, J. Quan, J. Oh, H. van Hasselt, D. Silver, and T. Schaul. Unicorn: Continual learning with a universal, off-policy agent. arXiv preprint arXiv:1802.08294, 2018.
V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran, D. Wierstra, S. Legg, and D. Hassabis. Human-level control through deep reinforcement learning. Nature, 518(7540):529­533, 2015.
J. Oh, S. P. Singh, H. Lee, and P. Kohli. Zero-shot task generalization with multi-task deep reinforcement learning. CoRR, abs/1706.05064, 2017. URL http://arxiv.org/abs/1706.05064.
M. L. Puterman. Markov Decision Processes--Discrete Stochastic Dynamic Programming. John Wiley & Sons, Inc., 1994.
A. A. Rusu, N. C. Rabinowitz, G. Desjardins, H. Soyer, J. Kirkpatrick, K. Kavukcuoglu, R. Pascanu, and R. Hadsell. Progressive neural networks. CoRR, abs/1606.04671, 2016. URL http: //arxiv.org/abs/1606.04671.
T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal Value Function Approximators. In International Conference on Machine Learning (ICML), pages 1312­1320, 2015.
J. Schmidhuber. A general method for incremental self-improvement and multi-agent learning in unrestricted environments. In Evolutionary Computation: Theory and Applications. Scientific Publishing Company, 1996.
11

Under review as a conference paper at ICLR 2019
R. S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. MIT Press, 1998. URL http://www-anw.cs.umass.edu/~rich/book/the-book.html.
R. S. Sutton, J. Modayil, M. Delp, T. Degris, P. M. Pilarski, A. White, and D. Precup. Horde: A scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction. In International Conference on Autonomous Agents and Multiagent Systems, pages 761­768, 2011.
C. Szepesva´ri. Algorithms for Reinforcement Learning. Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers, 2010.
M. E. Taylor and P. Stone. Transfer learning for reinforcement learning domains: A survey. Journal of Machine Learning Research, 10(1):1633­1685, 2009.
Y. W. Teh, V. Bapst, W. M. Czarnecki, J. Quan, J. Kirkpatrick, R. Hadsell, N. Heess, and R. Pascanu. Distral: Robust multitask reinforcement learning. In Advances in Neural Information Processing Systems (NIPS), pages 4499­4509, 2017.
A. S. Vezhnevets, S. Osindero, T. Schaul, N. Heess, M. Jaderberg, D. Silver, and K. Kavukcuoglu. FeUdal networks for hierarchical reinforcement learning. In Proceedings of the International Conference on Machine Learning (ICML), pages 3540­3549, 2017.
C. Watkins. Learning from Delayed Rewards. PhD thesis, University of Cambridge, England, 1989. J. Zhang, J. T. Springenberg, J. Boedecker, and W. Burgard. Deep reinforcement learning with
successor features for navigation across similar environments. CoRR, abs/1612.05533, 2016.
12

Under review as a conference paper at ICLR 2019

Universal Successor Features Approximators
- Supplementary Material -
A ILLUSTRATIVE EXAMPLE: TRIP MDP
In this section we provide some additional analysis and results omitted from the main text. As a reminder, this is a two state MDP, where the first state is a root state, the transition from s1  s2 comes at a cost rw(s1, E) = (s1, E)T w = - (w1 + w2) and all other actions lead to a final positive reward corresponding to how much the resulting state/restaurant alligns with our preferences (our task) right now. For convenience, we provide below the depiction of the Trip MDP introduced in Section 4.1.

S
Arrived in new city
CF

E S
- Explored neighborhood
-

... 1 0 .8 .6 .7 0 1 .6 .8 .7

In the experiments run we considered a fixed set of training tasks M = {01, 10} for all methods.
The set of outcomes from the exploratory state s2 is defined as (s2, a) = [cos(), sin()] for   {k/2N }k=0,N . Note that this includes the binary states for k = 0 and respectively k = N . We ran this MDP with N = 6, and = 0.05. Thus outside the binary outcomes, the agent can select N - 1 = 5 other mixed outcomes and, as argued in the main text, under these conditions there will
be a selection of the w-space in which each of these outcomes will be optimal. Thus the space of
optimal policies, we hope to recover, is generally N + 1. Nevertheless, there is a lot of structure in
this space, that the functional approximators can uncover and employ in their generalization.

A.1 ADDITIONAL RESULTS

In the main paper, we reported the zero-shot aggregated performance over all direction M =

{w |w

=

[cos(

k 2K

),

sin(

k 2K

)],

k



ZK }.

This

should

cover

most

of

the

space

of

tasks/trade-offs

we

would be interest in. In this section we include the generalization for other sets M . First in Fig. 6

we depict the performance of the algorithms considered across the whole w space M = [0, 1]2. Fig.

7 is just a different visualization of the previous plot, where we focus on how far these algorithms

are from recovering the optimal performance. This also shows the subtle effect mentioned in the

discussion in the main text, induced by the choice of C in the USFA evaluation.

13

Under review as a conference paper at ICLR 2019

1.0 Optimal Perfomance

1.0 Perfomance: UVFA

1.0 Perfomance: SF&GPI

1.0 Perfomance: USFA C=random(5) 1.0 Perfomance: USFA C={w}

1.600

0.8 0.8 0.8 0.8 0.8 1.371 1.143
0.6 0.6 0.6 0.6 0.6 0.914

0.4 0.4 0.4 0.4 0.4 0.686
0.457 0.2 0.2 0.2 0.2 0.2 0.229

0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.000

Figure 6: [Sample run] Performance of the different methods (in this order, starting with the second subplot): UVFA, SF&GPIon the perfect SFs induced by M, USFA with C = random(5) and USFA with C = {w } as compared to the optimal performance one could get in this MDP (first plot). These correspond to one sample run, where we trained the UVFA and USFA for 1000 episodes. The optimal
performance and the SF&GPIwere computed exactly.

1.0 Optimality Gap: UVFA

1.0 Optimality Gap: SF&GPI

1.0 Optimality Gap: USFA C={w}

1.0 Optimality Gap: USFA C=random(5) 0.0010

0.8 0.8 0.8 0.8 0.6 0.6 0.6 0.6

0.0491 0.0993 0.1494

0.4 0.4 0.4 0.4 0.2 0.2 0.2 0.2

0.1996 0.2497 0.2999

0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.00.0 0.2 0.4 0.6 0.8 1.0 0.3500

Figure 7: [Sample run] Optimality gap over the whole task space. These correspond to the same sample run as above, where we trained the UVFA and USFA for 1000 episodes. We can now see more clearly that USFAs manage to recover better policies and optimality across a much greater portion of the task space. The last two plots correspond to the same USFA just using different choices of the candidate set C. Something to note here is that by having a more diverse choice in C, we can recover an optimal policy even in areas of the space where our approximation has not yet optimally generalised (like the upper-left corner in the w-space in the figures above).

A particularly adversarial choice of test tasks for the vanilla SF&GPIwould be the diagonal in the [0, 1]2 quadrant depicted in the plot above: M = {w |w1 = w2, w1  [0, 1]}. This is, in a sense, maximally away from the training tasks and both of the precursor models are bound to struggle in this portion of the space. This intuition was indeed empirically validated. Results are provided in Fig. 8. As mentioned above, this is an adversarial evaluation, mainly to point out that, in general, there might be regions of the space were the generalization of the previous models can be very bad, but where the combination of them can still recover close to optimal performance.
0.00 Optimality Gap on the diagonal

0.05

Optimality Gap

0.10

0.15

USFA over C={w'} USFA over C=random(5)

UVFA

SF&GPI

0.20 0

20 40 60 80

Training iterations (10 episodes each)

Figure 8: Zero-shot performance on the diagonal: Optimality gap for M = {w |w1 = w2, w1  [0, 1]}. These results were averaged over 10 runs.

14

Under review as a conference paper at ICLR 2019
B LARGE SCALE EXPERIMENTS: DETAILS
B.1 AGENT'S ARCHITECTURE This section contains a detailed description of the USFA agent used in our experimental section. As a reminder, we include the agent's architecture below (Figure 1 in the main text).
Figure 9: USFA architecture
As highlighted in Section 4.2, our agent comprises of three main modules: · Input processing module: computes a state representation f (ht) from observation ot. This module is made up of three convolutional layers (structure identical to the one used in (Mnih et al., 2015)), the output of which then serves as input to a LSTM (256). This LSTM takes as input the previously executed action at-1. The output of the LSTM is passed through a non-linearity f (chosen here to be a ReLu) to produce a vector of 128 units, f (ht). · Policy conditioning module: compute the SFs ~ (s, a, z), given a (sampled) policy embedding z and the state representation f (ht). This module first produces nz number of z  Dz samples (nz = 30 in our experiments). Each of these is then transformed via a 2-layer MLP(32,32) to produce a vector of size 32, for each sample z. This vector g(z) gets concatenated with the state representation f (ht) and the resulting vector is further processed by a 2-layer MLP that produces a tensor of dimensions D × |A| for each z, where D = dim(). These correspond to SFs ~ (s, a, z) for policy z. Note that this computation can be done quite efficiently by reusing the state embedding f (ht), doing the downstream computation in parallel for each policy embedding z. · Task evaluation module: computes the value function Q(s, a, z, w) = ~ (s, a, z)T w for a given task description w. This module does not have any parameters as the value functions are simply composable from ~ (s, a, z) and the task description w via assumption (1). This module with output nz value functions that will be used to produce a behavior via GPI.
An important decision in this design was how and where to introduce the conditioning on the policy. In all experiments shown here the conditioning was done simply by concatenating the two embeddings w and z, although stronger conditioning via an inner product was tried yielding similar performance.
15

Under review as a conference paper at ICLR 2019
The 'where' on the other hand is much more important. As the conditioning on the policy happens quite late in the network, most of the processing (up to f (ht)) can be done only once, and we can sample multiple z and compute the corresponding ~ z at a fairly low computational cost. As mentioned above, these will be combined with the task vector w to produce the candidate action value functions for GPI. Note that this helps both in training and in acting, as otherwise the unroll of the LSTM would be policy conditioned, making the computation of the SFs and the off-policy n-step learning quite expensive.
UVFA baseline agents have a similar architecture, but now the task description w is fed in as an input to the network. The conditioning on the task of UVFAs is done in a similar fashion as we did the conditioning on the policies in USFAs, to make the computational power and capacity comparable. The input processing module is the same and now downstream, instead of conditioning on the policy embedding z, we condition on task description w. This conditioning if followed by a 2-layer MLP that computes the value functions Q~(s, a, w), which induces the greedy policy w(UV F A) = arg maxa Q~(s, a, w).
B.2 AGENT'S TRAINING
The agents' training was carried out using the IMPALA architecture (Espeholt et al., 2018). On the learner side, we adopted a simplified version of IMPALA that uses Q() as the RL algorithm. In our experiments, for all agents we used  = 0.9. Depending on the sampling distribution Dz, in learning we will be often off-policy. That is, most of the time, we are going to learn about a policy z1 and update its corresponding SFs approximations ~ (s, a, z1), using data generated by acting in the environment according to some other policy z2 . In order to account for this off-policiness, whenever computing the n-step return required in eq. 5, we are going to cut traces whenever the policies start to disagree and bootstrap from this step on (Sutton and Barto, 1998). Here we can see how the data distribution induce by the choice of training tasks M can influence the training process. If the data distribution Dz is very close to the set M, as in our first experiment, most of the policies we are going to sample will be close to the policies that generated the data. This means that we might be able to make use of longer trajectories in this data, as the policies will rarely disagree. On the other hand, by staying close to the training tasks, we might hurt our ability to generalise in the policy space, as our first experiment suggest (see Figure 4). By having a broader distribution Dz = N (w, 0.5I), we can learn about more diverse policies in this space, but we will also increase our off-policiness. We can see from Figure 5, that our algorithm can successfully learn and operate in both of these regimes.
For the distributed collection of data we used 50 actors per task. Each actor gathered trajectories of length 32 that were then added to the common queue. The collection of data followed an -greedy policy with a fixed = 0.1. The training curves shown in the paper correspond to the performance of the the -greedy policy (that is, they include exploratory actions of the agents).
B.3 AGENT'S EVALUATION
All agents were evaluated in the same fashion. During the training process, periodically (every 20M frames) we will evaluate the agents performance on a test of held out test tasks. We take these intermediate snapshots of our agents and 'freeze' their parameters to assess zero-shot generalisation. Once a test task w is provided, the agent interacts with the environment for 20 episodes, one minute each and the average (undiscounted) reward is recorded. These produce the evaluation curves in Figure 4. Evaluations are done with a small = 0.001, following a GPI policy with different instantiations of C. For the pure UVFA agents, the evaluation is similar: -greedy on the produced value functions Q~(s, a, w), with the same evaluation = 0.001.
C ADDITIONAL RESULTS
In our experiments we defined a set of easy test tasks (close to M) and a set of harder tasks, in order to cover reasonably well a few distinct scenarios:
· Testing generalisation to tasks very similar to the training set, e.g. w = [0, 0.9, 0, 0.1];
16

Under review as a conference paper at ICLR 2019

· Testing generalisation to harder tasks with different reward profiles: only positive rewards, only negative rewards, and mixed rewards.
In the main text, we included only a selection of these for illustrative purposes. Here we present the full results.
C.1 CANONICAL BASIS: ZERO-SHOT GENERALISATION
This section contains the complete results of the first experiment conducted. As a reminder, in this experiment we were training a USFA agent on M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I) and compare its performance with two conventional UVFA agents (one trained on-policy and the other one using all the data generated to learn off-policy) on a range of unseen test tasks. Complete set of result is included below, as follows: Figure 10 includes results on easy tasks, close to the tasks contained in the training set M (generalisation to those should be fairly straightforward); Figure 11 and Figure 12 present results on more challenging tasks, quite far away from the training set, testing out agents ability to generate to the whole 4D hypercube.

Episode reward Episode reward

45 Task 000.90.1

40

35

30

25

20

15

10

5

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

35 Task 00.70.20.1

30

25

20

15

10

5

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(a) Task 0.,0.,0.9,0.1

(b) Task 0.,0.7,0.2,0.1

35 Task 00.1-0.10.8

45 Task 00-0.11

30 25

40 35 30

20 15 10 5 00.0

0 2 4 6 8
0.2 Envi0r.o4nment0f.r6a11m20 e 0.8

Task -1-100 25 20 15 10 5
1e19.0 00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

14

(c) Task 0.,0.1,-0.1,106.08.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0(d) Task 0.,0.,-0.1,1.

UVFA UVFA (offpolicy)

USFA (GPI over C = M) USFA (GPI over C = M + {w'})

USFA (GPI over C = {w'})

Episode reward
Episode reward
Episode reward

Figure 10: Zero-shot performance on the easy evaluation set: Average reward per episode on test
tasks not shown in the main paper. This is comparing a USFA agent trained on the canonical training set M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I) and the two UVFA agents: one trained on-policy, one employing off-policy.

17

Under review as a conference paper at ICLR 2019

Episode reward Episode reward

60 Task 1100

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

80 Task 0111

70

60

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(a) Task 1100

(b) Task 0111

90 Task 1111

0 Task -1-100

80 2

70 4

60 50 40 30 20 10 00.0

0 2 4 6 8
0.2 Envi0r.o4nment0f.r6a11m20 e 0.8

Task -1-100 1e19.0

6 8 10 12 14 160.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

14

(c) Task 1111 160.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0 (d) Task -1-100

UVFA UVFA (offpolicy)

USFA (GPI over C = M) USFA (GPI over C = M + {w'})

USFA (GPI over C = {w'})

Episode reward
Episode reward
Episode reward

Figure 11: Zero-shot performance on harder tasks: Average reward per episode on test tasks not
shown in the main paper. This is comparing a USFA agent trained on the canonical training set M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I) and the two UVFA agents: one trained on-policy, one employing off-policy. (Part 1)

18

Under review as a conference paper at ICLR 2019

Episode reward Episode reward

35 Task -1100

30

25

20

15

10

5

0

50.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

60 Task -1101

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(a) Task-1100

(b) Task -1101

25 Task -11-10

50 Task -11-11

20 40

15 30

10 0 Task -1-100 20

5

2 4

10

0 60

50.0

8
0.2 Envi0r.o4nment0f.r6a11m02 e 0.8

1e19.0

14

100.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(c) Task -11-10 160.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0 (d) Task -11-11

UVFA UVFA (offpolicy)

USFA (GPI over C = M) USFA (GPI over C = M + {w'})

USFA (GPI over C = {w'})

Episode reward
Episode reward
Episode reward

Figure 12: Zero-shot performance on harder tasks: Average reward per episode on test tasks not
shown in the main paper. This is comparing a USFA agent trained on the canonical training set M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I) and the two UVFA agents: one trained on-policy, one employing off-policy. (Part 2)

19

Under review as a conference paper at ICLR 2019

C.2 CANONICAL BASIS: USFAS IN DIFFERENT TRAINING REGIMES.
In this section, we include the omitted results from our second experiment. As a reminder, in this experiment we were training two USFA agents on the same set of canonical tasks, but employing different distributions Dz, one will low variance  = 0.1, focusing in learning policies around the training set M, and another one with larger variance  = 0.5, that will try to learn about a lot more policies away from the training set, thus potentially facilitating the generalisation provided by the UVFA component. Results are displayed in Figures 13-14 on all tasks in the hard evaluation set.

Episode reward

60 Task 1100

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(a) Task 1100

90 Task 1111

80

70

60

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(c) Task 1111

Episode reward

Episode reward

80 Task 0111

70

60

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(b) Task 0111

0.5 Task -1-100

1.0

1.5

2.0

2.5

3.0

3.5

4.0

4.50.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(d) Task -1-100

Episode reward

Figure 13: Different Dz ­ Zero-shot performance on harder tasks: Average reward per episode
on test tasks not shown in the main paper. This is comparing the generalisations of two USFA agent
trained on the canonical training set M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I), and Dz = N (w, 0.5I). (Part 1)

20

Under review as a conference paper at ICLR 2019

Episode reward

40 Task -1100

35

30

25

20

15

10

5

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(a) Task -1100.

35 Task -11-10

30

25

20

15

10

5

0

50.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(c) Task -11-10

Episode reward

Episode reward

60 Task -1101

50

40

30

20

10

00.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(b) Task -1101

50 Task -11-11

40

30

20

10

0

100.0

0.2 0.4 0.6 0.8 Environment frame

1e19.0

(d) Task -11-11

Episode reward

Figure 14: Different Dz ­ Zero-shot performance on harder tasks: Average reward per episode on test tasks not shown in the main paper. This is comparing a USFA agent trained on the canonical training set M = {1000, 0100, 0010, 0001}, with Dz = N (w, 0.1I), and Dz = N (w, 0.5I). (Part 2)

21

Under review as a conference paper at ICLR 2019

C.3 LARGER COLLECTION OF TRAINING TASKS

We also trained our USFA agent on a larger set of training tasks that include the previous canonical tasks, as well as four other tasks that contain both positive and negative reward M = {1000, 0100, 0010, 0001, 1-100, 01-10, 001-1, -1000}. Thus we expect this agent to generalises better as a result
of its training. A selection of these results and sample performance in training are included in Fig. 15.

episode_reward

45 task_vector_str = 1000

80 task_vector_str = 0111

70 task_vector_str = 1100

90 task_vector_str = 1111

40 35 30 25 20 15 10 5

70 60 50 40 30 20 10

60 50 40 30 20 10

80 70 60 50 40 30 20 10

0
35 task_vector_str = -11-10 30 25 20

0 60 task_vector_str = -11-11
50
40

0
40 task_vector_str = -1100 35 30 25

0 60 task_vector_str = -1101
50
40

USFA (GPI over C = M + {w_test}) USFA (GPI over C = M) USFA (GPI over C = {w_test})

15 30 20 30

10 20 15 20

5 10

0 10

5 10

50.0

0.2 0.4 0.6 0.8 environment_frame

1e19.0 00.0

0.2 0.4 0.6 0.8 environment_frame

1e19.0 00.0

0.2 0.4 0.6 0.8 environment_frame

1e19.0 00.0

0.2 0.4 0.6 0.8 environment_frame

1e19.0

episode_reward

Figure 15: Large M. Learning curves for training task [1000]  M and generalisation performance on a sample of test tasks w  M after training on all the tasks M. This is a selection of the hard
evaluation tasks. Results are average over 10 training runs.

22

