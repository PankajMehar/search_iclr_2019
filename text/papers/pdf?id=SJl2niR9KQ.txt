Under review as a conference paper at ICLR 2019

BEYOND PIXEL NORM-BALLS: PARAMETRIC ADVERSARIES USING AN ANALYTICALLY DIFFERENTIABLE RENDERER
Anonymous authors Paper under double-blind review

ABSTRACT
Many machine learning image classifiers are vulnerable to adversarial attacks, inputs with perturbations designed to intentionally trigger misclassification. Current adversarial methods directly alter pixel colors and evaluate against pixel norm-balls: pixel perturbations smaller than a specified magnitude, according to a measurement norm. This evaluation, however, has limited practical utility since perturbations in the pixel space do not correspond to underlying real-world phenomena of image formation that lead to them and has no security motivation attached. Pixels in natural images are measurements of light that has interacted with the geometry of a physical scene. As such, we propose a novel evaluation measure, parametric normballs, by directly perturbing physical parameters that underly image formation. One enabling contribution we present is a physically-based differentiable renderer that allows us to propagate pixel gradients to the parametric space of lighting and geometry. Our approach enables physically-based adversarial attacks, and our differentiable renderer leverages models from the interactive rendering literature to balance the performance and accuracy trade-offs necessary for a memory-efficient and scalable adversarial data augmentation workflow.

1 INTRODUCTION

Research in adversarial examples continues to contribute to the development of robust (semi-)supervised learning (Miyato et al., 2018), data augmentation (Goodfellow et al., 2014; Sun et al., 2018), and machine learning understanding (Kanbak et al., 2017). One important caveat of the approach pursued by much of the literature in adversarial machine learning, as discussed recently (Goodfellow, 2018; Gilmer et al., 2018), is the reliance on overly simplified attack metrics: namely, the use of pixel value differences between an adversary and an input image, also referred to as the pixel norm-balls.

The pixel norm-balls game considers pixel perturbations of norm-constrained magnitude (Goodfellow et al., 2014), and is used to develop adversarial attackers, defenders and training strategies. The pixel norm-ball game is attractive from a research perspective due to its simplicity and well-posedness: no knowledge of image formation is required and any arbitrary pixel perturbation remains eligible (so long as it is "small", in the perceptual sense). But "these (pixel norm-balls) games are primarily tools for basic research, and not models of real-world security scenarios." (Goodfellow, 2018).

original image

one-step pixel multi-step pixel texture color
[Goodfellow 14] [Moosavi Dezfooli 16] [Athalye 18]

parametric (lighting)

parametric (geometry)

Figure 1: Traditional pixel-based adversarial attacks yield unrealistic images under a larger perturbation (L-norm  0.82), however our parametric lighting and geometry perturbations output believable images under the same norm (more results in Appendix A).
1

Under review as a conference paper at ICLR 2019

original

parametric perturbation

pixel perturbation

Figure 2: Parametrically-perturbed images remain natural, whereas pixel-perturbed ones do not.
Despite the ability of devising effective adversarial methods through the direct employment of optimizations using the pixel norm-balls measure, the pixel manipulations they promote are divorced from the types of variations present in the real world, limiting their usefulness "in the wild". Moreover, this methodology leads to defenders that are only effective when defending against unrealistic images/attacks, not generalizing outside of the space constrained by pixel norm-balls. In order to consider conditions that enable adversarial attacks in the real world, we advocate for a new measurement norm that is rooted in the physical processes that underly realistic image synthesis, moving away from overly simplified metrics, e.g., pixel norm-balls.
Our proposed solution ­ parametric norm-balls ­ rely on perturbations of physical parameters of a synthetic image formation model, instead of pixel color pertubations (Figure 2). To achieve this, we use a physically-based differentiable renderer which allows us to perturb the underlying parameters of the image formation process. Since these parameters indirectly control pixel colors, perturbations in this parametric space implicitly span the space of natural images. We will demonstrate two advantages that fall from considering perturbations in this parametric space: (1) they enable adversarial approaches that more readily apply to real-world applications, and (2) they permit the use of much more significant perturbations (compared to pixel norms), without invalidating the realism of the resulting image (Figure 1). We validate that parametric norm-balls game playing is critical for a variety of important adversarial tasks, such as building defenders robust to perturbations that can occur naturally in the real world.
We perform perturbations in the underlying image formation parameter space using a novel physicallybased differentiable renderer. Our renderer analytically computes the derivatives of pixel color with respect to these physical parameters, allowing us to extend traditional pixel norm-balls to physicallyvalid parametric norm-balls. Notably, we demonstrate perturbations on an environment's lighting and on the shape of the 3D geometry it shades. Our differentiable renderer achieves state-of-the-art performance in speed and scalability (Section 3) and is fast enough for rendered adversarial data augmentation (Section 5): training augmented with adversarial images generated with a renderer.
Existing differentiable renders are slow and do not scalable to the volume of high-quality, highresolutions images needed to make adversarial data augmentation tractable (Section 2). Given our analytically-differentiable renderer (Section 3), we are able to demonstrate the efficacy of parametric space perturbations for generating adversarial examples. These adversaries are based on a substantially different phenomenology than their pixel norm-balls counterparts (Section 4). Ours is among the first steps towards the deployment of rendered adversarial data augmentation in real-world applications: we train a classifier with computer-generated adversarial images, evaluating the performance of the training against real photographs (i.e., captured using cameras; Section 5). We test on real photos to show the parametric adversarial data augmentation increases the classifier's robustness to "deformations" happened in the real world. Our evaluation differs from the majority of existing literature which evaluates against computer-generated adversarial images, since our parametric space perturbation is no-longer a wholly idealized representation of the image formation model but, instead, modeled against of theory of realistic image generation.
2 RELATED WORK
Adversarial Examples Szegedy et al. (2013) expose the vulnerability of modern deep neural nets using purposefully-manipulated images with human-imperceptible misclassification-inducing noise. Goodfellow et al. (2014) introduce a fast method to harness adversarial examples, leading to the idea of pixel norm-balls for evaluating adversarial attackers/defenders. Since then, many significant developments in adversarial techniques have been proposed (Akhtar & Mian, 2018; Szegedy et al.,
2

Under review as a conference paper at ICLR 2019

2013; Rozsa et al., 2016; Kurakin et al., 2016a; Moosavi Dezfooli et al., 2016; Dong et al., 2017; Papernot et al., 2017; Moosavi-Dezfooli et al., 2017; Chen et al., 2017; Su et al., 2017). Our work extends this progression in constructing adversarial examples, a problem that lies at the foundation of adversarial machine learning. Kurakin et al. (2016b) study the transferability of attacks to the physical world by printing then photographing adversarial images. Athalye & Sutskever (2017) and Evtimov et al. (2017) propose extensions to non-planar (yet, still fixed) geometry and multiple viewing angles. These works still rely fundamentally on direct pixel or texture manipulation on physical objects. Since these methods assume independence between pixels in the image or texture space they remain variants of pixel norm-balls. This leads to unrealistic attack images that cannot model real-world scenarios (Goodfellow, 2018; Hendrycks & Dietterich, 2018; Gilmer et al., 2018). Zeng et al. (2017) generate adversarial examples by altering physical parameters using an abstract rendering network (Liu et al., 2017) trained to approximate the physics of realistic image formation. This data-driven approach leads to an image formation model biased towards the rendering style present in the training data, where renderings lack any significant semblance of realism. This method has to also rely on differentiation through the rendering network in order to compute adversaries, a costly operation (12 minutes are required, on average, to find new adversarial examples). Our approach is based on a differentiable physically-based renderer that directly (and, so, more convincingly) models the image formation process, allowing us to alter physical parameters ­ like geometry and lighting ­ and compute derivatives (and adversarial examples) much more rapidly.

Differentiable Renderer Applying paramet- Table 1: Previous differentiable renderers fall short

ric norm-balls requires that we differentiate the in one way or another among Performance, Bias,

image formation model with respect to the phys- or Accuracy.

ical parameters of the image formation model.

Modern realistic computer graphics models do

Methods

Perf. Unbias Accu.

not expose facilities to directly accommodate the computation of derivatives or automatic differentiation of pixel colors with respect to geometry and lighting variables. A physically-based differentiable renderer is fundamental to com-

NN proxy (Liu 17) Approx. (Kato 18) Autodiff (Loper 14) Analytical (Ours)

puting derivative of pixel colors with respect to scene parameters and can benefit machine learning

in several ways, including promoting the development of novel network architectures (Liu et al.,

2017), in computing adversarial examples (Athalye & Sutskever, 2017; Zeng et al., 2017), and in

generalizing neural style transfer to a 3D context (Kato et al., 2018; Liu et al., 2018). Recently,

various techniques have been proposed to obtain these derivatives: Wu et al. (2017); Liu et al. (2017);

Eslami et al. (2016) use neural networks to learn the image formation process provided a large amount

of input/output pairs. This introduces unnecessary bias in favor of the training data distribution,

leading to inaccurate derivatives due to imperfect learning. Kato et al. (2018) propose a differentiable

renderer based on a simplified image formation model and an underlying linear approximation to

obtain derivatives. Their approach requires no training and is unbiased, but their approximation

introduces errors in the derivative computation. For the sake of obtaining derivatives Loper & Black

(2014); Genova et al. (2018) use automatic differentiation to build fully differentiable renderers.

These renderers, however, are expensive to evaluate, requiring orders of magnitude more compute

and much larger memory footprints compared to the approximate method.

Our novel differentiable renderer overcomes these limitations by efficiently computing accurate (analytical) derivatives of a physically-based image formation model. We model image variations by changing geometry and realistic lighting conditions in an analytically differentiable manner, relying on an accurate model of diffuse image formation that extend spherical harmonics-based shading methods (Appendix C). Our analytic derivatives are efficient to evaluate, have scalable memory consumption, are unbiased, and are accurate by construction (Table 1). Our renderer explicitly models the physics of the image formation processes, and so the images it generates are realistic enough to illicit correct classifications from networks trained on real-world photographs.

3 ADVERSARIAL ATTACKS IN PARAMETRIC SPACES
Adversarial attacks based on pixel norm-balls typically generate adversarial examples by defining a cost function over the space of images C : I  R that enforces some intuition of what failure

3

Under review as a conference paper at ICLR 2019

should look like, typically using variants of gradient descent where the gradient C/I is accessible by differentiating through networks (Szegedy et al., 2013; Goodfellow et al., 2014; Rozsa et al., 2016; Kurakin et al., 2016a; Moosavi Dezfooli et al., 2016; Dong et al., 2017).

The choices for C include increasing the cross-entropy loss of the correct class (Goodfellow et al., 2014), decreasing the cross-entropy loss of the least-likely class (Kurakin et al., 2016a), using a combination of cross-entropies (Moosavi Dezfooli et al., 2016), and more (Szegedy et al., 2013; Rozsa et al., 2016; Dong et al., 2017; Tramèr et al., 2017). We combine of cross-entropies to provide flexibility for choosing untargeted and targeted attacks by specifying different set of labels:

C I(U, V ) = -CrossEntropy f (I(U, V )), Ld + CrossEntropy f (I(U, V )), Li , (1)

where I is the image, f (I) is the output of the classifier, Ld, Li are labels which a user wants to decrease and increase the predicted confidences respectively. In our experiments, Ld is the correct class and Li is either ignored or chosen according to user preference. Our adversarial attacks in the parametric space consider an image I(U, V ) is the function of physical parameters of the image
formation model, including the lighting U and the geometry V . Adversarial examples constructed by
perturbing physical parameters can then be computed via the chain rule

C C I =
U I U

C C U =,
V I V

(2)

where I/U, I/V are derivatives with respect to the physical parameters and we evaluate using our physically based differentiable renderer. In our experiments, we use gradient descent for finding parametric adversarial examples where the gradient is the direction of I/U, I/V .

3.1 PHYSICALLY BASED DIFFERENTIABLE RENDERER

Rendering is the process of generating a 2D image from a 3D scene by simulating the physics of light. Light sources in the scene emit photons that then interact with objects in the scene. At each interaction, photons are either reflected, transmitted or

Log-log Runtime (sec./iter.)

Time OpenDR
101

Out of memory

absorbed, changing trajectory and repeating until arriving at a sensor such as a camera. A physically based renderer models the

100 Our approach

interactions mathematically (Pharr et al., 2016), and our task is to analytically differentiate the physical process.

10-1 1

2 3 45 #variables (x103)

We develop our differentiable renderer with common assump- Figure 3: Our differentiable rentions in real-time rendering (Akenine-Moller et al., 2008) ­ dif- derer based on analytical derivafuse material, , local illumination, and distant light sources. Our tives is faster and more scalable diffuse material assumption considers materials which reflect then the previous method (Loper lights uniformly for all directions, equivalent to considering non- & Black, 2014). specular objects. We assume that variations in material (texture)

are piece-wise constant with respect to our triangle mesh discretization. The local illumination

assumption only considers light that bounce directly from the light source to the camera. Lastly, we

assume light sources are far away from the scene, allowing us to represent lighting with one spherical

function. For a more detailed rationale of our assumptions, we refer readers to Appendix B).

These assumptions simplify the complicated integral required for rendering (Kajiya, 1986) and allow us to represent lighting in terms of spherical harmonics, an orthonormal basis for spherical functions analogous to Fourier transformation. Thus, we can analytically differentiate the rendering equation to acquire derivatives with respect to lighting, geometry, and texture (derivations found at Appendix C).

Using analytical derivatives avoids pitfalls of previous differentiable renderers (see Section 2) and make our differentiable renderer orders of magnitude faster than the previous fully differentiable renderer OPENDR (Loper & Black, 2014) (see Figure 3). In terms of scalability, our approach can handle problems with more than 100,000 variables, while OPENDR runs out of memory for problems with more than 3,500 variables.

3.2 ADVERSARIAL LIGHTING AND GEOMETRY
Adversarial lighting denotes adversarial examples generated by changing the spherical harmonics lighting coefficients U (Green, 2003). As our differentiable renderer allows us to compute I/U

4

Under review as a conference paper at ICLR 2019

t-shirt 86%

Top 5: miniskirt 28% t-shirt 21% boot 6% crutch 5% sweatshirt 5%

street sign 57%

Top 5: water tower 48% street sign 18% mailbox 9% gas pump 3% barn 3%

Figure 4: By changing the lighting, we fool the classifier into seeing miniskirt and water tower, demonstrating the existence of adversarial lighting.

boot 98%

boot 98%

boot 100%

watter bottle 15% cannon 20% sleeping bag 98%

Figure 5: We construct a single lighting condition that can simultaneously fool the classifier viewing from different angles.

analytically (derivation is provided in Appendix C.4), we can simply apply the chain rule:

U



U

-

C 

I

,

I U

(3)

where C/I is the derivative of the cost function with respect to pixel colors and can be obtained by differentiating through the network. Spherical harmonics act as a implicit constraint to prevent unrealistic lighting because natural lighting environments everyday life are dominated by lowfrequency signals. For instance, rendering of diffuse materials can be approximated with only 1% pixel intensity error by the first 2 orders of spherical harmonics (Ramamoorthi & Hanrahan, 2001). As computers can only represent a finite number of coefficients, using spherical harmonics for lighting implicitly filters out high-frequency, unrealistic lightings. Thus, perturbing the parametric space of spherical harmonics lighting gives us more realistic compared to image-pixel perturbations Figure 1.

Adversarial geometry are our adversarial examples computed by changes the position of the shape's surface. The shape is encoded as a triangle mesh with |V | vertices and |F | faces, surface points are vertex positions V  R|V |×3 which determine per-face normals N  R|F |×3 which in turn determine the shading of the surface. We can compute adversarial shapes by applying the chain rule:

V

V

-  C

I

N ,

I N V

(4)

where I/N is computed via a derivation in Appendix E. Each triangle only has
one normal on its face, making N/V computable analytically. In particular, the 3 × 3 Jacobian of a unit face normal vector ni  R3 of the jth face of the triangle mesh V with respect to one of its corner vertices vj  R3 is

ni

hij vj

ni vj

=

hij niT hij 2

,

where hij  R3 is the height vector: the shortest vector to the corner vj from the opposite edge.

4 RESULTS AND EVALUATION
We have described how to compute adversarial examples by parametric perturbations, including lighting and geometry. In this section, we show that adversarial examples exist in the parametric spaces, then we analyze the characteristics of those adversaries and parametric norm-balls.
We use 49 × 3 spherical harmonics coefficients to represent environment lighting, with an initial realworld lighting condition (Ramamoorthi & Hanrahan, 2001). Camera parameters and the background

5

Under review as a conference paper at ICLR 2019 perturbation

perturbation

loggerhead Top 3: assault rifle 87%, military turtle 67% uniform 6%, six-gun 1%

banana 99% Top 3: slug 91%, roundworm 3%, banana 1%

Figure 6: Perturbing points on 3D shapes fools the classifier into seeing rifle/slug.

street sign 91% street sign 99% street sign 86%

mailbox 51% mailbox 61% mailbox 71%

Figure 7: We construct a single adversarial geometry that fools the classifier seeing a mailbox from different angles.

images are empirically chosen to have correct initial classifications and avoid synonym sets. In Figure 4 we show that single-view adversarial lighting attack can fool the classifier (pre-trained ResNet-101 on ImageNet (He et al., 2016)). Figure 5 shows multi-view adversarial lighting, which optimizes the summation of the cost functions for each view, thus the gradient is computed as the summation over all camera views:

U U-

 C Ii .

icameras Ii U

(5)

If one is interested in a more specific subspace, such as outdoor lighting conditions governed by sunlight and weather, our adversarial lighting can adapt to it. In Figure 9, we compute adversarial lights over the space of skylights by applying one more chain rule to the Preetham skylight parameters (Preetham et al., 1999; Habel et al., 2008). Details about taking these derivatives is provided in Appendix D. Although adversarial skylight exist, its low degrees of freedom (only three parameters) makes it more difficult to find adversaries.

In Figure 6 and Figure 7 we show the existence of adversarial geometry in both single-view and multi-view cases. Note that we upsample meshes to have >10K vertices as a preprocessing step to increase the degrees of freedom available for perturbations. Multi-view adversarial geometry enables us to perturb the same 3D shape from different viewing directions, which enables us to construct a deep optical illusion: The same 3D shape are classified differently from different angles. To create the optical illusion in Figure 8, we only need to specify the Li in Equation (1) to be a dog and a cat for two different views.

missile 49%

wing 33%

Figure 9: Even if we further constrain to a lighting subspace, skylight, we can still find adversaries.

jaguar 61%

jaguar 80%

Egyptian cat 90%

hunting dog 93%

Figure 8: By specifying different target labels, we can create an optical illusion: a jaguar is classified as cat and dog from two different views after geometry perturbations.

6

Under review as a conference paper at ICLR 2019

Table 2: We evaluate ResNet advrsaries on unseen models and show that parametric adversarial examples also share across models. The table shows the success rate of attacks (%).
Alex VGG Squeeze Dense
Lighting 81.2% 65.0% 78.6% 43.5% Geometry 70.3% 58.9% 71.1% 40.1%

Table 3: We compute parametric adversaries using a subset of views (#Views) and evaluate the the success rates (%) of attacks on unseen views.

#Views 0 1

5

Lighting 0.0% 29.4% 64.2% Geometry 0.0% 0.6% 3.6%

4.1 PROPERTIES OF PARAMETRIC NORM-BALLS AND ADVERSARIES

To further understand parametric adversaries, we analyze how do parametric adversarial examples generalize to black-box models. In Table 2, we test 5,000 ResNet parametric adversaries on unseen networks including AlexNet (Krizhevsky et al., 2012), DenseNet (Huang et al., 2017), SqueezeNet (Iandola et al., 2016), and VGG (Simonyan & Zisserman, 2014). Our result shows that parametric adversarial examples also share across models.

In addition to different models, we evaluate parametric adversaries on black-box viewing directions. This evaluation mimics the real-world scenario that a self-driving car would "see" a stop sign from different angles while driving. In Table 3, we randomly sample 500 correctly classified views for a given shape and perform adversarial lighting and geometry algorithms only on a subset of views, then evaluate the resulting adversarial lights/shapes on all the views. The results show that adversarial lights are more generalizable to fool unseen views; adversarial shapes, yet, are less generalizable.

Switching from pixel norm-balls to parametric init. light adv. light

init. geo. adv. geo.

norm-balls only requires to change the norm-

constraint from the pixel color space to the

parametric space. For instance, we can per-

form a quantitative comparison between para-

metric adversarial and random perturbations in Figure 10. We use L-norm = 0.1 to constraint the perturbed magnitude of each lighting coefficient, and L-norm = 0.002 to

Adv. lighting 61.0%

Random lighting
9.1%

Adv. Random geometry geometry
95.3% 17.5%

constrain the maximum displacement of surface points along each axis. The results show how many parametric adversaries can fool the classifier out of 10,000 adversarial lights and shapes respectively. Not only do the parametric norm-balls show the effectiveness of adver-

Figure 10: A quantitative comparison using parametric norm-balls shows the fact that adversarial lighting/geometry perturbations have higher success rate (%) in fooling classifiers comparing to random perturbations in the parametric spaces.

sarial perturbation, evaluating robustness using parametric norm-balls has real-world implications.

Runtime Figure 11 presents our runtime per iteration for computing derivatives. An adversary normally requires less than 10 iterations, thus takes a few seconds. We evaluate our serial python implementation, except the rendering is implemented using OPENGL (Shreiner & Group, 2009), on an Intel Xeon 3.5GHz CPU with 64GB of RAM and an NVIDIA GeForce GTX 1080. Due to the CPU imple-

Time (sec.)
1
.1

Adversarial Lighting
54K vertices 25K vertices 15K vertices

.01 105

106

Adversarial Geometry
54K vertices 25K vertices 15K vertices 105 106 #pixel

Figure 11: We reports the runtime of our adversarial lighting and geometry.

mentation, our runtime depends on the number of pixels that require to take derivatives.

5 RENDERED ADVERSARIAL DATA AUGMENTATION AGAINST REAL PHOTOS
We inject adversarial examples, generated using our differentiable renderer, into the training process of modern image classifiers. Our goal is to increase the robustness of these classifiers to real-world perturbations. Traditionally, adversarial training is evaluated against computer-generated adversarial images (Kurakin et al., 2016a; Madry et al., 2017; Tramèr et al., 2017). In contrast, our evaluation differs from the majority of the literature, as we evaluate performance against real photos (i.e., images captured using a camera), and not computer-generated images. This evaluation method is motivated

7

Under review as a conference paper at ICLR 2019

by our goal of increasing a classifier's robustness to "perturbations" that occur in the real world and result from the physical processes underlying real-world image formation. We present preliminary steps towards this objective, resolving the lack of realism of pixel norm-balls and evaluating our augmented classifiers (i.e., those trained using our rendered adversaries) against real photographs.

Training We train the WideResNet (16 layers, 4 wide factor) (Zagoruyko & Komodakis, 2016) on CIFAR-100 (Krizhevsky & Hinton, 2009) augmented with adversarial lighting examples. We apply a common adversarial training method that adds a fixed number of adversarial examples each epoch (Kurakin et al., 2016a), where the proportion of adversarial images is set to 0.1% and the batch size is set to 128. In our experiments, we compare three training scenarios: (1) CIFAR-100, (2) CIFAR-100 + 100 images under random lighting, and (3) CIFAR-100 + 100 images under adversarial lighting. Comparing to the accuracy reported in (Zagoruyko & Komodakis, 2016), WideResNets trained on these three cases all have comparable performance ( 77%) on the CIFAR-100 test set.

Testing We create a test set of real photos, captured in a lab-

oratory setting with controlled lighting and camera parameters:

we photographed oranges using a calibrated Prosilica GT 1920

camera under different lighting conditions, each generated by

projecting different lighting patterns using an LG PH550 projec-

tor. This hardware lighting setup projects lighting patterns from a fixed solid angle of directions onto the scene objects. Figure 12 illustrates samples from the 500 real photographs of our dataset. We evaluate the robustness of our classifier models according to test accuracy. Of note, average prediction accuracies over five trained WideResNets on our test data under the three training cases are (1) 4.6%, (2) 40.4%, and (3) 65.8%. This result sup-

Figure 12: Unlike much of the literature on adversarial training, we evaluate against real photos (captured by a camera), not computergenerated images. This figure illustrates a subset of our test data.

ports our claim that training on high-quality rendered adversarial images can improve the robustness

of modern classifiers on real photographs. Our result motivate a promising direction of exploration:

models trained adversarially using high-quality rendered images can increase the robustness of

classifier to shading variations in real-world photographs, as the underlying rendering model ap-

proaches an increasingly accurate simulation of the physics of real-world light transport. As synthetic

rendering approaches can provide a theoretically limitless supply of training data, our preliminary

result motivates the potential of relying on such synthetic rendering models for adversarial training of

models that are robust to visual phenomena present in real-world (i.e., external sensor) inputs.

6 LIMITATIONS & FUTURE WORK
Using parametric norm-balls to remove the lack of realism of pixel norm-balls is only the first step to bring adversarial machine learning to real-world. Our preliminary result of rendered adversarial training shows the possibility of deploying adversarial machine learning to reality and more evaluations could uncover the potential. Coupling the differentiable renderer with neural networks to reconstruct 3D scene parameters from images has the potential to develop realistic de-rendering network architectures. With this tool in hand, we can input an image, predicting parameters of the image formation model, manipulating the predicted parameters to construct the parametric adversarial examples, then perform rendered adversarial training. This direction has the potential to produce limitless realistic adversarial data augmentation for machine learning tasks.
The process of creating a high quality labeled dataset is time-consuming. Rendering offers the opportunity to provide theoretically limitless data. Our differentiable renderer models the change of realistic environment lighting and the geometry. Incorporating real-time rendering techniques from the graphics community could further improve the quality of rendering. Removing the locally constant texture assumption could improve our results. As the renderer approaches an increasingly accurate simulation of the physics of real-world, models trained using rendered adversarial training should become increasingly robust to real-world photographic inputs.
Extending the derivative computation to materials could enable "adversarial materials". Propagating gradient information to shape skeleton could also create "adversarial poses". These extensions offer a set of tools for modeling real security scenarios. For instance, we can train a self-driving car classifier that can robustly recognize pedestrians under different poses, lightings, and cloth deformations.

8

Under review as a conference paper at ICLR 2019
REFERENCES
Tomas Akenine-Moller, Eric Haines, and Naty Hoffman. Real-time rendering. AK Peters/CRC Press, 2008.
Naveed Akhtar and Ajmal S. Mian. Threat of adversarial attacks on deep learning in computer vision: A survey. IEEE Access, 6:14410­14430, 2018.
Anish Athalye and Ilya Sutskever. Synthesizing robust adversarial examples. arXiv preprint arXiv:1707.07397, 2017.
Ronen Basri and David W Jacobs. Lambertian reflectance and linear subspaces. IEEE transactions on pattern analysis and machine intelligence, 25(2):218­233, 2003.
Angel X Chang, Thomas Funkhouser, Leonidas Guibas, Pat Hanrahan, Qixing Huang, Zimo Li, Silvio Savarese, Manolis Savva, Shuran Song, Hao Su, et al. ShapeNet: An information-rich 3d model repository. arXiv preprint arXiv:1512.03012, 2015.
Pin-Yu Chen, Huan Zhang, Yash Sharma, Jinfeng Yi, and Cho-Jui Hsieh. Zoo: Zeroth order optimization based black-box attacks to deep neural networks without training substitute models. In Proceedings of the 10th ACM Workshop on Artificial Intelligence and Security, pp. 15­26. ACM, 2017.
Yinpeng Dong, Fangzhou Liao, Tianyu Pang, Hang Su, Xiaolin Hu, Jianguo Li, and Jun Zhu. Boosting adversarial attacks with momentum. arXiv preprint arXiv:1710.06081, 2017.
TM Dunster. Legendre and related functions. NIST handbook of mathematical functions, pp. 351­381, 2010.
SM Ali Eslami, Nicolas Heess, Theophane Weber, Yuval Tassa, David Szepesvari, Geoffrey E Hinton, et al. Attend, infer, repeat: Fast scene understanding with generative models. In Advances in Neural Information Processing Systems, pp. 3225­3233, 2016.
Ivan Evtimov, Kevin Eykholt, Earlence Fernandes, Tadayoshi Kohno, Bo Li, Atul Prakash, Amir Rahmati, and Dawn Song. Robust physical-world attacks on machine learning models. arXiv preprint arXiv:1707.08945, 2017.
Kyle Genova, Forrester Cole, Aaron Maschinot, Aaron Sarna, Daniel Vlasic, and William T. Freeman. Unsupervised training for 3d morphable model regression. In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2018.
Justin Gilmer, Ryan P Adams, Ian Goodfellow, David Andersen, and George E Dahl. Motivating the rules of the game for adversarial example research. arXiv preprint arXiv:1807.06732, 2018.
Ian Goodfellow. Defense against the dark arts: An overview of adversarial example security research and future research directions. arXiv preprint arXiv:1806.04169, 2018.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial examples. arXiv preprint arXiv:1412.6572, 2014.
Robin Green. Spherical harmonic lighting: The gritty details. In Archives of the Game Developers Conference, volume 56, pp. 4, 2003.
Ralf Habel, Bogdan Mustata, and Michael Wimmer. Efficient spherical harmonics lighting with the preetham skylight model. In Eurographics (Short Papers), pp. 119­122, 2008.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770­778, 2016.
Dan Hendrycks and Thomas G Dietterich. Benchmarking neural network robustness to common corruptions and surface variations. arXiv preprint arXiv:1807.01697, 2018.
9

Under review as a conference paper at ICLR 2019
Gao Huang, Zhuang Liu, Laurens van der Maaten, and Kilian Q. Weinberger. Densely connected convolutional networks. In 2017 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2017, Honolulu, HI, USA, July 21-26, 2017, pp. 2261­2269, 2017. doi: 10.1109/CVPR. 2017.243. URL https://doi.org/10.1109/CVPR.2017.243.
Forrest N Iandola, Song Han, Matthew W Moskewicz, Khalid Ashraf, William J Dally, and Kurt Keutzer. Squeezenet: Alexnet-level accuracy with 50x fewer parameters and< 0.5 mb model size. arXiv preprint arXiv:1602.07360, 2016.
James T Kajiya. The rendering equation. In ACM Siggraph Computer Graphics, volume 20, pp. 143­150. ACM, 1986.
Can Kanbak, Seyed-Mohsen Moosavi-Dezfooli, and Pascal Frossard. Geometric robustness of deep networks: analysis and improvement. arXiv preprint arXiv:1711.09115, 2017.
Hiroharu Kato, Yoshitaka Ushiku, and Tatsuya Harada. Neural 3d mesh renderer. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 3907­3916, 2018.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pp. 1097­1105, 2012.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial machine learning at scale. arXiv preprint arXiv:1611.01236, 2016a.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial examples in the physical world. In Proc. ICLR, 2016b.
Guilin Liu, Duygu Ceylan, Ersin Yumer, Jimei Yang, and Jyh-Ming Lien. Material editing using a physically based rendering network. In 2017 IEEE International Conference on Computer Vision (ICCV), pp. 2280­2288. IEEE, 2017.
Hsueh-Ti Derek Liu, Michael Tao, and Alec Jacobson. Paparazzi: Surface editing by way of multi-view image processing. 2018.
Matthew M Loper and Michael J Black. OpenDR: An approximate differentiable renderer. In European Conference on Computer Vision, pp. 154­169. Springer, 2014.
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu. Towards deep learning models resistant to adversarial attacks. arXiv preprint arXiv:1706.06083, 2017.
Gavin Miller. Efficient algorithms for local and global accessibility shading. In Proceedings of the 21st Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH '94, pp. 319­326, New York, NY, USA, 1994. ACM. ISBN 0-89791-667-0. doi: 10.1145/192161.192244. URL http://doi.acm.org/10.1145/192161.192244.
Takeru Miyato, Shin-ichi Maeda, Shin Ishii, and Masanori Koyama. Virtual adversarial training: a regularization method for supervised and semi-supervised learning. IEEE transactions on pattern analysis and machine intelligence, 2018.
Seyed Mohsen Moosavi Dezfooli, Alhussein Fawzi, and Pascal Frossard. Deepfool: a simple and accurate method to fool deep neural networks. In Proceedings of 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), number EPFL-CONF-218057, 2016.
Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, Omar Fawzi, and Pascal Frossard. Universal adversarial perturbations. In 2017 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2017, Honolulu, HI, USA, July 21-26, 2017, pp. 86­94, 2017.
Nicolas Papernot, Patrick McDaniel, Ian Goodfellow, Somesh Jha, Z Berkay Celik, and Ananthram Swami. Practical black-box attacks against machine learning. In Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security, pp. 506­519. ACM, 2017.
10

Under review as a conference paper at ICLR 2019
Matt Pharr, Wenzel Jakob, and Greg Humphreys. Physically based rendering: From theory to implementation. Morgan Kaufmann, 2016.
Arcot J Preetham, Peter Shirley, and Brian Smits. A practical analytic model for daylight. In Proceedings of the 26th annual conference on Computer graphics and interactive techniques, pp. 91­100. ACM Press/Addison-Wesley Publishing Co., 1999.
Ravi Ramamoorthi and Pat Hanrahan. An efficient representation for irradiance environment maps. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques, pp. 497­500. ACM, 2001.
Andras Rozsa, Ethan M Rudd, and Terrance E Boult. Adversarial diversity and hard positive generation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, pp. 25­32, 2016.
Dave Shreiner and The Khronos OpenGL ARB Working Group. OpenGL Programming Guide: The Official Guide to Learning OpenGL, Versions 3.0 and 3.1. Addison-Wesley Professional, 7th edition, 2009. ISBN 0321552628, 9780321552624.
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.
Peter-Pike Sloan, Ben Luna, and John Snyder. Local, deformable precomputed radiance transfer. In ACM Transactions on Graphics (TOG), volume 24, pp. 1216­1224. ACM, 2005.
Jiawei Su, Danilo Vasconcellos Vargas, and Sakurai Kouichi. One pixel attack for fooling deep neural networks. arXiv preprint arXiv:1710.08864, 2017.
Sining Sun, Ching-Feng Yeh, Mari Ostendorf, Mei-Yuh Hwang, and Lei Xie. Training augmentation with adversarial examples for robust speech recognition. arXiv preprint arXiv:1806.02782, 2018.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow, and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
Florian Tramèr, Alexey Kurakin, Nicolas Papernot, Dan Boneh, and Patrick McDaniel. Ensemble adversarial training: Attacks and defenses. arXiv preprint arXiv:1705.07204, 2017.
Lance Williams. Casting curved shadows on curved surfaces. In ACM Siggraph Computer Graphics, volume 12, pp. 270­274. ACM, 1978.
Jiajun Wu, Joshua B Tenenbaum, and Pushmeet Kohli. Neural scene de-rendering. In Proc. CVPR, volume 2, 2017.
Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. In Proceedings of the British Machine Vision Conference 2016, BMVC 2016, York, UK, September 19-22, 2016, 2016.
Xiaohui Zeng, Chenxi Liu, Weichao Qiu, Lingxi Xie, Yu-Wing Tai, Chi Keung Tang, and Alan L Yuille. Adversarial attacks beyond the image space. arXiv preprint arXiv:1711.07183, 2017.
11

Under review as a conference paper at ICLR 2019

Supplementary Material

A COMPARISON BETWEEN PERTURBATION SPACES

We extend our comparisons against pixel norm-balls methods (Figure 1) by visualizing the results and the generated perturbations (Figure 13). We hope this figure elucidates that our parametric perturbation are more realistic several scales of perturbations.

one-step pixel multi-step pixel texture color

[Goodfellow 14] [Moosavi Dezfooli 16]

[Athalye 18]

parametric (lighting)

parametric (geometry)

original image

img. diff. x0.5 large norm img. diff. x1 med. norm img. diff. x5 small norm

Figure 13: We compare our parametric perturbations (the first two columns) with pixel/color perturbations under the same L pixel norm (small: 0.12, medium: 0.53, large: 0.82). As changing physical parameters corresponds to real-world phenomena, our parametric perturbation are more realistic.

B PHYSICALLY BASED RENDERING

light source

Physically based rendering (PBR) seeks to model the flow of

light, typically the assumption that there exists a collection of

light sources that generate light; a camera that receives this

light; and a scene that modulates the flow light between the light Camera sources and camera (Pharr et al., 2016). What follows is a brief

discussion of the general task of rendering an image from a scene

scene

description and the approximations we take in order to make our

renderer efficient yet differentiable.

Figure 14: PBR models the

Computer graphics has dedicated decades of effort into devel- physics of light that emitted from

oping methods and technologies to enable PBR to synthesize the light source, interact with the

of photorealistic images under a large gamut of performance scene, then arrive a camera.

12

Under review as a conference paper at ICLR 2019

requirements. Much of this work is focused around taking approximations of the cherished Rendering equation (Kajiya, 1986), which describes the propagation of light through a point in space. If we let uo be the output radiance, p be the point in space, o be the output direction, ue be the emitted radiance, ui be incoming radiance, i be the incoming angle, fr be the way light be reflected off the material at that given point in space we have:
uo(p, o) = ue(p, o) + fr(p, i, o)ui(p, i)(i · n)di.
S2
From now on we will ignore the emission term ue as it is not pertinent to our discussion. Furthermore, because the speed of light is substantially faster than the exposure time of our eyes, what we perceive is not the propagation of light at an instant, but the steady state solution to the rendering equation evaluated at every point in space. Explicitly computing this steady state is intractable for our applications and will mainly serve as a reference for which to place a plethora of assumptions and simplifications we will make for the sake of tractability. Many of these methods focus on ignoring light with nominal effects on the final rendered image vis a vis assumptions on the way light travels. For instance, light is usually assumed to have nominal interacts with air, which is described as the assumption that the space between objects is a vacuum, which constrains the interactions of light to the objects in a scene. Another common assumption is that light does not penetrate objects, which makes it difficult to render objects like milk and human skin1. This constrains the complexity of light propagation to the behavior of light bouncing off of object surfaces.

B.1 LOCAL ILLUMINATION

It is common to see assumptions that limit number of bounces light is allowed.In our case we chose to assume that the steady state is sufficiently approximated by an extremely low number of iterations: one. This means that it seems sufficient to model the lighting of a point in space by the light sent to it directly by light sources. Working with such a strong simplification does, of course, lead to a few artifacts. For instance, light occluded by other objects is ignored so shadows disappear and auxiliary techniques are usually employed to evaluate shadows (Williams, 1978; Miller, 1994).

Figure 15: Rasterization converts a 3D scene into pixels.

When this assumption is coupled with a camera we approach what is used in standard rasterization systems such as OPENGL (Shreiner & Group, 2009), which is what we use. These systems compute the illumination of a single pixel by determining the fragment of an object visible through that pixel and only computing the light that traverses directly from the light sources, through that fragment, to that pixel. The lighting of a fragment is therefore determined by a point and the surface normal at that point, so we write the fragment's radiance as R(p, n, o) = uo(p, o):

R(p, n, o) = fr(p, i, o)ui(p, i)(i · n)di.
S2

(6)

B.2 LAMBERTIAN MATERIAL

Each point on an object has a model approximating the transfer

Lambertian Non-Lambertian

of incoming light to a given output direction fr, which is usually

called the material. On a single object the material parameters

may vary quite a bit and the correspondence between points and

material parameters is usually called the texture map which forms

the texture of an object. There exists a wide gamut of material models, from mirror materials that transport light from a single input direction to a single output direction, to materials that reflect light evenly in all directions, to materials liked brushed metal that reflect differently along different angles. For the sake

Figure 16: We consider the Lambertian material (left) where lights get reflected uniformly in every direction.

of document we only consider diffuse materials, also called Lambertian materials, where we assume

1this is why simple renderers make these sorts of objects look like plastic

13

Under review as a conference paper at ICLR 2019

that incoming light is reflected uniformly, i.e fr is a constant function with respect to angle, which we denote fr(p, i, o) = (p):

R(p, n) = (p)

u(p, )( · n)d.

(n)

(7)

This function  is usually called the albedo, which can be perceived as color on the surface for diffuse material, and we reduce our integration domain to the upper hemisphere (n) in order to model light not bouncing through objects. Furthermore, since only the only  and u are the incoming ones we can now suppress the "incoming" in our notation and just use  and u respectively.

B.3 ENVIRONMENT MAPPING

The illumination of static, distant objects such as the ground, the sky, or mountains do not change in any noticeable fashion when objects in a scene are moved around, so u can be written entirely in terms of , u(p, ) = u(). If their illumination forms a constant it seems prudent to pre-compute or cache their contributions to the illumination of a scene. This is what is usually called environment mapping and they fit in the rendering equation as a representation for the total lighting of a scene, i.e the total incoming radiance ui. Because the environment is distant, it is common to also assume that the position of the object receiving light from an environment map does not matter so this simplifies ui to be independent of position:

R(p, n) = (p)

u() ( · n) d.

(n)

(8)

B.4 SPHERICAL HARMONICS
Despite all of our simplifications, the inner integral is still a fairly generic function over S2. Many techniques for numerically integrating the rendering equation have emerged in the graphics community and we choose one which enables us to perform pre-computation and select a desired spectral accuracy: spherical harmonics. Spherical harmonics are a basis on S2 so, given a spherical harmonics expansion of the integrand, the evaluation of the above integral can be reduced to a weighted product of coefficients. This particular basis is chosen because it acts as a sort of Fourier basis for functions on the sphere and so the bases are each associated with a frequency, which leads to a convenient multi-resolution structure. In fact, the rendering of diffuse objects under distant lighting can be 99% approximated by just the first few spherical harmonics bases (Ramamoorthi & Hanrahan, 2001).
We will only need to note that the spherical harmonics bases Ylm are denoted with the subscript with l as the frequency and that there are 2l + 1 functions per frequency, denoted by superscripts m between -l to l inclusively. For further details on them please take a glance at Appendix C.
If we approximate a function f in terms of spherical harmonics coefficients f  lm fl,mYlm the integral can be precomputed as

f

fl,mYlm =

fl,m

Ylm,

S2 S2 lm

lm S2

(9)

Thus we have defined a reduced rendering equation that can be efficiently evaluated using OPENGL while maintaining differentiability with respect to lighting and vertices. In the following appendix we will derive the derivatives necessary to implement our system.

C DIFFERENTIABLE RENDERER
Rendering computes an image of a 3D shape given lighting conditions and the prescribed material properties on the surface of the shape. Our differentiable renderer assumes Lambertian reflectance, distant light sources, local illumination, and piece-wise constant textures. We will discuss how to explicitly compute the derivatives used in the main body of this text. Here we give a detailed discussion about spherical harmonics and their advantages.

14

Under review as a conference paper at ICLR 2019

C.1 SPHERICAL HARMONICS

Spherical harmonics are usually defined in terms of the Legendre polynomials, which are a class of orthogonal polynomials defined by the recurrence relation

P0 = 1 P1 = x (l + 1)Pl+1(x) = (2l + 1)xPl(x) - lPl-1(x).

(10) (11) (12)

The associated Legendre polynomials are a generalization of the Legendre polynomials and can be fully defined by the relations

Pl0 = Pl (l - m + 1)Plm+1(x) = (2l + 1)xPlm(x) - (l + m)Plm-1(x)

(13) (14)

2mxPlm(x) = - 1 - x2 Plm+1(x) + (l + m)(l - m + 1)Plm-1(x) . (15)

Using the associated Legendre polynomials Plm we can define the spherical harmonics basis as

(-1)m 

2Pl-m

(cos

)

sin(-m)

m<0

Ylm(, ) = Klm (-1)m 2Plm(cos ) cos(m)

m>0.

(16)

Pl0(cos )

m=0

where Klm =

(2l + 1)(l - |m|)! 4(l + |m|)! .

(17)

We will use the fact that the associated Legendre polynomials correspond to the spherical harmonics bases that are rotationally symmetric along the z axis (m = 0).
In order to incorporate spherical harmonics into Equation 8, we change the integral domain from the upper hemisphere (n) back to S2 via a max operation

R(p, n) = (p)

u()( · n)d

(n)

(18)

= (p) u() max( · n, 0)d.
S2

(19)

We see that the integral is comprised of two components: a lighting component u() and a component that depends on the normal max( · n, 0). The strategy is to pre-compute the two components by projecting onto spherical harmonics, and evaluating the integral via a dot product at runtime, as we will now derive.

C.2 LIGHTING IN SPHERICAL HARMONICS

Approximating the lighting component u() in Equation 19 using spherical harmonics Ylm up to band n can be written as

nl

u() 

Ul,mYlm(),

l=0 m=-l

where Ul,m  R are coefficients. By using the orthogonality of spherical harmonics we can use evaluate these coefficients as an integral between u() and Ylm()

Ul,m = u, Ylm S2 = u()Ylm()d,
S2
which can be evaluated via quadrature.

C.3 CLAMPED COSINE IN SPHERICAL HARMONICS
So far, we have projected the lighting term u() onto the spherical harmonics basis. To complete evaluating Equation 19 we also need to approximate the second component max( · n, 0) in spherical

15

Under review as a conference paper at ICLR 2019

harmonics. This is the so-called the clamped cosine function.

nl

g(, n) = max( · n, 0) =

Gl,m(n)Ylm(),

l=0 m=-l

where Gl,m(n)  R can be computed by projecting g(, n) onto Ylm()

Gl,m(n) = max( · n, 0)Ylm()d.
S2
Unfortunately, this formulation turns out to be tricky to compute. Instead, the common practice is to analytically compute the coefficients for unit z direction G~l,m = Gl,m(nz) = Gl,m([0, 0, 1] ) and evaluate the coefficients for different normals Gl,m(n) by rotating G~l,m. This rotation, G~l,m, can be computed analytically:

G~l,m = = = =

max( · nz, 0)Ylm()d
S2
2 
max([sin  cos , sin  sin , cos ][0, 0, 1] , 0)Ylm(, ) sin dd
00
2 
max(cos , 0)Ylm(, ) sin dd
00
2 /2
cos  Ylm(, ) sin dd.
00

(20)

In fact, because max( · nz, 0) is rotationally symmetric around the z-axis, its projection onto Ylm() will have many zeros except the rotationally symmetric spherical harmonics Yl0. In other words, G~l,m is non-zero only when m = 0. So we can simplify Equation 20 to

/2

G~l = G~l,0 = 2

cos  Yl0() sin d.

0

The evaluation of this integral can be found in Appendix A in (Basri & Jacobs, 2003). We provide

this here as well:



 

 

2

 



G~l

=

3



(-1)  

l 2

+1

(l-2)! (2l+1)

2l

(

l 2

-1)!(

l 2

+1)!

0

l=0 l=1
. l  2, even
l  2, odd

The spherical harmonics coefficients Gl,m(n) of the clamped cosine function g(, n) can be computed by rotating G~l (Sloan et al., 2005) using this formula

Gl,m(n) =

4 2l +

1

G~l

Ylm(n).

(21)

So far we have projected the two terms in Equation 19 into the spherical harmonics basis. Orthogonality of spherical harmonics makes the evaluation of this integral straightforward:

u() max( · n, 0)d =

Ul,mYlm()

S2 S2 l,m

Gj,k(n)Yjk() d
j,k

= Ul,mGj,k(n)jl km
j,k,l,m

= Ul,mGl,m(n).
l,m

(22) (23)

16

Under review as a conference paper at ICLR 2019

This, in conjunction with Equation 21allows us to derive the rendering equation using spherical harmonics lighting for Lambertian objects:

nl

R(p, n) = (p)

Ul,m

l=0 m=-l

4 2l +

1

G~l

Ylm(n).

(24)

So far we have only considered the shading of a specific point p with surface normal n. If we consider the rendered image I given a shape V , lighting U , and camera parameters , the image I is the evaluation of the rendering equation R of each point in V visible through each pixel in the image. This pixel to point mapping is determined by . Therefore, we can write I as

n
I(V, U, ) = (V, )

l

Ul,m

4 2l +

1

G~l

Ylm(N

(V

)),

l=0 m=-l

(25)

F (V,U )

where N (V ) is the surface normal. We exploit the notation and use (V, ) to represent the texture of V mapped to the image space through .

C.4 LIGHTING AND TEXTURE DERIVATIVES

For our applications we must differentiate Equation 25 with respect to lighting and material parameters. The derivative with respect to the lighting coefficients U can be obtained by

I 

F

= F +

U U

U

n l F

=0+

.

l=0 m=-l Ul,m

(26) (27)

This is the Jacobian matrix that maps from spherical harmonics coefficients to pixels. The term /F Ul,m can then be computed as

F =
Ul,m

4 2l +

1 G~l

Ylm(N

(V

)).

(28)

The derivative with respect to texture is defined by

I n l

= 

Ul,m

l=0 m=-l

4 2l +

1

G~l

Ylm(N (V

)).

(29)

D DIFFERENTIATING SKYLIGHT PARAMETERS

To model possible outdoor daylight conditions, we use the analytical Preetham skylight model
(Preetham et al., 1999). This model is calibrated by atmospheric data and parameterized by two intuitive parameters: turbidity  , which describes the cloudiness of the atmosphere, and two polar angles s  [0, /2], s  [0, 2], which are encode the direction of the sun. Note that s, s are not the polar angles ,  for representing incoming light direction  in u(). The spherical harmonics
representation of the Preetham skylight is presented in (Habel et al., 2008) as

6l

u() =

Ul,m(s, s,  )Ylm().

l=0 m=-l

This is derived by first performing a non-linear least squares fit to write Ul,m as a polynomial of s and  which lets them solve for U~l,m(s,  ) = Ul,m(s, 0,  )

13 7

U~l,m(s,  ) =

(pl,m)i,j si  j ,

i=0 j=0

17

Under review as a conference paper at ICLR 2019

where (pl,m)i,j are scalar coefficients, then Ul,m(s, s,  ) can be computed by applying a spherical harmonics rotation with s using
Ul,m(s, s,  ) = U~l,m(s,  ) cos(ms) + U~l,-m(s,  ) sin(ms).
We refer the reader to (Preetham et al., 1999) for more detail. For the purposes of this article we just need the above form to compute the derivatives.

D.1 DERIVATIVES

The derivatives of the lighting with respect to the skylight parameters (s, s,  ) are

Ul,m(s, s,  ) s

=

-mU~l,m(s,  ) sin(ms)

+

mU~l,-m(s,  ) cos(ms)

Ul,m(s, s,  ) = U~l,m(s,  ) cos(ms) + U~l,-m(s,  ) sin(ms) s s

= isi-1 j (pl,m)i,j cos(ms) + isi-1(pl,-m)i,j sin(ms)
ij ij

Ul,m(s, s,  ) = 

jsi  j-1(pl,m)i,j cos(ms) +

jsi  j-1(pl,-m)i,j sin(ms)

ij ij

(30) (31) (32)
(33)

E DERIVATIVES OF SURFACE NORMALS

Taking the derivative of the rendered image I with respect to surface normals N is an essential task for computing the derivative of I with respect to the geometry V . Specifically, the derivative of the rendering equation Equation 25 with respect to V is

I 

F

= F +

V V

V

 F N = F +
V N V

(34) (35)

We assume the texture variations are piece-wise constant with respect to our triangle mesh discretization and omit the first term /V as the magnitude is zero. Computing N/V is provided in Section 3.2. Computing F/Ni on face i is

F n l

Ni

=

Ul,m
l=0 m=-l

4 2l +

1

G~l

Ylm Ni

,

(36)

where the /Ylm Ni is the derivative of the spherical harmonics with respect to the face normal Ni.
To begin this derivation recall the relationship between a unit normal vector n = (nx, ny, nz) and its corresponding polar angles , 

 = cos-1

nz nx2 + n2y + nz2

 = tan-1 ny , nx

18

Under review as a conference paper at ICLR 2019

we can compute the derivative of spherical harmonics with respect to the normal vector through

Ylm(, )

n

 (-1)m 2   

Pl-m(cos 

)

 n

sin(-m)

+

Pl-m(cos

)



sin(-m) 

 n



=

Klm

 



(-1)m 2



Plm(cos 

)

 n

cos(m)

+

Plm(cos

)



cos(m) 

 n





   

Pl0(cos

)





 n

 (-1)m 2   

Pl-m(cos 

)

 n

sin(-m)

-

mPl-m(cos

)

cos(-m)

 n



=

Klm

 



(-1)m 2



Plm(cos 

)

 n

cos(m)

-

mPlm(cos

)

sin(m)

 n





   

Pl0(cos

)





 n

m<0 m>0 m=0 m<0 m>0 m=0
(37)

Note that the derivative of the associated Legendre polynomials Plm(cos ) can be computed by applying the recurrence formula Dunster (2010)

Plm(cos ) 

=

- cos (l

+

1)Plm(cos ) + (l - cos2  - 1

m

+

1)Plm+1(cos )

×

(- sin )

= - cos (l + 1)Plm(cos ) + (l - m + 1)Plm+1(cos ) . sin 

(38)

Thus the derivatives of polar angles (, ) with respect to surface normals n = [nx, ny, nz] are

 =
n 
= n

   ,,
nx ny nz   
,, nx ny nz

= nxnz, nynz, -(n2x + n2y) , (n2x + ny2 + n2z) n2x + ny2

=

-ny nx2 + n2y

,

nx2

nx +

n2y

,

0

.

(39) (40)

In summary, the results of Equation 37, Equation 38, Equation 39, and Equation 40 tell us how to compute Ylm/Ni. Then the derivative of the pixel j with respect to vertex p which belongs to face i
can be computed as

Ij Vp



F j Ni

Ni Vp

nl

= j

Ul,m

l=0 m=-l

4 2l +

1

G~l



Ylm(, Ni

)

Ni Vp

.

(41)

19

Under review as a conference paper at ICLR 2019

F EVALUATE RENDERING QUALITY

We evaluated our rendering quality by whether our rendered images are recognizable by models trained on real photographs.

Histogram of Model Confidence

number of images

Although large 3D shape datasets, such as ShapeNet (Chang

et al., 2015), are available, they do not have have geometries

or textures at the resolutions necessary to create realistic ren-

derings. We collected 75 high-quality textured 3D shapes from

cgtrader.com and turbosquid.com to evaluate our rendering quality. We augmented the shapes by changing the field of view, backgrounds, and viewing directions, then keep the configu-

0 .2 .4 .6 .8 1
Confidence (max: 1)

rations that were correctly classified by a pre-trained ResNet-101 on ImageNet. Specifically, we place the centroid, calculated as the weighted average of the mesh vertices where the weights are the vertex areas, at the origin and normalize shapes to range -1 to 1; the field of view is chosen to be 2 and 3 in the same unit with the normalized shape; background images include plain colors

Figure 17: Prediction confidence on rendered images, showing our rendering quality is faithful enough to be confidently recognized by ImageNet models.

and real photos, which have small influence on model predictions; viewing directions are chosen to

be 60 degree zenith and uniformly sampled 16 views from 0 to 2 azimuthal angle. In Figure 17, we

show that the histogram of model confidence on the correct labels over 10,000 correctly classified

rendered images from our differentiable renderer. The confidence is computed using softmax function

and the results show that our rendering quality is faithful enough to be recognized by models trained

on natural images.

20

