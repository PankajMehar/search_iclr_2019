Under review as a conference paper at ICLR 2019
GRAPH TRANSFORMATION POLICY NETWORK FOR CHEMICAL REACTION PREDICTION
Anonymous authors Paper under double-blind review
ABSTRACT
We address a fundamental problem in chemistry known as chemical reaction product prediction. Our main insight is that the input reactant and reagent molecules can be jointly represented as a graph and the process of generating product molecules from reactant molecules (reaction mechanism) can be formulated as a sequence of graph transformations. To this end, we propose Graph Transformation Policy Network (GTPN) - a novel generic method that combines the strengths of graph neural networks and reinforcement learning to learn the reaction mechanisms directly from known reactions with minimal chemical knowledge. Compared to previous methods, GTPN has some appealing properties such as: end-to-end learning, and making no assumption about the length or the order of graph transformations. In order to guide model search through the complex discrete space of sets of bond changes effectively, we extend the standard policy gradient loss by adding useful constraints. Evaluation results show that GTPN improves the top-1 accuracy over the current state-of-the-art method by about 3% on the large USPTO dataset, setting a new record of 83.2%. Our model's performances and prediction errors are also analyzed carefully in the paper.
1 INTRODUCTION
Chemical reaction product prediction is a fundamental problem in organic chemistry. It paves the way for planning syntheses of new substances (Chen & Baldi, 2009). For decades, huge effort has been spent to solve this problem. However, most methods still depend on the handcrafted reaction rules (Chen & Baldi, 2009; Kayala & Baldi, 2011; Wei et al., 2016) or heuristically extracted reaction templates (Segler & Waller, 2017; Coley et al., 2017), thus are not well generalizable to unseen reactions.
A reaction can be regarded as a set or sequence of graph transformations in which reactants represented as molecular graphs are transformed into products by modifying the bonds between some atom pairs. See Fig. 1 for an illustration. We call an atom pair (u, v) that changes its connectivity during reaction and its new bond b a reaction triple (u, v, b). The reaction product prediction problem now becomes predicting a set of reaction triples given the input reactants and reagents. We argue that in order to solve this problem well, an intelligent system should have two key capabilities: (a) Understanding the molecular graph structure of the input reactants and reagents so that it can identify possible reactivity patterns (i.e., atom pairs with changing connectivity). (b) Learning the reaction mechanism so that it can find the correct set of reaction triples to generate the desired products.
Recent state-of-the-art methods (Jin et al., 2017; Bradshaw et al., 2018) have built the first capability by leveraging graph neural networks (Duvenaud et al., 2015; Hamilton et al., 2017; Pham et al., 2017; Gilmer et al., 2017). However, these methods are either unaware of the reaction mechanisms (Jin et al., 2017) or limited to reactions with simple reaction mechanisms (Bradshaw et al., 2018). The main challenge is that the space of all possible configurations of reaction triples is extremely large and non-differentiable. Moreover, a small change in the predicted set of reaction triples can lead to very different reaction products and a little mistake can produce invalid prediction.
In this paper, we propose a novel method called Graph Transformation Policy Network (GTPN) that addresses the aforementioned challenges. Our model consists of three main components: a graph neural network (GNN), a node pair prediction network (NPPN) and a policy network (PN). Starting from the initial graph of reactant and reagent molecules, our model iteratively alternates between
1

Under review as a conference paper at ICLR 2019

C:10 C:11 N:12
C:5 C:4 C:6

O:1 C:2

C:3 C:9

C:7 Br:8

Reactants

C:10 C:11 N:12
C:5 C:4 C:6

O:1 C:2

C:3 C:9

C:7 Br:8

Intermediate Molecules

C:10

C:11

N:12

C:2

O:1

C:5 C:4
C:6

C:3 C:9

C:7 Br:8

Product

Figure 1: A sample reaction represented as a sequence of graph transformations from reactants (leftmost) to products (rightmost). Atoms are labeled with their type (Carbon, Oxygen,...) and their index (1, 2,...) in the molecular graph. The atom pairs that change connectivity and their new bonds (if existed) are highlighted in green. There are two bond changes in this case: 1) The double bond between O:1 and C:2 becomes single. 2) A new single bond between C:2 and C:10 is added.

modeling an input graph using GNN and predicting a reaction triple using NPPN and PN to generate a new intermediate graph as input for the next step until it decides to stop. The final generated graph is considered as the predicted products of the reaction. Importantly, GTPN does not assume any fixed number or any order of bond changes but learn these properties itself. Therefore, one can view GTPN as a reinforcement learning (RL) agent that operates on a complex and non-differentiable space of sets of reaction triples. To guide our model towards learning a diverse yet robust-to-small-changes policy, we customize our loss function by adding some useful constraints to the standard RL loss.
To the best of our knowledge, GTPN is the most generic approach for the reaction product prediction problem so far in the sense that: i) It combines graph neural networks and reinforcement learning into a unified framework and trains everything end-to-end; ii) It does not use any handcrafted or heuristically extracted reaction rules/templates to predict the products. Instead, it automatically learns various reaction mechanisms from the training data and can generalize to unseen reactions; iii) It can interpret how the products are formed via the sequence of reaction triples it generates.
We evaluate GTPN on two large public datasets named USPTO-15k and USPTO. Our method significantly outperforms all baselines in the top-1 accuracy, achieving new state-of-the-art results of 82.39% and 83.20% on USPTO-15k and USPTO, respectively. In addition, we also provide comprehensive analyses about the performance of GTPN and about different types of errors our model could make.
2 METHOD
2.1 CHEMICAL REACTION AS MARKOV DECISION PROCESS OF GRAPH TRANSFORMATIONS
A reaction occurs when reactant molecules interact with each other in the presence (or absence) of reagent molecules to form new product molecules by breaking or adding some of their bonds. Our main insight is that reaction product prediction can be formulated as predicting a sequence of such bond changes (also known as reaction mechanism 1) given the reactant and reagent molecules as input. A bond change is characterized by the atom pair (where the change happens) and the new bond type (what is the change). We call this atom pair a reaction atom pair and call this atom pair with the new bond type a reaction triple.
More formally, we represent the entire system of input reactant and reagent molecules as a labeled graph G = (V, E) with multiple connected components, each of which corresponds to a molecule. Nodes in V are atoms labeled with their atomic numbers and edges in E are bonds labeled with their bond types. Given G as input, we predict a sequence of reaction triples that transforms G into a graph of product molecules G .
As reactions vary in number of transformation steps, we represent the sequence of reaction triples as (, u, v, b)0, (, u, v, b)1, ..., (, u, v, b)T -1 or (, u, v, b)0:T for short. Here T is the maximum number of steps, (u, v) is a pair of nodes, b is the new edge type of (u, v), and  is a binary signal that indicates the end of the sequence. If the sequence ends at Tend < T , 0, ...Tend-1 will be 1 and
1https://en.wikipedia.org/wiki/Chemical_reaction

2

Under review as a conference paper at ICLR 2019

5

3 RNN

4 Top K atom pairs
2
Embedded Nodes 1
Input Graphs

7 6

RNN

Top K atom pairs
Embedded Nodes

...

Figure 2: Workflow of a Graph Transformation Policy Network (GTPN). At every step of the forward pass, our model performs 7 major functions: 1) Computing the atom representation vectors, 2) Computing the most possible K reaction atom pairs, 3) Predicting the continuation signal , 4) Predicting the reaction atom pair (u, v), 5) Predicting a new bond b of this atom pair, 6) Updating the atom representation vectors, and 7) Updating the recurrent state.

Tend , ..., T -1 will be 0. At every step  , if  = 1, we apply the predicted edge change (u, v, b) on the current graph G to create a new intermediate graph G+1 as input for the next step  + 1. This iterative process of graph transformation can be formulated as a Markov Decision Process (MDP) characterized by a tuple (S, A, P, R, ), in which S is a set of states, A is a set of actions, P is a state transition function, R is a reward function, and  is a discount factor. Since the process is finite and contains no loop, we set the discount factor  to be 1. The rest of the MDP tuple are defined as follows:
· State: A state s  S is an intermediate graph G generated at step  (0   < T ). When  = 0, we denote s0 = G0 = G.
· Action: An action a  A performed at step  is the tuple (, u, v, b) . The action is composed of three consecutive sub-actions:  , (u, v) , and b . If  = 0, our model will ignore the next sub-actions (u, v) and b , and all the future actions (, u, v, b)+1:T . Note that setting  to be the first sub-action is useful in case a reaction does not happen, i.e., 0 = 0
· State Transition: If  = 1, the current graph G is modified based on the reaction triple (u, v, b) to generate a new intermediate graph G+1. We do not incorporate chemical rules such as valency check during state transition because the current bond change may result in invalid intermediate molecules G , but later, other bond changes may compensate it to create the valid final products GTend .
· Reward: We use both immediate rewards and delayed rewards to encourage our model to learn the optimal policy faster. At every step  , if the model predicts  , (u, v) or b correctly, it will receive a positive reward for each correct sub-action. Otherwise, a negative reward is given. After the prediction process has terminated, if the generated products are exactly the same as the groundtruth products, we give the model a positive reward, otherwise a negative reward. The concrete reward values are provided in Appendix A.3.

2.2 GRAPH TRANSFORMATION POLICY NETWORK
In this section, we describe the architecture of our model - a Graph Transformation Policy Network (GTPN). GTPN has three main components namely a Graph Neural Network (GNN), a Node Pair Prediciton Network (NPPN), and a Policy Network (PN). Each component is responsible for one or several key functions shown in Fig. 2: GNN performs functions 1 and 6; NPPN performs function 2; and PN performs functions 3, 4 and 5. Apart from these components, GTPN also has a Recurrent
3

Under review as a conference paper at ICLR 2019

Neural Network (RNN) to keep track of the past transformations. The hidden state h of this RNN is used by NPPN and PN to make accurate prediction.
2.2.1 GRAPH NEURAL NETWORK To model the intermediate graph G at step  , we compute the node state vector xi of every node i in G by using a variant of the Message Passing Neural Networks (Gilmer et al., 2017):

xi = MessagePassingm xi-1, vi, N  (i)

(1)

where m is the number of message passing steps; vi is the feature vector of node i; N  (i) is the set of

all neighbor nodes of node i; and xi -1 is the state vector of node i at the previous step. When  = 0, xi -1 is initialized from vi using a neural network. Details about the MessagePassing(.) function are

provided in Appendix A.1.

2.2.2 NODE PAIR PREDICTION NETWORK
In order to predict how likely an atom pair (i, j) of the intermediate graph G will change its bond, we assign (i, j) with a score sij  R. If sij is high, (i, j) is more probably a reaction atom pair, otherwise, less probably. Similar to (Jin et al., 2017), we use two different networks called "local" network and "global" network for this task. In case of the "local" network, sij is computed as:

zij =  W1 h-1, (xi + xj ), eij + b1

(2)

sij = f atom pair zij

(3)

where f atom pair is a neural network;  is a nonlinear activation function (e.g., ReLU); [.] denotes vector concatenation; W1 and b1 are parameters; h-1 is the hidden state of the RNN at the previous step; and eij is the representation vector of the bond between (i, j). If there is no bond between (i, j) we assume that its bond type is "NULL". We consider zij as the representation vector for the atom pair (i, j).

The "global" network leverages self-attention (Vaswani et al., 2017; Wang et al., 2018) to detect compatibility between atom i and all other atoms before computing the scores:

rij =  V1 (xi + xj ), eij + c1 aij = softmax V2rij + c2

ci =

aij xj

jV

z

 ij

=

 W1 h-1, (xi + xj ), (ci + cj ), eij + b1

(4)

sij

=

f atom pair

z

 ij

(5)

where aij is the attention score from node i to every other node j; ci is the context vector of atom i

that summarizes the information from all other atoms.

During experiments, we tried both options mentioned above and saw that the "global" network clearly outperforms the "local" network so we set the "global" network as a default module in our model. In addition, since reagents never change their form during a reaction, we explicitly exclude all atom pairs that have either atoms belong to the reagents. This leads to better results than not using reagent information. Detailed analyses are provided in Appendix A.5.

Top-K atom pairs Because the number of atom pairs that actually participate in a reaction is very
small (usually smaller than 10) compared to the total number of atom pairs of the input molecules
(usually hundreds or thousands), it is much more efficient to identify reaction triples from a small subset of highly probable reaction atom pairs. For that reason, we extract K (K |V|2) atom pairs with the highest scores. Later, we will predict reaction triples taken from these K atom pairs only. We denote the set of top-K atom pairs, their corresponding scores, and representation vectors as
(uk, vk)|k = 1, K , sukvk |k = 1, K and ZK = zukvk |k = 1, K , respectively.

4

Under review as a conference paper at ICLR 2019

2.2.3 POLICY NETWORK

Predicting continuation signal To account for varying number of transformation steps, PN gener-

ates a continuation signal   {0, 1} to indicate whether prediction should continue or terminate.

 is drawn from a Bernoulli distribution:

p ( = 1) = sigmoid f signal h-1, g (ZK )

(6)

where h-1 is the previous RNN state; ZK is the set of representation vectors of the top K atom

pairs at the current step; f signal is a neural network; g is a function that maps an unordered set of

inputs to an output vector. For simplicity, we use a mean function:

zK -1

=

g (ZK )

=

1 K

K

W

z

 -1 uk vk

k=1

Predicting atom pair At the next sub-step, PN predicts which atom pair changes its bond during the reaction by sampling from the top-K atom pairs with probability:

p ((uk, vk) ) = softmaxK su kvk where su kvk is the score of the atom pair (uk, vk) computed in Eq. (5).

(7)

Predicting bond type Given an atom pair (u, v) sampled from the previous sub-step, we predict a new bond type b between u and v to get a complete reaction triple (u, v, b) using the probability:

p (b |(u, v) ) = softmaxB f bond

h -1 ,

z

 uv

,

(eb

-

ebold )

(8)

where B is the total number of bond types; zuv is the representation vector of (u, v) computed in Eq. (4); bold is the old bond of (u, v); ebold and eb are the embedding vectors corresponding to the bond type bold and b, respectively; and f bond is a neural network.

2.3 UPDATING STATES
After predicting a complete reaction triple (u, v, b) , our model updates: i) the new recurrent hidden state h , and ii) the new node representation vectors xi +1 of the new intermediate graph G+1 for i  V. These updates are presented in Appendix A.2.

2.4 TRAINING
Loss function plays a central role in achieving fast training and high performance. We design the following loss:

L = 1Latom pair + 2LA2C + 3Lvalue + 4Lover length + 5Lin top K where Latom pair accounts for binary change in the bond of an atom pair; LA2C is the Advantage Actor-Critic (A2C) loss (Mnih et al., 2016) to account for the correct sequence of reaction triples; Lvalue is the loss for estimating the value function used in A2C; Lover length penalizes long predicted sequences; and Lin top K is the rank loss to force a groundtruth reaction atom pair to appear in the top-K; and 1, ..., 5 > 0 are tunable coefficients. The component losses are explained in the following.
2.4.1 REACTION ATOM PAIR LOSS
This loss function is a cross-entropy loss:

Latom pair = -

(yij log pij + (1 - yij) log(1 - pij))

(9)

iV jV,j=i

where yij  {0, 1} is the label indicating whether the atom pair (i, j) is a reaction atom pair or not; pij = sigmoid(sij) (see Eq. (5)).

5

Under review as a conference paper at ICLR 2019

2.4.2 REACTION TRIPLE LOSS The loss follows a policy gradient method known as Advantage Actor-Critic (A2C):

Tend -1

LA2C = -

Asignal log p ( ) + Aatom pair log p ((u, v) ) + Abond log p (b )

 =0

-ATsigenndal log  Tend

(10)

where Tend is the first step that  = 0; Asignal, Aatom pair and Abond are called advantages. To compute these advantages, we use the unbiased estimations called Temporal Different errors, defined as:

Asignal = rsignal + V ZK +1 - V (ZK )

(11)

Aatom pair = ratom pair + V ZK +1 - V (ZK )

(12)

Abond = rbond + V ZK+1 - V (ZK )

(13)

where rsignal, ratom pair, rbond are immediate rewards at step  ; at the final step  = Tend, the model

receives additional delayed rewards;  is the discount factor; and V is the parametric value function.

We train V using the following mean square error loss:

Tend

Lvalue =

V (ZK ) - R 2

where R is the return at step  .

 =0

(14)

Episode termination during training Although the loss defined in Eq. (10) is correct, it is not
good to use in practice because: i) If our model selects a wrong sub-action at any sub-step of the
step Twrong (Twrong < Tend), the whole predicted sequence will be incorrect regardless of what will be predicted from Twrong + 1 to Tend. Therefore, computing the loss for actions from Twrong + 1 to Tend is redundant. ii) More importantly, the incorrect updates of the graph structure at subsequent steps from Twrong + 1 to Tend will lead to cumulative prediction errors which make the training of our model much more difficult.

To resolve this issue, during training, we use a binary vector   {0, 1}3T to keep track of the first

wrong sub-action: t =

1 0

if t  tfirst wrong if t > tfirst wrong

where

tfirst wrong

denotes

the

sub-step

at

which

our

model chooses a wrong sub-action the first time. The actor-critic loss in Eq. (10) now becomes:

T

LA2C = -

 Asignal log p ( ) + (+1)Aatom pair log p ((u, v) ) + (+2)Abond log p (b )

 =0
(15)

where T is the maximum number of steps. Similarly, we change the value loss into:

T

Lvalue =

 V (ZK ) - R 2

 =0

2.4.3 CONSTRAINT ON THE SEQUENCE LENGTH

One major difficulty of the chemical reaction prediction problem is to know exactly when to stop prediction so we can make accurate inference. By forcing the model to stop immediately when making wrong prediction, we can prevent cumulative error and significantly reduce variance during training. But it also comes with a cost: The model cannot learn (because it does not have to learn) when to stop. This phenomenon can be visualized easily as the model predicts 1 for the signal at every step  during inference. In order to make the model aware of the correct sequence length during training, we define a loss that punishes the model if it produces a longer sequence than the ground truth sequence:

6

Under review as a conference paper at ICLR 2019

Dataset

train USPTO-15k valid
test

USPTO

train valid test

#reactions
10,500 1,500 3,000
409,035 30,000 40,000

#changes
1 | 11 | 2.3 1 | 11 | 2.3 1 | 11 | 2.3
1 | 6 | 2.2 1 | 6 | 2.2 1 | 6 | 2.2

#molecules
1 | 20 | 3.6 1 | 20 | 3.6 1 | 16 | 3.6
2 | 29 | 4.8 2 | 25 | 4.8 2 | 22 | 4.8

#atoms
4 | 100 | 34.9 7 | 94 | 34.5 7 | 98 | 34.9
9 | 150 | 39.7 9 | 150 | 39.6 9 | 150 | 39.8

#bonds
3 | 110 | 34.7 5 | 99 | 34.2 5 | 102 | 34.7
6 | 165 | 38.6 7 | 158 | 38.5 7 | 162 | 38.7

Table 1: Statistics of USPTO-15k and USPTO datasets. "changes" means bond changes, "molecules" means reactants and reagents in a reaction; "atoms" and "bonds" are defined for a molecule. Apart from "#reactions", other columns are presented in the format "min | max | mean".

Lover length = -

log p ( = 0)

(16)

Tegntd <Tend
where Tegntd is the end step of the groundtruth sequence. Note that the loss in Eq. (16) is not applied when Tend  Tegntd. The reason is that forcing  = 1 with Tend   < Tegntd is not theoretically correct because all the signals after Tend are assumed to be 0. The incentive to force Tend close to Tegntd when it is smaller than Tegntd has already been included in the advantages in Eq. (15).

2.4.4 CONSTRAINT ON THE TOP-K ATOM PAIRS

Ideally, the loss from Eq. (9) pushes a reaction atom pair (u~, v~) into the top-K atom pairs at each

sthteepgro<unTdtegrntudt.hHreoawcetivoenr,atthoims ispaniort(gu~u, av~r)antweeitdh,

especially the highest

when score

 comes close to Tegntd. to appear in the top K

To encourage , we introduce

an additional rank-based loss:

where Tfirst wrong =

Tfirst wrong

Lin top K = -

log p ((u~, v~) in top K)

 =0

tfirst wrong 3

; and p ((u~, v~) in top K) is computed as:

p ((u~, v~) in top K)

=

exp (su~v~)

exp (su~v~) +

K k=1

exp

suk vk

(17)

3 EXPERIMENTS

3.1 DATASET
We evaluate our model on two standard datasets USPTO-15k (15K reactions) and USPTO (480K reactions) which have been used in previous works (Jin et al., 2017; Schwaller et al., 2018; Bradshaw et al., 2018). Details about these datasets are given in Table 1.

3.2 REACTION ATOM PAIR PREDICTION
In this section, we test our model's ability to identify reaction atom pairs by formulating it as a ranking problem with the scores computed in Eq. (5). Similar to (Jin et al., 2017), we use Coverage@k as the evaluation metric, which is the proportion of reactions that have all groundtruth reaction atom pairs appear in the top k predicted atom pairs.
We compare our proposed graph neural network (GNN) with Weisfeiler-Lehman Network (WLN) (Jin et al., 2017) and Column Network (CLN) (Pham et al., 2017). Since our GNN explicitly uses reagent information to compute the scores of atom pairs, we modify the implementation of WLN and CLN accordingly for fair comparison. From Table 2, we observe that our GNN clearly outperforms WLN and CLN in all cases. We attribute this improvement to the use of a separate node state vector

7

Under review as a conference paper at ICLR 2019

Model
WLN (Jin et al., 2017) WLN (Jin et al., 2017) CLN (Pham et al., 2017)
Our GNN

USPTO-15k C@6 C@8 C@10

81.6 88.45 88.68 88.92

86.1 91.65 91.63 92.00

89.1 93.34 93.07 93.57

C@6
89.8 90.97 90.72 91.24

USPTO C@8 C@10
92.0 93.3 93.98 95.26 93.57 94.80 94.17 95.33

Table 2: Results for reaction atom pair prediction. C@k is coverage at k. Best results are highlighted in bold. WLN is the original model from (Jin et al., 2017) while WLN is our re-implemented version. Except for WLN , other models explicitly use reagent information.

1.0

0.8

value

0.6

0.4
0.2 1

5

coverage@k recall@k 10k 15 20

Figure 3: Coverage@k and Recall@k with respect to k for the USPTO dataset.

xit (different from the node feature vector vi) for updating the structural information of a node (see Eq. (21)). The other two models, on the other hand, only use a single vector to store both the node features and structure, hence, some information may be lost. In addition, using explicit reagent information boosts the prediction accuracy, which improves the WLN by 1-7% depending on the metrics. The presence of reagent information reduces the number of atom pairs to be searched on and contributes to the likelihood of reaction atom pairs. Further results are presented in Appendix A.5.
3.3 TOP-K ATOM PAIR EXTRACTION
The performance of our model depends on the number of selected top atom pairs K. The value of K presents a trade-off between coverage and efficiency. In addition to the metric Coverage@k in Sec. 3.2, we use Recall@k which is the proportion of correct atom pairs that appear in top k to find the good K. Fig. 3 shows Coverage@k and Recall@k for the USPTO dataset with respect to k. We see that both curves increase rapidly when k < 10 and stablize when k > 10. We also ran experiments with k = 10, 15, 20 and observed that their prediction results are quite similar. Hence, in what follows we select K = 10 for efficiency.
3.4 REACTION PRODUCT PREDICTION
This experiment validates GTPN on full reaction product prediction against the recent state-of-the-art methods (Jin et al., 2017; Schwaller et al., 2018) using the accuracy metric. The recent method ELECTRO (Bradshaw et al., 2018) is not compatible here because it was only evaluated on a subset of USPTO limited to linear chain topology. Comparison against ELECTRO is reported separately in Appendix A.6. Table 3 shows the prediction results. We produce multiple reaction product candidates by using beam search decoding with beam width N = 20. Details about beam search and its behaviors are presented in Appendix A.4.
In brief, we compute the normalized-over-length log probabilities of N predicted sequences of reaction triples and sort these values in descending order to get a rank list of N possible reaction

8

Under review as a conference paper at ICLR 2019

Model
WLDN (Jin et al., 2017) Seq2Seq (Schwaller et al., 2018)
GTPN GTPN GTPN GTPN GTPN

USPTO-15k P@1 P@3 P@5

76.7 85.6 86.8 ---

72.31 -

-

74.56 82.62 84.23

74.56 83.19 84.97 82.39 85.60 86.68

82.39 85.73 86.78

P@1
79.6 80.3
71.26 73.25 73.25 83.20 83.20

USPTO P@3
87.7 86.2
80.56 84.31 84.97 86.03

P@5
89.2 87.5
83.53 85.76 85.90 86.48

Table 3: Results for reaction prediction. P@k is precision at k. State-of-the-art results from (Jin et al., 2017) are written in italic. Results from (Schwaller et al., 2018) are marked with and they are computed on a slightly different version of USPTO that contains only single-product reactions. Best results are highlighted in bold. : With beam search (beam width = 20), : Invalid product removal, : Duplicated product removal.

outcomes. Given a predicted sequence of reaction triples (u, v, b)0:T , we can generate reaction products from input reactants simply by replacing the old bond of (u, v) with b . However, these products are not guaranteed to be valid (e.g., maximum valence constraint violation or aromatic molecules cannot be kekulized) so we post-process the outputs by removing all invalid products. The removal increases the top-1 accuracy by about 8% and 10% on USPTO-15k and USPTO, respectively. Due to the permutation invariance of the predicted sequence of reaction triples, some product candidates are duplicate and will also be removed. This does not lead to any change in P@1 but slightly improves P@3 and P@5 by about 0.5-1% on the two datasets.
Overall, GTPN with beam search and post-processing convincingly beats both WLDN (Jin et al., 2017) and Seq2Seq (Schwaller et al., 2018) in the top-1 accuracy. For the top-3 and top-5, our model's performance is comparable to WLDN's on USPTO-15k and is worse than WLDN's on USPTO. It is not surprising since our model is trained to accurately predict the top-1 outcomes instead of ranking the candidates directly like WLDN. It is important to emphasize that we did not tune the model hyper-parameters when training on USPTO but reused the optimal settings from USPTO-15k (which is 25 times smaller than USPTO) so the results may not be optimal (see Appendix A.3 for more training detail).

4 RELATED WORK
4.1 LEARNING TO PREDICT CHEMICAL REACTION
In chemical reaction prediction, machine learning has replaced rule-based methods (Chen & Baldi, 2009) for better generalizability and scalability. Existing machine learning-based techiques are either template-free (Kayala & Baldi, 2011; Jin et al., 2017; Fooshee et al., 2018) and template-based (Wei et al., 2016; Segler & Waller, 2017; Coley et al., 2017). Both groups share the same mechanism: running multiple stages with the aid of reaction templates or rules. For example, in (Wei et al., 2016) the authors proposed a two-stage model that first classifies reactions into different types based on the neural fingerprint vectors (Duvenaud et al., 2015) of reactant and reagent molecules. Then, it applies pre-designed SMARTS transformation on the reactants with respect to the most suitable predicted reaction type to generate the reaction products.
The work of (Jin et al., 2017) treats a reaction as a set of bond changes so in the first step, they predict which atom pairs are likely to be reactive using a variant of graph neural networks called Weisfeiler-Lehman Networks (WLN). In the next step, they do almost the same as (Coley et al., 2017) by modifying the bond type between the selected atom pairs (with chemical rules satisfied) to create product candidates and rank them (with reactant molecules as addition input) using another kind of WLN called Weifeiler-Lehman Different Networks (WLDN).
To the best of our knowledge, (Jin et al., 2017) is the first work that achieves remarkable results (with the Precision@1 is about 79.6%) on the large USPTO dataset containing more than 480 thousands reactions. Works in (Nam & Kim, 2016) and (Schwaller et al., 2018) avoid multi-stage prediction by

9

Under review as a conference paper at ICLR 2019
building a seq2seq model that generates the (canonical) SMILES string of the single product from the concatenated SMILES strings of the reactants and reagents in an end-to-end manner. However, their methods cannot deal with sets of reactants/reagents/products properly as well as cannot provide concrete reaction mechanism for every reaction.
The most recent work on this topic is (Bradshaw et al., 2018) which solves the reaction prediction problem by predicting a sequence of bond changes given input reactants and reagents represented as graphs. To handle ordering, they only select reactions with predefined topology. Our method, by contrast, is order-free and can be applied to almost any kind of reactions.
4.2 GRAPH NEURAL NETWORKS FOR MODELING MOLECULES
In recent years, there has been a fast development of graph neural networks (GNNs) for modeling molecules. These models are proposed to solve different problems in chemistry including toxicity prediction (Duvenaud et al., 2015), drug activity classification (Shervashidze et al., 2011; Dai et al., 2016; Pham et al., 2018), protein interface prediction (Fout et al., 2017) and drug generation (Simonovsky & Komodakis, 2018; Jin et al., 2018). Most of them can be regarded as variants of message-passing graph neural networks (MPGNNs) (Gilmer et al., 2017).
4.3 REINFORCEMENT LEARNING FOR STRUCTURAL REASONING
Reinforcement learning (RL) has become a standard approach to many structural reasoning problems2 because it allows agents to perform discrete actions. A typical example of using RL for structural reasoning is drug generation (Li et al., 2018; You et al., 2018). Both (Li et al., 2018) and (You et al., 2018) learn the same generation policy whose action set including: i) adding a new atom or a molecular scaffold to the intermediate graph, ii) connecting existing pair of atoms with bonds, and iii) terminating generation. However, (You et al., 2018) uses an adversarial loss to enforce global chemical constraints on the generated molecules as a whole instead of using the common reconstruction loss as in (Li et al., 2018). Other examples are path-based relational reasoning in knowledge graphs (Das et al., 2018; Xiong et al., 2017) and learning combinatorial optimization over graphs (Khalil et al., 2017).
5 DISCUSSION
We have introduced a novel method named Graph Transformation Policy Network (GTPN) for predicting products of a chemical reaction. GTPN uses graph neural networks to represent input reactant and reagent molecules, and uses reinforcement learning to find an optimal sequence of bond changes that transforms the reactants into products. We train GTPN using the Advantage Actor-Critic (A2C) method with appropriate constraints to account for notable aspects of chemical reaction. Experiments on real datasets have demonstrated the competitiveness of our model.
Although the GTPN was proposed to solve the chemical reaction problem, it is indeed generic to solve the graph transformation problem, which can be useful in reasoning about relations (e.g., see (Zambaldi et al., 2018)) and changes in relation. Open rooms include addressing dynamic graphs over time, extending toward full chemical planning and structural reasoning using RL.
REFERENCES
Peter Battaglia, Razvan Pascanu, Matthew Lai, Danilo Jimenez Rezende, et al. Interaction networks for learning about objects, relations and physics. In Advances in neural information processing systems, pp. 4502­4510, 2016.
John Bradshaw, Matt J Kusner, Brooks Paige, Marwin HS Segler, and José Miguel Hernández-Lobato. Predicting electron paths. arXiv preprint arXiv:1805.10970, 2018.
Jonathan H Chen and Pierre Baldi. No electron left behind: a rule-based expert system to predict chemical reactions and reaction mechanisms. Journal of chemical information and modeling, 49 (9):2034­2043, 2009.
2Structural reasoning is a problem of inferring or generating new structure (e.g. objects with relations)
10

Under review as a conference paper at ICLR 2019
Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using RNN encoder-decoder for statistical machine translation. EMNLP, 2014.
Connor W Coley, Regina Barzilay, Tommi S Jaakkola, William H Green, and Klavs F Jensen. Prediction of organic reaction outcomes using machine learning. ACS central science, 3(5): 434­443, 2017.
Hanjun Dai, Bo Dai, and Le Song. Discriminative embeddings of latent variable models for structured data. In International Conference on Machine Learning, pp. 2702­2711, 2016.
Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishnamurthy, Alex Smola, and Andrew McCallum. Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning. ICLR, 2018.
David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Alán Aspuru-Guzik, and Ryan P Adams. Convolutional networks on graphs for learning molecular fingerprints. In Advances in Neural Information Processing Systems, pp. 2224­2232, 2015.
David Fooshee, Aaron Mood, Eugene Gutman, Mohammadamin Tavakoli, Gregor Urban, Frances Liu, Nancy Huynh, David Van Vranken, and Pierre Baldi. Deep learning for chemical reaction prediction. Molecular Systems Design & Engineering, 2018.
Alex Fout, Jonathon Byrd, Basir Shariat, and Asa Ben-Hur. Protein interface prediction using graph convolutional networks. In Advances in Neural Information Processing Systems, pp. 6530­6539, 2017.
Justin Gilmer, Samuel S Schoenholz, Patrick F Riley, Oriol Vinyals, and George E Dahl. Neural message passing for quantum chemistry. In Proceedings of the International Conference on Machine Learning, 2017.
Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive representation learning on large graphs. In Proceedings of Advances in Neural Information Processing Systems, pp. 1025­1035, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770­778, 2016.
Wengong Jin, Connor Coley, Regina Barzilay, and Tommi Jaakkola. Predicting Organic Reaction Outcomes with Weisfeiler-Lehman Network. In Advances in Neural Information Processing Systems, pp. 2604­2613, 2017.
Wengong Jin, Regina Barzilay, and Tommi Jaakkola. Junction tree variational autoencoder for molecular graph generation. International Conference on Machine Learning (ICML), 2018.
Matthew A Kayala and Pierre F Baldi. A machine learning approach to predict chemical reactions. In Advances in Neural Information Processing Systems, pp. 747­755, 2011.
Elias Khalil, Hanjun Dai, Yuyu Zhang, Bistra Dilkina, and Le Song. Learning combinatorial optimization algorithms over graphs. In Advances in Neural Information Processing Systems, pp. 6348­6358, 2017.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. International Conference on Learning Representations (ICLR), 2015.
Yibo Li, Liangren Zhang, and Zhenming Liu. Multi-objective de novo drug design with conditional graph generative model. Journal of Cheminformatics, 10, 2018.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International conference on machine learning, pp. 1928­1937, 2016.
Juno Nam and Jurae Kim. Linking the neural machine translation and the prediction of organic chemistry reactions. arXiv preprint arXiv:1612.09529, 2016.
11

Under review as a conference paper at ICLR 2019
Trang Pham, Truyen Tran, Dinh Phung, and Svetha Venkatesh. Column networks for collective classification. In Proceedings of AAAI Conference on Artificial Intelligence, 2017.
Trang Pham, Truyen Tran, and Svetha Venkatesh. Graph memory networks for molecular activity prediction. ICPR, 2018.
Michael Schlichtkrull, Thomas N Kipf, Peter Bloem, Rianne van den Berg, Ivan Titov, and Max Welling. Modeling relational data with graph convolutional networks. 15th European Semantic Web Conference (ESWC-18), 2018.
Philippe Schwaller, Theophile Gaudin, David Lanyi, Costas Bekas, and Teodoro Laino. "found in translation": Predicting outcome of complex organic chemistry reactions using neural sequence-tosequence models. Chemical Science, 9:6091­6098, 2018.
Marwin HS Segler and Mark P Waller. Neural-symbolic machine learning for retrosynthesis and reaction prediction. Chemistry­A European Journal, 23(25):5966­5971, 2017.
Nino Shervashidze, Pascal Schweitzer, Erik Jan van Leeuwen, Kurt Mehlhorn, and Karsten M Borgwardt. Weisfeiler-Lehman graph kernels. Journal of Machine Learning Research, 12(Sep): 2539­2561, 2011.
Martin Simonovsky and Nikos Komodakis. GraphVAE: Towards Generation of Small Graphs Using Variational Autoencoders. arXiv preprint arXiv:1802.03480, 2018.
Rupesh K Srivastava, Klaus Greff, and Jürgen Schmidhuber. Training very deep networks. In Advances in neural information processing systems, pp. 2377­2385, 2015.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, pp. 5998­6008, 2017.
Xiaolong Wang, Ross Girshick, Abhinav Gupta, and Kaiming He. Non-local neural networks. In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018.
Jennifer N Wei, David Duvenaud, and Alán Aspuru-Guzik. Neural networks for the prediction of organic chemistry reactions. ACS Central Science, 2(10):725­732, 2016.
Wenhan Xiong, Thien Hoang, and William Yang Wang. DeepPath: A Reinforcement Learning Method for Knowledge Graph Reasoning. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pp. 564­573, 2017.
Jiaxuan You, Bowen Liu, Rex Ying, Vijay Pande, and Jure Leskovec. Graph convolutional policy network for goal-directed molecular graph generation. NIPS, 2018.
Vinicius Zambaldi, David Raposo, Adam Santoro, Victor Bapst, Yujia Li, Igor Babuschkin, Karl Tuyls, David Reichert, Timothy Lillicrap, Edward Lockhart, et al. Relational deep reinforcement learning. arXiv preprint arXiv:1806.01830, 2018.
12

Under review as a conference paper at ICLR 2019

A APPENDIX
A.1 GRAPH NEURAL NETWORK
In this section, we describe our graph neural network (GNN) in detail. Since our GNN does not use the recurrent hidden state h , we exclude the time step  from our notations for clarity. Instead, we use t to denote a message passing step.
GRAPH NOTATIONS
Input to our GNN is a graph G = (V, E) in which each node i  V is represented by a node feature vector vi and each edge (i, j)  E is represented by an edge feature vector eij. For example of molecular graph, the node feature vector vi may include chemical information about the atom i such as its type, charge and degree. Similarly, eij captures the bond type between the two atoms i and j. We denote by N (i) the set of all neighbor nodes of node i together with their links to node i:

N (i)  {(j, eij) | j is a neighbor node of i} If we only care about the neighbor nodes of i not their links, we use the notation Nn(i) defined as:

Nn(i)  {j | j is a neighbor node of i}

In addition to vi, node i also has a state vector xi to store information about itself and the surrounding context. This state vector is updated recursively using the neural message passing method (Battaglia

et al., 2016; Pham et al., 2017; Hamilton et al., 2017; Gilmer et al., 2017; Schlichtkrull et al., 2018). The initial state x0i is the nonlinear mapping of vi:

xi0 =  (W vi + b)

(18)

COMPUTING NEIGHBOR MESSAGES
At the message passing step t, we compute the message mtij from every neighbor node j  Nn(i) to node i as:

mitj = f xit, xjt , eij =  W xit, xjt , eij + b
where [·] denotes concatenation; and  is a nonlinear function.

(19)

AGGREGATING NEIGHBOR MESSAGES Then, we aggregate all the messages sent to node i into a single message vector by averaging:

mit

=

1 |Nn(i)|

j Nn (i)

mtij

where |Nn(i)| is the number of neighbor nodes of node i.

UPDATING NODE STATE Finally, we update the state of node i as follows:

(20)

xti+1 = g xti, mti, vi where g(.) is a Highway Network (Srivastava et al., 2015):

(21)

xti+1 = Highway xti, mti, vi =   x~ti+1 + (1 - )  xit
13

(22) (23)

Under review as a conference paper at ICLR 2019

where x~ti+1 is the nonlinear part which is computed as: x¯it+1 =  W1 xti, mit, vti + b1
and  is the gate controlling the flow of information:

 = sigmoid(W2 xti, mti, vti + b2) By combining Eqs. (19,20,22) together, one step of message passing update for node i can be written in a generic way as follows:

xit+1 = MessagePassing xti, vi, N (i)

(24)

A.2 UPDATING STATES

UPDATING RNN STATE
We keep the old representation of the edge that have been modified in the hidden memory of the RNN as follows:

h = GRU h-1, zu v

(25)

where GRU stands for Gated Recurrent Units (Cho et al., 2014); zuv is the representation vector of the atom pair (u, v) including its old bond (see Eq. 4). Eq. (25) allows the model to keep track of all

the changes happening to the graph so far so it can make more accurate prediction later.

UPDATING GRAPH STRUCTURE AND NODE STATES
After predicting a reaction triple (u, v, b) at step  , we update the graph structure and node states based on the new bond change. First, to update the graph structure, we simply update the neighbor set of u and v with information from the other atom and the new bond type b as follows:

N  (u) = N -1(u)\ v, bold  (v, b)

(26)

N  (v) = N -1(v)\ u, bold  (u, b)

(27)

Next, to update the node states, our model performs one step of message passing for u and v with

their new neighbor sets:

xu = MessagePassing xu-1, vu, N  (u)

(28)

xv = MessagePassing xv-1, vv, N  (v)

(29)

where the MessagePassing(.) function is defined in Eq. (24). For other nodes in the graph to be

aware of the new structures of u and v, we need to perform several message passing steps for all

nodes in the graph after Eqs. (28, 29). However, it is very costly to run for every prediction step  .

Sometimes it is unnecessary since far-away bonds are less likely to be affected by the current bond

change (unless the far-way bonds and the new bond are in an aromatic ring). Therefore, in our model,

we limit the number of message passing updates for all nodes at step  to be 1.

A.3 MODEL CONFIGURATIONS
We optimize our model's hyper-parameters in two stages: First, we tune the hyper-parameters of the GNN and the NPPN for the reaction atom pair prediction task. Then, we fix the optimal settings of the first two components and optimize the hyper-parameters of the PN for the reaction product prediction task.
We provide details about the settings that give good results on the USPTO-15k dataset below. With these settings, we trained another model on the USPTO dataset from scratch. Because training on the large dataset such as the USPTO takes time, we did not tune hyper-parameters on the USPTO, eventhough it is possible to increase model sizes for better performance.
Unless explicitly stated, all neural networks in our model have 2 layers with the same number of hidden units, ReLU activation and residual connections (He et al., 2016).

14

Under review as a conference paper at ICLR 2019

Atom attribute
Degree Explicit valence Explicit number of Hs Charge Part of a ring

Data type
numeric numeric numeric numeric boolean

Table 4: Data types of atom attributes.

Graph Neural Network (GNN) There are 72 different types of atom depending on their atomic numbers and 5 different types of bond including NULL, SINGLE, DOUBLE, TRIPLE and AROMATIC. The size of embedding vectors for atom and bond are 51 and 21, respectively. Apart from atom type, each atom has 5 more attributes listed in Table 4. These attributes are normalized to the range of [0, 1] and are concatenated to the atom embedding vector to form a final atom feature vector of size 56. The state vector and the neighbor message vector for an atom both have the size of 99. The number of message passing steps is 6.
Node Pair Prediction Network (NPPN) This component consists of two parts. The first part computes the representation vector zij of an atom pair (i, j) using a neural network with hidden size of 71. The second part maps zij to an unnormalized score sij using the function f atom pair (see Eqs. (3,5)). This function is also a neural network with hidden size of 51.
Policy Network (PN) The recurrent network is a GRU (Cho et al., 2014) with 101 hidden units. The value function V is a neural network with 99 hidden units. The two functions f signal for computing signal scores (see Eq. (6)) and f bond for computing scores over bond types (see Eq. (8)) are neural networks with 81 hidden units.
Training At each step, we set the reward to be 1.0 for correct prediction of signal/atom pair/bond type and -1.0 for incorrect prediction. After the prediction sequence is terminated (zero signal was emitted), we check whether the entire set of predicted reaction triples is correct or not. If it is correct, we give the model a reward value of 2.0, otherwise -2.0. From the rewards and estimated values for signal, atom pair and bond type, we define the Advantage Actor Critic loss (A2C) as in Eq. (15). The coefficients of components in the final loss L are set empirically as follows:

L = Latom pair + LA2C + 0.5 × Lvalue + 0.2 × Lover length + 0.2 × Lin top K
We trained our model using Adam (Kingma & Ba, 2015) with the initial learning rate of 0.001 for both USPTO-15k and USPTO. For USPTO-15k, the learning rate will decrease by half if the Precision@1 does not improve on the validation set after 1,000 steps until it reaches the minimum value of 5 × 10-5. For USPTO, the decay rate is 0.8 after every 500 steps of no improvement until reaching the minimum learning rate is 2 × 10-5. The maximum number of training iterations is 106 and the batch size is 20.
A.4 DECODING WITH BEAM SEARCH
For decoding, our model generates a sequence of reaction triples (including the stop signal) (, u, v, b) by taking the best (u, v) and b at every step until it outputs a zero signal ( = 0). In other words, it computes the argmax of p (, u, v, b) | G, (, u, v, b)0:-1 at every step  . However, this algorithm is not robust for the sequence generation task because just a single error at a step may destroy the entire sequence. To overcome this issue, we employ beam search for decoding.
During beam search, we keep track of N > 1 best subsequences at every step  . N is called beam width. Instead of modeling the conditional distribution of generating an output at the current step  , we model the joint distribution of the whole subsequence that has been generated from 0 to  :

log p (, u, v, b)0: |G

= log p (, u, v, b) |G, (, u, v, b)0:-1 + log p (, u, v, b)0:-1|G

(30)

15

Under review as a conference paper at ICLR 2019

Beam width
1 2 5 10 15 20

1
74.49 72.21 72.21 72.15 72.15 74.56

2
80.65 79.54 79.54 79.54 80.72

Precision@k 3 5 10

82.29 82.19 82.16 82.62

84.27 83.93 83.93 84.23

86.01 86.11 86.14

15
86.98 87.04

20
87.55

Table 5: Reaction product prediction results using beam search with different values of beam width on USPTO-15k.

Computing all configurations of (, u, v, b) jointly is very memory demanding, however. Thus, we decompose the first term as follows:

log p (, u, v, b) |G, (, u, v, b)0:-1 = log p  |G, (, u, v, b)0:-1 +
log p (u, v) | , G, (, u, v, b)0:-1 +
log b |(, u, v) , G, (, u, v, b)0:-1
At step  , we do beam search for the signal  , then the atom pair (u, v) and finally the bond type b . Algorithm 1 describes beam search in detail. Some notable technicalities are:
· We only do beam search for (u, v) and b if the prediction is ongoing, i.e., when  = 1. To keep track of this, we use a boolean vector C of length N with C0 is initialized to be all true.
· To avoid beam search favoring short sequences, we normalize the log probability scores over sequence lengths. This is shown in lines 10, 17, 32 and 47

BEAM WIDTH ANALYSIS
Table 5 reports how beam width affects the decoding performance on the USPTO-15k dataset. Surprisingly, the top-1 accuracy in case of beam width3 of 1 is higher than the those when beam widths range from 2 to 15. It means that large beam width is not always good in our situation. However, at beam width of 20, our beam search achieves the best results for different values of k. Thus, we set the beam width to 20 in subsequent experiments.
A.5 USING REAGENT INFORMATION EXPLICITLY
As can be seen from Table 6, reagent molecules account for about a half of the input molecules on average and 60-80% of all reactions containing reagents. It suggests that the proper use of reagent information will lead to better prediction. In our model, before computing the scores for all atom pairs, we append to the representation vector of every atom a binary scalar indicating whether this atom comes from a reagent molecule or not. Then, at the top-K atom pair selection step, we also exclude all atom pairs that have either atoms belong to a reagent molecule. The improvement in prediction accuracy on the validation set of USPTO-15k is shown in Fig. 4.
A.6 COMPARISON WITH ELECTRO
In method Both GTPN and ELECTRO (Bradshaw et al., 2018) are able to explain the mechanism behind a reaction. ELECTRO regards a reaction as an ordered sequence that alternates between removing and adding a single bond. Our model, on the other hand, assumes no specific order of transformations as well as the amount of valences that a bond can change. Thus, our model is more generic than ELECTRO and can cover a much larger set of reactions.
3Note that beam search with beam width = 1 is different from greedy search as in beam search, as we model the whole sequence probability.

16

Under review as a conference paper at ICLR 2019

Algorithm 1 Beam search decoding.

Input: A multi-graph G consisting of reactant and reagent molecules, number of bond types E, max

prediction steps T , beam width N

1: P 0 = [(-1, -1, -1, -1), ...]

The best N subsequences of (, u, v, b)

2: S0 = [0, ...]

The length-normalized log joint probabilities of the best N subsequences

3: C0 = [True, ...]

The continuation indicator of the best N subsequences

4: Perform L steps of message passing for all nodes using Eq. (1)

5: x0i = xi i  V 6: N 0(i) = N (i) i  V

The initial states of all nodes before decoding The initial neighbor set of all nodes before decoding

7: h0 is loaded from the saved model

The initial RNN hidden state before decoding

8: for  from 1 to T do 9: Find the top K atom pairs (uk, vk) | k = 1, K using Eqs. (4,5)

10:

S -1;0

=

S -1

×

 -1 

11: P  -1;0 = P  -1; C -1;0 = C -1

Superscript 0 denotes the sub-step 0

12: Beam search for continuation signals

13: 14: Rsignal = 

Stores the log joint probabilities for N × 2 possible signals

15: for n from 1 to N do

16: Compute p  | Pn-1;0 using Eq. (6)

17:

Add

C -1;0

×

1 

log p

 =  | Pn-1;0

+ Sn-1;0 to Rsignal for   {True, False}

18: end for

19: Sort Rsignal in descending order

20: S -1;1 = R0si:gNnal 21: ¯  output signal of N beams in R0si:gNnal 22: I-1;1  indices of N beams in R0si:gNnal 23: P -1;1 = extract P -1;0, I-1;1

24: C-1;1 = extract C-1;0, I-1;1

25: Cn-1;1 = Cn-1;1  n n  1, N 26:

27: Beam search for atom pairs

28: 29: Ratom pair = 

Stores the log joint probabilities for N × K possible atom pairs

30: for n from 1 to N do

31: Compute p (u, v) |¯n , Pn-1;1 using Eq. (7)

32:

Add

C -1;1

×

1 

log p

(u, v)k |n , Pn-1;1

+ Sn-1;1 to Ratom pair k  1, K

33: end for

34: Sort Ratom pair in descending order

35: S -1;2 = R0at:oNm pair 36: (u¯, v¯)  output atom pair of N beams in R0at:oNm pair 37: I-1;2  indices of N beams in R0at:oNm pair 38: P -1;2 = extract P -1;1, I-1;2

39: C-1;2 = extract C-1;1, I-1;2

40: ¯ = extract ¯ , I-1;2

41:

42: Beam search for bonds
43: 44: Rbond = 

Stores the log joint probabilities for N × B possible bonds

17

Under review as a conference paper at ICLR 2019

Algorithm 2 Reaction triple prediction using beam search (cont.)

45: for n from 1 to N do

46: Compute p b | (¯, u¯, v¯)n , Pn-1 using Eq. (8)

47:

Add

C -1;2

×

1 

log p

b =  | (¯, u¯, v¯), Pn-1

+ Sb-1 to Rbond   1, B

48: end for

49: Sort Rbond in descending order

50: 51:

S ¯b

-1;3 = R0bo:Nnd  output bond

of

N

beams

in

R0bo:Nnd

52: I-1;3  indices of N beams in R0bo:Nnd

53: P -1;3 = extract P -1;2, I-1;3

54: C-1;3 = extract C-1;2, I-1;3

55: ¯ = extract ¯ , I-1;3

56: (u¯, v¯) = extract (u¯, v¯) , I-1;3

57:

58: S = S-1;3; C = C-1;3 59: Pn = append Pn-1;3, (¯, u¯, v¯, ¯b)n

60: for n from 1 to N do 61: Update the N  (u¯n) and N  (v¯n) for all n = 1, N using Eqs. (26,27) 62: Update xu¯n and xv¯n using Eq. (1) 63: Perform m steps of message passing for all nodes in the graph 64: Update h using Eq. (25)
65: end for
66: end for Output: P T , ST

Dataset

USPTO-15k USPTO

train valid test
train valid test

%reactions containing reagents
63.1% 65.3% 63.6%
79.7% 80.0% 79.9%

%reagents over input molecules
41.3% 42.3% 40.9%
54.0% 54.4% 54.2%

Table 6: Proportion of reactions containing reagents and proportion of reagents over input molecules on USPTO-15k and USPTO.

accuracy

0.7 0.6 0.5 0.4 0.3 0.2
0k

w/ reagent wo/ reagent 100k 200sktep300k 400k 500k

Figure 4: Learning curves of our model with and without using reagent information explicitly on USPTO-15k.

18

Under review as a conference paper at ICLR 2019

Model
WLDN (Jin et al., 2017) ELECTRO (Bradshaw et al., 2018)
GTPN

Processed USPTO P@1 P@3 P@5
84.0 91.1 92.3 87.0 94.5 95.9
87.35 90.22 90.68

Table 7: Results for the reaction prediction task. P@k is the precision at k. Best results are highlighted in bold. Meanings of markers in our model: : With beam search (beam width = 20), : Invalid product removal, : Duplicate product removal.

#hits error proportion

1800 1600 1400 1200 1000 800 600 400 200
0

80.1

79.2

72.9

52.8
1 2 3 4 5 6 7 8 931.9 34.2 36.0 0.0 0.0 #bond changes

01.10

1.0 4.5 5.4 6.0 7.0 8.0 0.8 3.5
2.8
0.6
4.4 5.0
0.4 1.8 2.2 2.2 3.0 4.5 0.2

0.0

1.0
123456789

# bond changes

7.0
11

(a) (b)

Figure 5: Performance with respect to different number of bond changes. (a) Top-1 accuracy. (b) Errors grouped by length. In (a), blue: all reactions having that sequence length; orange: correct predicted reactions. In (b), red: the predicted sequence is shorter (than the groundtruth sequence); green: the predicted and the groundtruth have the same length; blue: the predicted sequence is longer; number indidate the average length.

In performance To do a fair comparison with ELECTRO (Bradshaw et al., 2018), we follow their procedure described in the paper to prepare a new test set that contains only reactions with linear chain topology and single-valence bond changes. It results in 29,808 reactions, close to the reported number of 29,360 in (Bradshaw et al., 2018). We reuse our old model (see Section 3.4) trained on the original USPTO dataset. We also use beam search decoding and post-processing as similar to (Bradshaw et al., 2018). From Table 7, we see that GTPN achieves the highest top-1 accuracy of 87.35%, outperforming ELECTRO and WLDN by 0.35% and 3%, respectively. For the top-3 and top-5 accuracies, our model, however, does worse than the other two. Especially, while both ELECTRO and WLDN have big jumps from P@1 to P@3 with about 7% improvement, GTPN only has 3% increase. We conjecture that this problem mainly comes from the fact that GTPN was not optimized on the compatible training and validation sets.
A.7 ERROR ANALYSIS
In this section, we analyze several error types that our model makes during prediction. All the results below are computed on the USPTO-15k dataset by using beam search decoding with the beam width N = 20 and no post-processing.
Errors grouped by number of bond changes Fig. 5 shows the top-1 accuracies for reactions with different number of bond changes. Our model performs poorly on reactions with many bond changes. However, those kinds of reactions only accounts for a small proportion in the dataset. From Fig. 5b, we see that the lengths of the error sequences tends to be shorter than the lengths of the groundtruth sequences.
Errors caused by signal/atom pair/bond type We define a sub-action causing error as the first sub-action that our model makes a wrong decision. In Fig. 6a, we plot the the proportion of errors with respect to the three kinds of sub-actions. Clearly, atom pair prediction causes the most errors
19

Under review as a conference paper at ICLR 2019

signal bond type 13.8% 20.1%

symmetric 5.7%

66.1% 94.3%

atom pair

not symmetric

(a) Proportion of the first incorrect sub-action that our model makes.

(b) Proportion of the incorrect top-1 products that have similar structure to the groundtruth products.

Figure 6: Errors grouped by the first incorrect sub-actions (a), and errors caused by symmetric structures (b).

(nearly two third). This makes sense because this sub-action is harder than signal prediction and bond type prediction. Therefore, more effort should be put on improving the prediction of atom pairs.
Errors caused by symmetry There exists cases in which different sequences of bond changes can result in the same products due to symmetric graph structures. Errors caused by symmetry account for 5.7% of the top-1 errors on the USPTO-15k dataset as shown in Fig. 6b. For better understanding, we provide a short list of wrong reaction triple predictions caused by symmetry in Fig. 7. In this list, the top-1 products (along the second column) are incorrect while the top-2 products (along the third column) are correct though both have the same probability.

20

Under review as a conference paper at ICLR 2019

HO:4

C:2

C:3

NH2:1

C:8 C:7 C:9

C:6 C:10

Cl:5

N:12

Cl:11

C:1 N:2

C:11 C:12

C:10

Cl:4

C:3 N:5

C:6

C:8 C:7

C:17 NH:18

F:9

C:16

C:13

[(1, 6), (5, 6)]

HCl:5

HO:4 C:3

C:8 C:7 C:9

C:2 C:6 C:10

NH:1

N:12

Cl:11

prob: 0.852 [(3, 4), (3, 18)]

[(1, 10), (10, 11)]

HCl:11

C:9 C:8
C:10 C:7
N:12 C:6

NH:1 C:2

C:3 OH:4

Cl:5

prob: 0.852 [(3, 4), (3, 15)]

HCl:4

C:1

C:16 C:17

C:11

N:2 C:12

C:10

NH:15

N:18 C:3

C:6

C:8

C:14 C:13

N:5

C:7 F:9

HCl:4

C:1

C:13 C:14

C:11

N:2 C:12

C:10

NH:18

N:15 C:3

C:6

C:8

C:17 C:16

N:5 C:7 F:9

NH:15 C:14

Mg:1

C:19 C:18

O:20

C:15

C:14

O:17

C:13

C:16 C:11
C:12

O:10

C:8 C:9

Br:7 C:6

C:3

Br:2 NH4+:2C2l-:21

C:5 C:4

H2O:17 O:23

C:18

C:19 O:20

C:21 C:22

C:7 F:6 C:8
C:5

C:2 C:1

C:4 C:3

C:9 C:15
Cl:16

O:13 C:14
C:10
O:11 C:12

Na+:23

HO-:22

C:1 C:2
C:4

O:5 C:6

NC::89C:C2:11C0C::2101NH:1CC2::1143C:1C9C::1168

C:3 O:7

C:15

F:17

prob: 0.917 [(10, 11), (6, 7), (6, 11)]

HBr:7

Cl-:21

Mg:1

NH4+:22

C:19 O:20

C:9

C:13

C:8

C:18

C:14

C:12

C:3

O:17

C:6 C:11

C:4

C:15

C:5

C:16 OH:10

Br:2

prob: 0.901 [(10, 11), (13, 14), (10, 13)]
H2O:17
O:23

C:19

C:18

C:21

O:20

C:22

CH4:14 C:7
F:6 C:8 C:5

C:2 C:1

C:4 C:3

C:9 C:15
Cl:16

C:10 C:12 OH:11 O:13

prob: 0.917

[(6, 7), (5, 6), (20, 21), (8, 21), (6, 20)]

HO-:22

H2O:7

OH:5

C:3

C:2

C:1 C:4

CH4:21

C:9

C:10

NH:12

C:19

C:11

C:13

C:18

Na+:23

NH:8

C:20

C:14

C:16

C:15

F:17

C:6

prob: 0.820

[(6, 8), (18, 20), (6, 20)]

C:21

C:24

N:22

O:25

C:23

OH:8

C:4

C:3 C:6 O:15 C:5

Cl:20

O:7

C:2 C:1

C:9 F:13

C:16 C:18

C:14

C:10

Cl:17

O:19

F:12

F:11

H2O:8

C:21

C:24

N:22

O:25

C:23

Cl:20

C:4

C:3 C:6

Cl:17

C:5

O:7

C:2 C:1 C:9
C:14

F:13

O:19

C:16

C:18

O:15

C:10

F:12 F:11

prob: 0.753

prob: 0.917 [(10, 11), (2, 3), (3, 11)]

HBr:2

Cl-:21

Mg:1

NH4+:22

C:19 O:20

C:8

C:13

C:9

C:18

C:14

C:12

C:6

O:17

C:3 C:11

C:5

C:15

C:4

C:16 OH:10

Br:7

prob: 0.901 [(10, 13), (11, 12), (10, 11)]
H2O:17
O:23

C:19

C:18

C:21

O:20

C:22

CH4:12 C:7
F:6 C:8 C:5

C:2 C:1

C:4 C:3

C:9 C:15
Cl:16

C:10 C:14 OH:13 O:11

prob: 0.917

[(6, 7), (5, 6), (9, 10), (8, 9), (6, 10)]

HO-:22

H2O:7

OH:5

C:3

C:2

C:1 C:4

CH4:9

C:20 C:21

NH:12

C:19

C:11

C:13

C:18

Na+:23

NH:8

C:10

C:14

C:16

C:15

F:17

C:6

prob: 0.820

[(6, 8), (16, 17), (6, 17)]

H2O:8

C:21

C:24

N:22

O:25

C:23

Cl:17

C:4

C:3 C:6

Cl:20

C:5

O:7

C:2 C:1 C:9
C:14

F:13

O:15

C:18

C:16

O:19

C:10

F:12 F:11

prob: 0.753

HO
NH N O
O F
F

NH N

Cl

N NF
Br OH

O Cl
NH NH
O Cl
F FF

Figure 7: Visualization of some reactions that cause multiple products with symmetric structures. Each row corresponds to a reaction. The columns, from left to right, show: i) reactant and reagent molecules, ii) incorrect top-1 product molecules, iii) correct top-2 product molecules, and iv) major groundtruth product molecules. All atoms in the first three columns are labeled with their atom map numbers. For the top-1 and top-2 products, we highlight the predicted reaction triples in green and provide the probability of the predicted sequence at the bottom.

21

