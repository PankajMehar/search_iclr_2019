Under review as a conference paper at ICLR 2019
DEEP DECODER: CONCISE IMAGE REPRESENTATIONS FROM UNTRAINED NON-CONVOLUTIONAL NETWORKS
Anonymous authors Paper under double-blind review
ABSTRACT
Deep neural networks, in particular convolutional neural networks, have become highly effective tools for compressing images and solving inverse problems including denoising, inpainting, and reconstruction from few and noisy measurements. This success can be attributed in part to their ability to represent and generate natural images well. Contrary to classical tools such as wavelets, imagegenerating deep neural networks have a large number of parameters--typically a multiple of their output dimension--and need to be trained on large datasets. In this paper, we propose an untrained simple image model, called the deep decoder, which is a deep neural network that can generate natural images from very few parameters. As a consequence, we demonstrate that this network enables efficient image compression and state-of-the-art performance for inverse problems like denoising. Contrary to previous deep image generators (trained or not) the network is under-parameterized, and thus conforms with the classical perspective that an efficient model maps a low-dimensional parameter space to a high-dimensional image space. In addition, the deep decoder is simple in the sense that each layer has an identical structure that consists of only one upsampling unit, pixel-wise linear combination of channels, ReLU nonlinearity, and channelwise normalization. This simplicity makes the program amenable to theoretical analysis. Notably, the deep decoder does not involve convolutional layers.
1 INTRODUCTION
Data models are central for signal and image processing and play a key role in compression and inverse problems such as denoising, super-resolution, and compressive sensing. These data models impose structural assumptions on the signal or image, which are traditionally based on expert knowledge. For example, imposing the assumption that an image can be represented with few non-zero wavelet coefficients enables modern (lossy) image compression (Antonini et al., 1992) and efficient denoising (Donoho, 1995).
In recent years, it has been demonstrated that for a wide range of imaging problems, from compression to denoising, deep neural networks trained on large datasets can often outperform methods based on traditional image models (Toderici et al., 2016; Agustsson et al., 2017; Theis et al., 2017; Burger et al., 2012; Zhang et al., 2017). This success can largely be attributed to the ability of deep networks to represent realistic images when trained on large datasets. Examples include learned representations via autoencoders (Hinton & Salakhutdinov, 2006) and generative adversarial models (Goodfellow et al., 2014). Almost exclusively, three common features of the recent success stories of using deep neural network for imaging related tasks are that the corresponding networks are over-parameterized (i.e., they have much more parameters than the dimension of the image that they represent or generate), that the networks have a convolutional structure, and perhaps most importantly, that the networks are trained on large datasets.
An important exception that breaks with the latter feature is a recent work by Ulyanov et al. (2018), which shows that a deep neural network--over-parameterized and convolutional--can solve inverse problems well without any training. Specifically, Ulyanov et al. (2018) demonstrated that by fitting the weights of an over-parameterized deep convolutional network to a single image while regulariz-
1

Under review as a conference paper at ICLR 2019
ing by stopping early for regularization, this regularized network can act as a good prior for a variety of image restoration problems. This result is surprising as it suggests that regularization along with the network structure itself can be a good approach for image restoration without a large training dataset.
In this paper, we propose a simple image model in the form of a deep neural network that can generate natural images well, and thus enables image compression, denoising, and solving other inverse problems with close-to or state-of-the-art performance. We call the network deep decoder, due to its resemblance to the decoder part of an autodecoder. Contrary to previous approaches, the network is under-parameterized, does not require training, does not require convolutions, and has a simplicity that makes it amenable to theoretical analysis. The key features of the approach, and key contributions of the paper are as follows:
· The network is not learned and itself incorporates all assumptions on the data. This has multiple benefits: the same network and code is usable for multiple applications; the method is not sensitive to a potential misfit between training and test data, since there is no training; and the method does not have assumptions on the class of natural images as part of additional regularization, such as by stopping optimization early.
· The network is under-parameterized. Thus, the network maps a lower-dimensional space to a higher-dimensional space, similar to classical image representations such as sparse wavelet representations. This feature enables image compression. In Section 2, we demonstrate that the compression is on-par with wavelet thresholding (Antonini et al., 1992), a strong baseline that underlies JPEG-2000.
· The network does not have a convolutional structure. The majority of the networks for image compression, restoration, and recovery have a convolutional structure (Toderici et al., 2016; Agustsson et al., 2017; Theis et al., 2017; Burger et al., 2012; Zhang et al., 2017). While convolutions are perhaps critical and certainly useful for a number of important image related problems, our work suggests that they are not critical for the specific problem of generating an image without learning.
· The network only consists of a simple combination of few building blocks, which makes it amenable to analysis and theory. For example, we prove that the deep decoder can only fit a small proportion of noise, which, combined with the empirical observation that it can represent natural images very well, explains its denoising performance.
The remainder of the paper is organized as follows. In Section 2, we first demonstrate that the deep decoder enables concise image representations. We formally introduce the deep decoder in Section 3. In Section 4, we show the performance of the deep decoder on a number of inverse problems such as denoising. In Section 5 we discuss related work, and finally, in Section 6 we provide theory and explanations on what makes the deep decoder work.
2 CONCISE IMAGE REPRESENTATIONS WITH A DEEP IMAGE MODEL
Intuitively, a model describes a class of signals well if it is able to represent or approximate a member of the class with few parameters. In this section, we demonstrate that the deep decoder, an untrained, non-convolutional neural network, defined in the next section, enables concise representation of an image--on par with state of the art wavelet thresholding.
The deep decoder is a deep image model G : RN  Rn, where N is the number of parameters of the model, and n is the output dimension, which is typically much larger than the number of parameters (N n). The parameters of the model, which we denote by C, are the weights of the network, and not the input of the network, which we will keep fixed. To demonstrate that the deep decoder enables concise image representations, we choose the number of parameters of the deep decoder, N , such that it is a small fraction of the output dimension of the deep decoder, i.e., the dimension of the images1.
We draw 100 images from the imagenet validation set uniformly at random and crop the center to obtain a 512x512 pixel color image. For each image x, we fit a deep decoder model G(C) by
1Specifically, we took a deep decoder G with d = 6 layers and output dimension 512 × 512 × 3, and choose k = 64 and k = 128 for the respective compression ratios.
2

Under review as a conference paper at ICLR 2019

50 50

decoder PSNR n1 n2 n3 nd

40 40

30 30

20 20

20 30 40 50 wavelet PSNR

20 30 40 50 wavelet PSNR

compression ratio 0.031 compression ratio 0.125

B1 B2 B3 . . . Bd
k1 k2 k3
kd
BN, lin. comb., ReLU, upsampling lin. comb., sigmoid

Figure 1: The deep decoder (depicted on the right) enables concise image representations, onpar with state-of-the-art wavelet based compression. The dots on the left depict the PSNRs for 100 randomly chosen imagenet-images represented with few wavelet coefficients and with the deep decoder. A dot above the red line means the corresponding image has a smaller representation error when represented with the deep decoder. The deep decoder is particularly simple, as each layer has the same structure, consisting of one channelwise normalization (BN), a pixel-wise linear combination of channels, ReLU nonlinearity, and upsampling.

minimizing the loss

L(C) =

G(C) - x

2 2

with respect to the parameters C using the Adam optimizer. We then compute for each image the cor-

responding peak-signal-to noise ratio, defined as 10 where G(C) is the image generated by the network,

laongd10x(1/isMthSeEo)riMgiSnEal

=

1 3·5122

image.

x - G(C)

2 2

,

We compare the compression performance to wavelet compression (Antonini et al., 1992) by repre-
senting each image with the N -largest wavelet coefficients. Wavelets--which underly JPEG 2000,
a standard for image compression--are one of the best methods to approximate images with few
coefficients. In Fig. 1 we depict the results. It can be seen that for small compression ratios (N/3 · 5122 = 0.031), the representation by the deep decoder is slightly better for most images (i.e., is above the red line), while for larger compression ratios (N/3 · 5122 = 0.125), the wavelet
representation is slightly better. This experiment shows that deep neural networks can represent
natural images well with only very few parameters and without any learning.

The observation that, for large compression ratios, wavelets enable more concise representations than the deep decoder is intuitive because with sufficiently many wavelet coefficients any image can be represented exactly, whereas a priori there is no reason to believe that the deep decoder has representation error equal to zero in the under-parameterized regime.

The main point of this experiment is to demonstrate that the deep decoder is a good image model, which enables applications like solving inverse problems, as in Section 4. However, it also suggest that the deep decoder can be used for lossy image compression, by quantizing the coefficients C and saving the quantized coefficients. In the appendix, we show that image representations of the deep decoder are not sensitive to perturbations of its coefficients, thus quantization does not have a detrimental effect on the image quality. Deep networks were used successfully before for the compression of images (Toderici et al., 2016; Agustsson et al., 2017; Theis et al., 2017). In contrast to our work, which is capable of compressing images without any learning, the aforementioned works learn an encoder and decoder using convolutional recurrent neural networks (Toderici et al., 2016) and convolutional autoencoders (Theis et al., 2017) based on training data.

3 THE DEEP DECODER
We consider a decoder architecture that transforms a randomly chosen and fixed tensor B1  Rn1×k1 consisting of k1 many n1-dimensional channels to an nd × kout dimensional image, where kout = 1 for a grayscale image, and kout = 3 for an RGB image with three color channels. Throughout, ni has two dimensions; for example our default configuration has n1 = 16 × 16 and nd = 512 × 512. The network transforms the tensor B1 to an image using batch-normalization and

3

Under review as a conference paper at ICLR 2019

upsampling operations, pixel-wise linearly combining the channels, and applying rectified linear units (ReLUs). Specifically, the channels in the (i + 1)-th layer are given by
Bi+1 = Uirelu(bn(BiCi)), i = 1, . . . , d. Here, the coefficient matrices Ci  Rki×ki+1 contain the weights of the network. Each column of the tensor BiCi  Rni×ki+1 is formed by taking linear combinations of the channels of the tensor Bi in a way that is consistent across all pixels.

Then, bn(·) performs the batch norm operation (Ioffe & Szegedy, 2015), which is equivalent to

normalizing each channel individually. Specifically, let Zi = BiCi be the channels in the i-th layer,

and let zij be the j-th channel in the i-th layer. Then batch normalization performs the following

transformation:

zij

=

zij -mean(zij )

var(zij )+

ij

+ ij, where mean and var

compute the empirical mean

and variance, and ij and ij are parameters, learned independently for each channel, and is a

fixed small constant. Learning the parameters  and  helps the optimization, but is not critical.

The operator Ui  Rni+1×ni is an upsampling tensor, which we choose throughout so that it performs bi-linear upsampling. For example, if the channels in the first layer have dimensions n1 = 16 × 16, then the upsampling operator U1 upsamples each channel to dimensions 32 × 32. In the last layer, we do not upsample and choose the corresponding upsampling operator as the identity.
Finally, the output of the d-layer network is formed as
x = sigmoid(BdCd+1), where Cd+1  Rkd×kout . Throughout, our default architecture is a d = 6 layer network with ki = k for all i, and we focus on output images of dimensions nd = 512×512. See Fig. 1 for an illustration. Recall that the parameters of the network are given by C = {C1, C2, . . . , Cd, Cd+1}, and the output of the network is only a function of C, since we choose the tensor B1 at random and fix it. Therefore, we write x = G(C). Note that the number of parameters is given by id=1(kiki+1 + 2ki) + kd+1kd, where the term 2ki corresponds to the two free parameters associated with the batch norm. We choose the number of output (i.e. color) channels throughout as kout = 3 and the other parameters as ki = k, for all i. Thus, the number of parameters is dk2 + 2dk + 3k.

We finally note that taking pixelwise linear combinations of channels (with a consistent transformation across all pixels) is equivalent to performing 1x1 convolutions. To stress the fact that 1x1 convolutions are degenerate convolutions that do not exploit locality within images by extracting features from local image patches, we refrain from naming this operation a convolution throughout the paper. The deep decoder is not a convolutional neural network.

4 SOLVING INVERSE PROBLEMS WITH THE DEEP DECODER

In this section, we use the deep decoder as a structure-enforcing model for solving standard inverse problems: denoising, super-resolution, and inpainting. In all of those inverse problems, the goal is to recover an image x from a noisy observation y = f (x) + . Here, f is a known forward operator (possibly equal to identity), and  is structured or unstructured noise.

We recover the image x with the deep decoder as follows. Motivated by the finding from the previous

section that a natural image x can (approximately) be represented with the deep decoder as G(C),

we estimate the unknown image from the noisy observation y by minimizing the loss

L(C) =

f (G(C)) - y

2 2

with respect to the model parameters C. Let C^ be the result of the optimization procedure. We

estimate the image as x^ = G(C^ ).

We use the Adam optimizer for minimizing the loss, but have obtained comparable results with
gradient descent. Note that this optimization problem is non-convex and we might not reach a global minimum. Throughout, we consider the least-squares loss (i.e., we take · 2 to be the 2 norm), but the loss function can be adapted to account for structure of the noise.

We remark that fitting an image model to observations in order to solve an inverse problem is a standard approach and is not specific to the deep decoder or deep networks based models in general. Specifically, a number of classical signal recovery approaches fit into this framework; for example solving a compressive sensing problem with 1-norm minimization amounts to choosing the forward operator as f (x) = Ax and minimizing over x in a 1-norm ball.

4

Under review as a conference paper at ICLR 2019

original image

noisy image 19.1dB

DD 29.6dB

DIP 29.2dB

BM3D 28.6dB

Figure 2: An application of the deep decoder for denoising the astronaut test image. The deep decoder has performance on-par with state of the art untrained denoising methods, such as the DIP method (Ulyanov et al., 2018) and the BM3D algorithm (Dabov et al., 2007).

4.1 DENOISING

We start with the perhaps most basic inverse problem, denoising. The motivation to study denoising

is at least threefold: First, denoising is an important problem in practice, second, many inverse

problem can be solved as a chain of denoising steps (Romano et al., 2017), and third, the denoising

problem is simple to model mathematically, and thus a common entry point for gaining intuition

on a new method. Given a noisy observation y = x + , where  is additive noise, we estimate

an image with the deep decoder by minimizing the least squares loss

G(C) - y

2 2

,

as described

above.

The results in Fig. 2 and Table 1 demonstrate that the deep decoder has denoising performance onpar with state of the art untrained denoising methods, such as the related Deep Image Prior (DIP) method (Ulyanov et al., 2018) (discussed in more detail later) and the BM3D algorithm (Dabov et al., 2007). Since the deep decoder is an untrained method, we only compared to other state-of-the-art untrained methods (as opposed to learned methods such as (Zhang et al., 2017)).

Why does the deep decoder denoise well? In a nutshell, from Section 2 we know that the deep decoder can represent natural images well even when highly underparametrized. In addition, as a consequence of being under-parameterized, the deep decoder can only represent a small proportion of the noise, as we show analytically in Section 6, and as demonstrated experimentally in Fig. 4. Thus, the deep decoder "filters out" a significant proportion of the noise, and retains most of the signal.

How to choose the parameters of the deep decoder? The larger k, the larger the number of latent parameters and thus the smaller the representation error, i.e., the error that the deep decoder makes when representing a noise-free image. On the other hand, the smaller k, the fewer parameters, and the smaller the range space of the deep decoder G(C), and thus the more noise the method will remove. The optimal k trades off those two errors; larger noise levels will require smaller values of k. Throughout the denoising experiments, we choose k = 128.

4.2 SUPERRESOLUTION
We next super-resolve images with the deep denoiser. We define a forward model f that performs downsampling with the Lanczos filter by a factor of four. We then downsample a given image by a factor of four, and then reconstruct it with the deep decoder (with k = 128, as before). We compare performance to bi-cubic interpolation and to the deep image prior, and find that the deep decoder outperforms bicubic interpolation, and is on-par with the deep image prior (see Table 1 in the appendix).

4.3 INPAINTING
Finally, we use the deep decoder for inpainting, where we are given an inpainted image y, and a forward model f mapping a clean image to an inpainted image. The forward model f is defined by a mask that describes the inpainted region, and simply maps that part of the image to zero. Fig. 3 and Table 1 demonstrate that the deep decoder performs well on the inpainting problems, however

5

Under review as a conference paper at ICLR 2019

original image

noisy image 12.9dB

DD 34.1dB

DIP 34dB

Figure 3: An application of the deep decoder for recovering an inpainted image. For this example, the deep decoder and the deep image perform essentially equally well.

the deep image prior performs slightly better on average over the examples considered. For the impainting problem we choose a significantly more expressive prior, specifically we set k = 320.

5 RELATED WORK

Image compression, restoration, and recovery algorithms are either trained or untrained. Conceptually, the deep decoder image model is most related to untrained methods, such as sparse representations in overcomplete dictionaries (for example wavelets (Donoho, 1995) and curvelets (Starck et al., 2002)). A number of highly successful image restoration and recovery schemes are not directly based on generative image models, but rely on structural assumptions about the image, such as exploiting self-similarity in images for denoising (Dabov et al., 2007) and super-resolution (Glasner et al., 2009).

Since the deep decoder is an image-generating deep network, it is also related to methods that rely on trained deep image models. Deep learning based methods are either trained end-to-end for tasks ranging from compression (Toderici et al., 2016; Agustsson et al., 2017; Theis et al., 2017; Burger et al., 2012; Zhang et al., 2017) to denoising (Burger et al., 2012; Zhang et al., 2017), or are based on learning a generative image model (by training an autoencoder or GAN (Hinton & Salakhutdinov, 2006; Goodfellow et al., 2014)) and then using the resulting model to solve inverse problems such as compressed sensing (Bora et al., 2017; Hand & Voroninski, 2018), denoising (Heckel et al., 2018), phase retrieval (Hand et al., 2018; Shamshad & Ahmed, 2018), and blind deconvolution (Asim et al., 2018), by minimizing an associated loss. In contrast to the deep decoder, where the optimization is over the weights of the network, in all the aforementioned methods, the weights are adjusted only during training and then are fixed upon solving the inverse problem.

Most related to our work is the Deep Image Prior (DIP), recently proposed by Ulyanov et al. (Ulyanov et al., 2018). The deep image prior is an untrained method that uses a network with an hourglass or decoder-encoder architecture, similar to the U-net and related architectures that work well as autoencoders. The key differences to the deep decoder are threefold: i) the DIP is over-parameterized, whereas the deep decoder is under-parameterized. ii) Since the DIP is highly over-parameterized, it critically relies on regularization through early stopping and adding noise to its input, whereas the deep decoder does not need to be regularized (however, regularization can enhance performance). iii) The DIP is a convolutional neural network, whereas the deep decoder is not.

We further illustrate point ii) comparing the DIP and deep decoder by denoising the astronaut image

from Fig. 2. In Fig. 4(a) we plot the Mean Squared Error (MSE) over the number of iterations

of the optimizer for fitting the noisy astronaut image x +  (i.e.,

G(Ct) - x

2 2

where Ct

are the

parameters of the deep decoder after t iterations). In Fig. 4(b) and (c), we plot the loss or MSE

associated with fitting the noiseless astronaut image, x, ( G(Ct) - x 22) and the noise itself, ,

(

G(Ct) - 

2 2

).

The plots in Fig. 4 show that with sufficiently many iterations, both the DIP and the DD can fit the image well. However, even with a large number of iterations, the deep decoder can not fit the noise well, whereas the DIP can. This is not surprising, given that the DIP is over-parameterized

6

Under review as a conference paper at ICLR 2019

Test MSE Train MSE Train MSE

·10-2 2
1

DD DIP

·10-2 8 6 4 2

·10-3 8 6 4 2

0 102

104

(a) fit noisy image

0 102

104

(b) fit image

0 102

104

(c) fit noise

Figure 4: Denoising with the deep decoder and the deep image prior: Due to underparameterization, the deep decoder can only fit a small proportion of the noise, and thus enables image denoising. Early stopping can enhance the performance. The deep image prior can fit noise very well, but fits an image faster than noise, thus early stopping is critical for denoising performance.

and the deep decoder is under-parameterized. In fact, in Section 6 we formally show that due to the underparameterization, the deep decoder can only fit a small proportion of the noise, no matter how and how long we optimize. As a consequence, it filters out much of the noise when applied to a natural image. In contrast, the DIP relies on the empirical observation that the DIP fits a structured image faster than it fits noise, and thus critically relies on early stopping.

6 DISCUSSION ON WHAT MAKES THE DECODER WORK

In the previous sections we empirically showed that the deep decoder can represent images well and at the same time cannot fit noise well. In this section, we formally show that the deep decoder can only fit a small proportion of the noise, relative to the degree of underparameterization. In addition, we provide insights into how the components of the deep decoder contribute to representing natural images well, and we provide empirical observations on the sensitivity of the parameters and their distribution.

6.1 THE DEEP DECODER CAN ONLY FIT LITTLE NOISE

We start by showing that an under-parameterized deep decoder can only fit a proportion of the noise relative to the degree of underparameterization. At the heart of our argument is the intuition that a method mapping from a low- to a high-dimensional space can only fit a proportion of the noise relative to the number of free parameters. For simplicity, we consider a one-layer network, and ignore the batch normalization operation. Then, the networks output is given by

G(C) = U1relu(B1C1)c2  Rn.

Here, we take C = (C1, c2), where C1 is a k × k matrix and c2 is a k-dimensional vector, assuming that the number of output channels is 1. While for the performance of the deep decoder the choice of upsampling matrix is important, it is not relevant for showing that the deep decoder cannot represent noise well. Therefore, the following statement makes no assumptions about the upsampling matrix U1.
Proposition 1. Consider a deep decoder with one layer and arbitrary upsampling and input matrices. That is, let B1  Rn1×k and U1  Rn×n1 . Let   Rn be zero-mean Gaussian noise with covariance matrix I. Assume that k2 log(n1)/n  1/32. Then, with probability at least 1 - 2n-1 k2 ,

min
C

G(C) - 

2 2





2 2

1 - 20 k2 log(n1) n

.

The proposition asserts that the deep decoder can only fit a small portion of the noise energy, pre-

cisely a proportion determined by its number of parameters relative to the output dimension, n. Our

simulations and preliminary analytic results suggest that this statement extends to multiple layers in

that the lower bound becomes

1

-

c

k2

log(

d i=1
n

ni )

, where c is a numerical constant.

7

Under review as a conference paper at ICLR 2019

0.8 0.6 0.4 0.2

0 0.2 0.4 0.6 0.8 1 (a) Linear upsampling

0 0.2 0.4 0.6 0.8 1 (b) Convex upsampling

Figure 5: The blue curves show a one-dimensional piecewise smooth signal, and the red hatches show estimates of this signal by a one-dimensional deep decoder with either linear or convex upsampling. We see that linear upsampling acts as an indirect signal prior that promotes piecewise smoothness.

6.2 UPSAMPLING
Upsampling is a vital part of the deep decoder because it is the only way that the notion of locality enters the signal model. The choice of the upsampling method strongly affects the `character' of the resulting signal estimates. We now discuss the impacts of a few choices of upsampling matrices Ui, and their impact on the images the model can fit.
No upsampling: If there is no upsampling, or, equivalently, if Ui = I, then there is no notion of locality in the resulting image. All pixels become decoupled, and there is then no notion of which pixels are near to each other. Specifically, a permutation of the input pixels (the rows of B1) simply induces the identical permutation of the output pixels. Thus, if a deep decoder without upsampling could fit a given image, it would also be able to fit random permutations of the image equally well, which is practically equivalent to fitting random noise.
Nearest neighbor upsampling: If the upsampling operations perform nearest neighbor upsampling, then the output of the deep decoder consists of piecewise constant patches. If the upsampling doubles the image dimensions at each layer, this would result in patches of 2d × 2d pixels that are constant. While this upsampling method does induce a notion of locality, it does so too strongly in the sense that squares of nearby pixels become identical and incapable of fitting local variation within natural images.
Linear and convex, non-linear upsampling: The specific choice of upsampling matrix affects the multiscale `character' of the signal estimates. To illustrate this, Figure 5 shows the signal estimate from a 1-dimensional deep decoder with upsampling operations given by linear upsampling (x0, x1, x2, . . .)  (x0, 0.5x0 + 0.5x1, x1, 0.5x1 + 0.5x2, x2, . . .) and convex nonlinear upsampling given by (x0, x1, x2, . . .)  (x0, 0.75x0 + 0.25x1, x1, 0.75x1 + 0.25x2, x2, . . .). Note that while both models are able to capture the coarse signal structure, the convex upsampling results in a multiscale fractal-like structure that impedes signal representation. In contrast, linear upsampling is better able to represent smoothly varying portions of the signal. Linear upsampling in a deep decoder indirectly encodes the prior that natural signals are piecewise smooth and in some sense have approximately linear behavior at multiple scales
6.3 NETWORK INPUT
Throughout, the network input is fixed. We choose the network input B1 by choosing its entries uniformly at random. The particular choice of the input is not very important, it is however desirable that the rows are incoherent. To see this, as an extreme case, if any two rows of B1 are equal, then the output of the corresponding pixels is also exactly the same, which restricts the range space of the deep decoder unrealistically, since for any pair of pixels, the majority of natural images does not have exactly the same value at this pair of pixels.
6.4 IMAGE GENERATION BY SUCCESSIVE APPROXIMATION
The deep decoder is tasked with coverting multiple noise channels into a structured signal primarily using pixelwise linear combinations, ReLU activation funcions, and upsampling. Using these tools, the deep decoder builds up an image through a series of successive approximations that grad-
8

Under review as a conference paper at ICLR 2019

Figure 6: The left panel shows an image reconstruction after training a deep decoder on the MRI phantom image (PSNR is 51dB). The right panel shows how the deep decoder builds up an image starting from a random input. From top to bottom are the input to the network and the activation maps (i.e., relu(BiCi)) for eight out of the 64 channels in layers one to six.

barbara lovett mri zebra F16 baboon fruit astronaut castle saturn DN identity 20.3 20.9 22.1 21.3 20.3 20.3 20.5 20.6 20.4 20.2
DD128 26.8 27.9 26.9 22.5 29.1 21.4 29.2 29.8 27.7 29.0 DIP 24.4 25.3 26.6 24.8 25.0 22.8 25.7 26.1 25.0 25.0 BM3D 24.7 25.1 28.0 22.8 25.2 22.6 26.3 26.2 25.6 30.5

SR bicubic 26.3 26.0 24.5 18.2 26.4 20.7 27.1 29.3 DD128 26.4 26.3 26.4 19.0 26.6 20.6 28.6 30.2 DIP 26.4 26.6 25.6 19.2 27.4 20.6 28.3 29.6

25.8 27.9 26.1 27.8 26.0 27.9

IP identity 14.9 DD320 30.8 DIP 35.6

14.4 18.3 13.0 11.7 14.0 12.4 32.9 31.1 23.6 34.7 23.9 35.3 26.9 32.1 24.2 34.7 26.2 35.5

14.0 36.1 35.3

14.2 13.4 31.6 35.4 32.6 36.2

Table 1: Performance comparison of the deep decoder for denoising (DN), superresolution (SR), and inpainting (IP).

ually morph between random noise and signal. To illustrate that, we plot the activation maps (i.e., relu(BiCi)) of a deep decoder fitted to the phantom MRI test image (see Fig. 6). We choose a deep decoder with d = 5 layers and k = 64 channels. This image reconstruction approach is in contrast to being a semantically meaningful hierarchical representation (i.e., where edges get combined into corners, that get combined into simple sample, and then into more complicated shapes), similar to what is common in discriminative networks.
REFERENCES
E. Agustsson, F. Mentzer, M. Tschannen, L. Cavigelli, R. Timofte, L. Benini, and L. V. Gool. Softto-hard vector quantization for end-to-end learning compressible representations. In Advances in Neural Information Processing Systems, pp. 1141­1151, 2017.
M. Antonini, M. Barlaud, P. Mathieu, and I. Daubechies. Image coding using wavelet transform. IEEE Transactions on Image Processing, 1(2):205­220, 1992.
M. Asim, F. Shamshad, and A. Ahmed. Solving bilinear inverse problems using deep generative priors. arXiv preprint arXiv:1802.04073, 2018.
A. Bora, A. Jalal, E. Price, and A. G. Dimakis. Compressed sensing using generative models. arXiv:1703.03208, 2017.
H. C. Burger, C. J. Schuler, and S. Harmeling. Image denoising: Can plain neural networks compete with BM3d? In IEEE Conference on Computer Vision and Pattern Recognition, pp. 2392­2399, 2012.

9

Under review as a conference paper at ICLR 2019
K. Dabov, A. Foi, V. Katkovnik, and K. Egiazarian. Image denoising by sparse 3-D transformdomain collaborative filtering. IEEE Transactions on Image Processing, 16(8):2080­2095, 2007.
D. L. Donoho. De-noising by soft-thresholding. IEEE Transactions on Information Theory, 41(3): 613­627, 1995.
D. Glasner, S. Bagon, and M. Irani. Super-resolution from a single image. In IEEE International Conference on Computer Vision, pp. 349­356, 2009.
I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Generative adversarial nets. In Advances in Neural Information Processing Systems, pp. 2672­2680. 2014.
P. Hand and V. Voroninski. Global guarantees for enforcing deep generative priors by empirical risk. In Conference on Learning Theory, 2018. arXiv:1705.07576.
P. Hand, O. Leong, and V. Voroninski. Phase retrieval under a generative prior. arXiv preprint arXiv:1807.04261, 2018.
R. Heckel, W. Huang, P. Hand, and V. Voroninski. Deep denoising: Rate-optimal recovery of structured signals with a deep prior. arXiv:1805.08855, 2018.
G. E. Hinton and R. R. Salakhutdinov. Reducing the dimensionality of data with neural networks. Science, 313(5786):504­507, 2006.
S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In International Conference on Machine Learning, pp. 448­456, 2015.
B. Laurent and P. Massart. Adaptive estimation of a quadratic functional by model selection. The Annals of Statistics, 28(5):1302­1338, 2000.
Y. Romano, M. Elad, and P. Milanfar. The little engine that could: Regularization by denoising (red). SIAM Journal on Imaging Sciences, 10(4):18041844, 2017.
F. Shamshad and A. Ahmed. Robust compressive phase retrieval via deep generative priors. arXiv preprint arXiv:1808.05854, 2018.
J.-L. Starck, E. J. Candes, and D. L. Donoho. The curvelet transform for image denoising. IEEE Transactions on Image Processing, 11(6):670­684, 2002.
L. Theis, W. Shi, A. Cunningham, and F. Husza´r. Lossy image compression with compressive autoencoders. arXiv:1703.00395, 2017.
G. Toderici, S. M. OMalley, S. J. Hwang, D. Vincent, D. Minnen, S. Baluja, M. Covell, and R. Sukthankar. Variable rate image compression with recurrent neural networks. In International Conference on Learning Representations, 2016.
D. Ulyanov, A. Vedaldi, and V. Lempitsky. Deep image prior. In Conference on Computer Vision and Pattern Recognition, 2018.
R. O. Winder. Partitions of n-space by hyperplanes. SIAM Journal on Applied Mathematics, 14(4): 811­818, 1966.
K. Zhang, W. Zuo, Y. Chen, D. Meng, and L. Zhang. Beyond a Gaussian denoiser: Residual learning of deep CNN for image denoising. IEEE Transactions on Image Processing, 26(7):3142­3155, 2017.
10

Under review as a conference paper at ICLR 2019

APPENDIX

A PROOF OF PROPOSITION 1

Suppose that the network has two layers, i.e., G(C) = Udrelu(B1C)c2. We start by re-writing B2 = relu(B1C) in a convenient form. For a given vector x  Rn, denote by diag(x > 0) the matrix that contains one on its diagonal if the respective entry of x is positive and zero otherwise. Let cjci denote the i-th column of Cj, and denote by Wji  {0, 1}k×k the corresponding diagonal matrix Wji = diag(Bjcjci > 0). With this notation, we can write

B2 = relu(B1C1) = [W11B1c1c1, . . . , W1kB1c1ck].

Thus,

c1c1 [c2 ]1 

G(C)

=

U1[W11B1,

.

.

.

,

W1k B1 ]

 

...

, 

c1c1[c2]k

where [c2]i denotes the i-th entry of c2. Thus, G(C) lies in the union of at-most-k2-dimensional subspaces of Rn, where each subspace is determined by the matrices {W1j}kj=1. The number of those subspaces is bounded by nk2 . This follows from the fact that for each matrix W1j, by Lemma 1 below, the number of different matrices is bounded by nk. Since there are k matrices, the number of different sets of matrices is bounded by nk2 .

Lemma 1. For any W  Rn×k and k  5,

|{diag(Wv > 0)W|v  Rk}|  nk.

Next, fix the matrixes {W1j}j. As G(C) lies in an at-most-k2-dimensional subspace, let S be a k2-dimensional subspace that contains the range of G for these fixed {W1j}j. It follows that

min
C

G(C) - 

2 2



PSc 



2 2

2
2.

Now, we make use of the following bound on the projection of the noise  onto a subspace.

(1)

Lemma 2. Let S  Rn be a subspace with dimension . Let   N (0, In) and   1. Then,

P

PSc 



2 2

2 2

1-

10 n

 1 - e- - e-n/16.

Proof of Lemma 2.

From

Laurent & Massart P X-n

(2000, 2 nx

Lem. + 2x

1), if X   e-x,

2n,

then

P

 X  n - 2 nx

 e-x.

With these, we obtain

P [X  5n]  e-n if   1,

(2)

P [X  n/2]  e-n/16.

(3)

We have

PSc 



2 2

2 2

=1-

.PS 

2 2



2 2

Note

that

PS 2  2 and



2 2

 2n. Applying inequality (2)

to bound

PS 2 and inequality (3) to bound



2 2

,

a

union

bound

gives

that

claim.

Thus, by inequality (1) and Lemma 2 with = k2, for all   1,

P

1



2

min
C

2

G(C) - 

2 2



1

-

10k2 n

{W1j }j

 1 - e-k2 - e-n/16.

Since the number of matrices {W1j}j is bounded by n1k2 , by a union bound,

(4)

P

1



2

min
C

2

G(C) - 

2 2



1

-

10k2 n

 nk12 (e-k2 + e-n/16)  2n-1 k2 ,

(5)

where the last inequality follows with choosing  = 2 log(n1) and by the assumption that k2 <

n 32 log

n1

.

This

proves

the

claim

in

Proposition

1.

11

Under review as a conference paper at ICLR 2019

Image PSNR

1 2
30 3
4 5 6
20 7

noiseless C1 noisy C2 noisy C3 noisy

10 0 10 20 weight noise SNR

C4 noisy C5 noisy C6 noisy c7 noisy

Figure 7: Sensitivity to parameter perturbations of the weights in each layer, and images generated by perturbing the weights in different layers, and keeping the weights in the other layers constant.

A.1 PROOF OF LEMMA 1

Our goal is to count the number of sign patterns (Wv > 0)  {0, 1}. Note that this number is equal to the maximum number of partitions one can get when cutting a k-dimensional space with n many hyperplanes that all pass through the origin, and are perpendicular to the rows of W. This number if well known (see for example Winder (1966)) and is upper bounded by

n-1 n - 1 2.
k
i=0

Thus,

n-1
|{diag(Wv > 0)W : v  Rk}|  2

i=0

where the last inequality holds for k  5.

n-1 k

 2k

e(n - 1)

k
 nk,

k

B SENSITIVITY TO PARAMETER PERTURBATIONS AND DISTRIBUTION OF
PARAMETERS

The deep decoder is not overly sensitive to perturbations of its coefficients. To demonstrate this, fit the standard test image Barbara with a deep decoder with 6 layers and k = 128, as before. We then perturb the weights in a given layer i (i.e., the matrix Ci) with Gaussian noise of a certain signal-tonoise ratio relative to Ci and leave the other weights and the input untouched. We then measure the peak signal-to-noise ratio in the image domain, and plot the corresponding curve for each layer (see Fig. 7). It can be seen that the representation provided by the deep decoder is relatively stable with respect to perturbations of its coefficients, and that it is more sensitive to perturbations in higher levels.
Finally, in Fig. 8 we depict the distribution of the weights of the network after fitted to the Barbara test image, and note that the weights are approximately Gaussian distributed.

1.5 1
0.5 0 -1 0

1 -2 0

2 -2-1 0 1 -4-2 0 2 -2 0

-2 0 2 -1 0 1

Figure 8: Distribution of the weights for fitting the test image Barbara along with a Gaussian fit: The distribution of the weighs is approximately Gaussian.

12

