Under review as a conference paper at ICLR 2019
Finding Mixed Nash Equilibria of Generative Adversarial Networks
Anonymous authors Paper under double-blind review
Abstract
We reconsider the training objective of Generative Adversarial Networks (GANs) from the mixed Nash Equilibria (NE) perspective. Inspired by the classical prox methods, we develop a novel algorithmic framework for GANs via an infinite-dimensional two-player game and prove rigorous convergence rates to the mixed NE, resolving the longstanding problem that no provably convergent algorithm exists for general GANs. We then propose a principled procedure to reduce our novel prox methods to simple sampling routines, leading to practically efficient algorithms. Finally, we provide experimental evidence that our approach outperforms methods that seek pure strategy equilibria, such as SGD, Adam, and RMSProp, both in speed and quality.
1 Introduction
The Generative Adversarial Network (GAN) (Goodfellow et al., 2014) has become one of the most powerful paradigms in learning real-world distributions, especially for image-related data. It has been successfully applied to a host of applications such as image translation (Isola et al., 2017; Kim et al., 2017; Zhu et al., 2017), super-resolution imaging (Wang et al., 2015), pose editing (Pumarola et al., 2018b), and facial animation (Pumarola et al., 2018a).
Despite of the many accomplishments, the major hurdle blocking the full impact of GAN is its notoriously difficult training phase. In the language of game theory, GAN seeks for a pure strategy equilibrium, which is well-known to be ill-posed in many scenarios (Dasgupta & Maskin, 1986). Indeed, it is known that a pure strategy equilibrium might not exist (Arora et al., 2017), might be degenerate (Sønderby et al., 2017), or cannot be reliably reached by existing algorithms (Mescheder et al., 2017).
Empirically, it has also been observed that common algorithms, such as SGD or Adam (Kingma & Ba, 2015), lead to unstable training. While much efforts have been devoted into understanding the training dynamics of GANs (Balduzzi et al., 2018; Gemp & Mahadevan, 2018; Gidel et al., 2018a;b; Liang & Stokes, 2018), a provably convergent algorithm for general GANs, even under reasonably strong assumptions, is still lacking.
In this paper, we address the above problems with the following contributions:
1. We propose to study the mixed Nash Equilibrium (NE) of GANs: Instead of searching for an optimal pure strategy which might not even exist, we optimize over the set of probability distributions over pure strategies of the networks. The existence of a solution to such problems was long established amongst the earliest game theory work (Glicksberg, 1952), leading to well-posed optimization problems.
2. We demonstrate that the prox methods of (Nemirovsky & Yudin, 1983; Nemirovski, 2004), which are fundamental building blocks for solving two-player games with finitely many strategies, can be extended to continuously many strategies, and hence applicable to training GANs. We provide an elementary proof for their convergence rates to learning the mixed NE.
3. We construct a principled procedure to reduce our novel prox methods to certain sampling tasks that were empirically proven easy by recent work (Chaudhari et al., 2017; 2018; Dziugaite & Roy, 2018). We further establish heuristic guidelines to greatly scale down the memory and computational costs, resulting in simple algorithms whose per-iteration complexity is almost as cheap as SGD.
1

Under review as a conference paper at ICLR 2019

4. We experimentally show that our algorithms consistently achieve better or comparable performance than popular baselines such as SGD, Adam, and RMSProp (Tieleman & Hinton, 2012).
Related Work: While the literature on training GANs is vast, to our knowledge, there exist only few papers on the mixed NE perspective. The notion of mixed NE is already present in (Goodfellow et al., 2014), but is stated only as an existential result. The authors of (Arora et al., 2017) advocate the mixed strategies, but do not provide a provably convergent algorithm. (Oliehoek et al., 2018) also considers mixed NE, but only with finitely many parameters. The work (Grnarova et al., 2018) proposes a provably convergent algorithm for finding the mixed NE of GANs under the unrealistic assumption that the discriminator is a single-layered neural network. In contrast, our results are applicable to arbitrary architectures, including popular ones (Arjovsky et al., 2017; Gulrajani et al., 2017).
Due to its fundamental role in game theory, many prox methods have been applied to study the training of GANs (Daskalakis et al., 2018; Gidel et al., 2018a; Mertikopoulos et al., 2018). However, these works focus on the classical pure strategy equilibria and are hence distinct from our problem formulation. In particular, they give rise to drastically different algorithms from ours and do not provide convergence rates for GANs.
In terms of analysis techniques, our framework is closely related to (Balandat et al., 2016), but with several important distinctions. First, the analysis of (Balandat et al., 2016) is based on dual averaging (Nesterov, 2009), while we consider Mirror Descent and also the more sophisticated Mirror-Prox (see Section 3). Second, unlike our work, (Balandat et al., 2016) do not provide any convergence rate for learning mixed NE of two-player games. Finally, (Balandat et al., 2016) is only of theoretical interest with no practical algorithm.
Notation: Throughout the paper, we use z to denote a generic variable and Z  Rd its domain. We denote the set of all Borel probability measures on Z by M(Z), and the set of all functions on Z by F(Z).1 We write dµ = dz to mean that the density function of µ  M(Z) with respect to the Lebesgue measure is . All integrals without specifying the measure are understood to be with respect to Lebesgue. For any objective of the form minx maxy F (x, y) with (xNE, yNE) achieving the saddle-point value, we say that (xT , yT ) is an O T -1/2 -NE if |F (xT , yT ) - F (xNE, yNE)| = O T -1/2 . Similarly we can define O T -1 -NE. The symbol · L denotes the L-norm of functions, and · TV denotes the total variation norm of probability measures.
2 Problem Formulation
We review standard results in game theory in Section 2.1, whose proof can be found in (Bubeck, 2013a;b;c). Section 2.2 relates training of GANs to the two-player game in Section 2.1, thereby suggesting to generalize the prox methods to infinite dimension.

2.1 Preliminary: Prox Methods for Finite Games

Consider the classical formulation of a two-player game with finitely many strategies:

min max q, a - q, Ap ,
pm qn

(1)

where A is a payoff matrix, a is a vector, and d := z  Rd |

d i=1

zi

=

1

is the proba-

bility simplex, representing the mixed strategies (i.e., probability distributions) over d pure

strategies. A pair (pNE, qNE) achieving the min-max value in (1) is called a mixed NE.

Assume that the matrix A is too expensive to evaluate whereas the (stochastic) gradients of

(1) are easy to obtain. Under such settings, a celebrated algorithm, the so-called entropic

Mirror Descent (entropic MD), learns an O T -1/2 -NE: Let (z) :=

d i=1

zi

log

zi

be

the

entropy function and  (y) := log

d i=1

eyi

=

supzd {

z, y

- (z)} be its Fenchel dual.

1Strictly speaking, our derivation requires mild regularity (see Appendix A.1) assumptions on the probability measure and function classes, which are met by most practical applications.

2

Under review as a conference paper at ICLR 2019

For a learning rate  and an arbitrary vector b  Rd, define the MD iterates as

z = MD (z, b)



z =  ((z) - b)



zi =

zie-bi

d i=1

zie-bi

,

1  i  d.

(2)

The equivalence of the last two formulas in (2) can be readily checked.

Denote

by

p¯T

:=

1 T

T t=1

pt

and

q¯T

:=

1 T

T t=1

qt

the

ergodic

average

of

two

sequences

{pt}Tt=1 and {qt}Tt=1. Then, with a properly chosen step-size , we have

pt+1 = MD pt, -A qt qt+1 = MD (qt, -a + Apt)

 (p¯T , q¯T ) is an O T -1/2 -NE.

Moreover, a slightly more complicated algorithm, called the entropic Mirror-Prox (entropy MP) (Nemirovski, 2004), achieves faster rate than the entropic MD:

pt = MD p~t, -A q~t , qt = MD (q~t, -a + Ap~t) ,

p~t+1 = MD p~t, -A qt q~t+1 = MD (q~t, -a + Apt)



(p¯T , q¯T ) is an O T -1 -NE.

If, instead of deterministic gradients, one uses unbiased stochastic gradients for entropic MD and MP, then both algorithms achieve O T -1/2 -NE in expectation.

2.2 Mixed Strategy Formulation for Generative Adversarial Networks

For illustration, let us focus on the Wasserstein GAN (Arjovsky et al., 2017). The training objective of Wasserstein GAN is

min


max
wW

EX Preal

[fw

(X

)]

-

EX P

[fw

(X

)],

(3)

where  is the set of parameters for the generator and W the set of parameters for the

discriminator2 f , typically both taken to be neural nets. As mentioned in the introduction,

such an optimization problem can be ill-posed, which is also supported by empirical evidence.

The high-level idea of our approach is, instead of solving (3) directly, we focus on the mixed strategy formulation of (3). In other words, we consider the set of all probability distributions over  and W, and we search for the optimal distribution that solves the following program:

min
M()

max
µM(W

)

Ewµ EX Preal

[fw

(X

)]

-

EwµE

EX P

[fw

(X

)].

(4)

Define the function g : W  R by g(w) := EXPreal [fw(X)] and the operator G : M()  F (W) as (G)(w) := E,XP [fw(X)]. Denoting µ, h := Eµh for any probability measure µ and function h, we may rewrite (4) as

min max µ, g - µ, G .
M() µM(W)

(5)

Furthermore, the Fr´echet derivative (the analogue of gradient in infinite dimension) of (5) with respect to µ is simply g - G, and the derivative of (5) with respect to  is -Gµ, where G : M(W)  F() is the adjoint operator of G defined via the relation

µ  M(W),   M(), µ, G = , Gµ .

(6)

One can easily check that (Gµ)() := EXP,wµ[fw(X)] achieves the equality in (6).

To summarize, the mixed strategy formulation of Wasserstein GAN is (5), whose derivatives can be expressed in terms of g and G. We now make the crucial observation that (5) is exactly the infinite-dimensional analogue of (1): The distributions over finite strategies are replaced with probability measures over a continuous parameter set, the vector a is replaced with a function g, the matrix A is replaced with a linear operator3 G, and the gradients are replaced with Fr´echet derivatives. Based on Section 2.1, it is then natural to ask:

Can the entropic Mirror Descent and Mirror-Prox be extended to infinite dimension to solve (5)? Can we retain the convergence rates?

We provide an affirmative answer to both questions in the next section.
Remark. The derivation in Section 2.2 can be applied to any GAN objective.
2Also known as "critic" in Wasserstein GAN literature. 3The linearity of G trivially follows from the linearity of expectation.

3

Under review as a conference paper at ICLR 2019

3 Infinite-Dimensional Prox Methods
This section builds a rigorous infinite-dimensional formalism in parallel to the finitedimensional prox methods and proves their convergence rates. While simple in retrospect, to our knowledge, these results are new.

3.1 Preparation: The Mirror Descent Iterates

We first recall the notion of (Fr´echet) derivative in infinite-dimensional spaces. A (nonlinear)
functional  : M(Z)  R is said to possess a derivative at µ  M(Z) if there exists a function d(µ)  F(Z) such that, for all µ  M(Z), we have

(µ + µ ) = (µ) + µ , d(µ) + o( ).

Similarly, a (nonlinear) functional  : F(Z)  R is said to possess a derivative at h  F(Z) if there exists a measure d (h)  M(Z) such that, for all h  F(Z), we have

 (h + h ) =  (h) + d (h), h + o( ).

The most important functionals in this paper are the (negative) Shannon entropy

and its Fenchel dual

µ  M(Z), (µ) :=

dµ dµ log

dz

h  F (Z),  (h) := log ehdz.

The first result of our paper is to show that, in direct analogy to (2), the infinite-dimensional MD iterates can be expressed as:
Theorem 1 (Infinite-Dimensional Mirror Descent, informal). For a learning rate  and an arbitrary function h, we can equivalently define

e-hdµ µ+ = MD (µ, h)  µ+ = d (d(µ) - h)  dµ+ = e-hdµ .

(7)

Moreover, most the essential ingredients in the analysis of finite-dimensional prox methods can be generalized to infinite dimension.

See Theorem 4 of Appendix A for precise statements and a long list of "essential ingredients of prox methods" generalizable to infinite dimension.
3.2 Infinite-Dimensional Prox Methods and Convergence Rates Armed with results in Section 3.1, we now introduce two "conceptual" algorithms for solving the mixed NE of Wasserstein GANs: The infinite-dimensional entropic MD in Algorithm 1 and MP in Algorithm 2. These algorithms iterate over probability measures and cannot be directly used in practice, but they possess rigorous convergence rates, and hence motivate the reduction procedure in Section 4 to come.

Algorithm 1: Infinite-Dimensional Entropic MD

Input: Initial distributions µ1, 1, learning rate  for t = 1, 2, . . . , T - 1 do
t+1 = MD t, -Gµt , µt+1 = MD (µt, -g + Gt);

return

¯T

=

1 T

T t=1

t

and

µ¯T

=

1 T

T t=1

µt

.

Theorem 2 (Convergence Rates). Let (µ) =

dµ log

dµ dz

.

Let

M

be

a

constant

such

that

max -g + G L , Gµ L  M , and L be such that G( -  ) L  L  -  TV

and G(µ - µ ) L  L µ - µ TV. Let D(·, ·) be the relative entropy, and denote by

D0 := D(µNE, µ1) + D(NE, 1) the initial distance to the mixed NE. Then

4

Under review as a conference paper at ICLR 2019

Algorithm 2: Infinite-Dimensional Entropic MP

Input: Initial distributions µ~1, ~1, learning rate  for t = 1, 2, . . . , T do
t = MD ~t, -Gµ~t , µt = MD (µ~t, -g + G~t); ~t+1 = MD ~t, -Gµt , µ~t+1 = MD (µ~t, -g + Gt);

return

¯T

=

1 T

T t=1

t

and

µ¯T

=

1 T

T t=1

µt

.

1. Assume that we have access to the deterministic derivatives

-Gµt

T t=1

and

{g - G}tT=1.

Then Algorithm

1 achieves O

T -1/2

-NE with  =

2 M

D0 T

,

and

Algorithm 2 achieves O

T -1

-NE

with



=

4 L

.

T

2. Assume that we have access to unbiased stochastic derivatives -G^µt

and

t=1

T

g^ - G^

such that max E -g^ + G^ , E G^µ

 M , and the variance

t=1

L L

is upper bounded by 2. Then Algorithm 1 with stochastic derivatives achieves

O

T -1/2

-NE

in

expectation

with



=

2 M

D0 T

,

and

Algorithm

2

with

stochastic

derivatives achieves O T -1/2 -NE in expectation with  = min 4 ,
3L

2D0 3T 2

.

The proof can be found in Appendix B and C.
Remark. If, as in previous work (Arora et al., 2017), we assume the output of the discriminator to be bounded by U , then we have M, M  2U and L  U in Theorem 2.

4 From Theory to Practice

Section 4.1 reduces Algorithm 1 and Algorithm 2 to a sampling routine (Welling & Teh, 2011) that has widely been used in machine learning. Section 4.2 proposes to further simplify the algorithms by summarizing a batch of samples by their mean.
For simplicity, we will only derive the algorithm for entropic MD; the case for entropic MP is similar but requires more computation. To ease the notation, we assume  = 1 throughout this section as  does not play an important role in the derivation below.

4.1 Implementable Entropic MD: From Probability Measure to Samples

Consider Algorithm 1. The reduction consists of three steps.

Step 1: Reformulating Entropic Mirror Descent Iterates

The definition of the MD iterate (7) relates the updated probability measure µt+1 to the current probability measure µt, but it tells us nothing about the density function of µt+1, from which we want to sample. Our first step is to express (7) in a more tractable form.
By recursively applying (7) and using Theorem 4.10 in Appendix A, we have, for some
constants C1, ..., CT -1,

d(µT ) = d(µT -1) - (-g + GT -1) + CT -1

= d(µT -2) - (-g + GT -2) - (-g + GT -1) + CT -1 + Ct-2

T -1

T -1

= · · · = d(µ1) - -(T - 1)g + G s + Cs.

s=1

s=1

For simplicity, assume that µ1 is uniform so that d(µ1) is a constant function. Then,

by (13) and that d (d(µT )) = dµT , we see that the density function of µT is simply

dµT =

exp{(T -1)g-G exp{(T -1)g-G

T -1
}s=1

s

dw

.T -1 }s=1

s

dw

Similarly,

we

have

dT

=

exp{G exp{G

T -1
}s=1

µs

d

.T -1 }s=1

µs

d

5

Under review as a conference paper at ICLR 2019

Step 2: Empirical Approximation for Stochastic Derivatives

The derivatives of (5) involve the function g and operator G. Recall that g requires taking expectation over the real data distribution, which we do not have access to. A common approach is to replace the true expectation with its empirical average:

g(w) = EXPreal [fw(X)]

1 n

n

fw (Xireal )

i=1

g^(w)

where Xi's are real data and n is the batch size. Clearly, g^ is an unbiased estimator of g.
On the other hand, Gt and Gµt involve expectation over t and µt, respectively, and also over the fake data distribution P. Therefore, if we are able to draw samples from µt and t, then we can again approximate the expectation via the empirical average:

(1), (2), ..., (n )  t,

Xi(j)

n
 P(j) ,
i=1

G^t(w)

w(1), w(2), ..., w(n )  µt, {Xi}ni=1  P,

G^µt()

1 nn

n

n
fw Xi(j)

i=1 j=1

1 nn nn fw(j) (Xi) .
i=1 j=1

Now, assuming that we have obtained unbiased stochastic derivatives -

t s=1

G^µs

and

t s=1

-g^ + G^s

, how do we actually draw samples from µt+1 and t+1? Provided we can

answer this question, then we can start with two easy-to-sample distributions (µ1, 1), and then we will be able to draw samples from (µ2, 2). These samples in turn will allow us to draw samples from (µ3, 3), and so on. Therefore, it only remains to answer the above question. This leads us to:

Step 3: Sampling by Stochastic Gradient Langevin Dynamics
For any probability distribution with density function e-hdz, the Stochastic Gradient Langevin Dynamics (SGLD) (Welling & Teh, 2011) iterates as

zk+1 = zk - ^ h(zk) + 2 k,

(8)

where  is the step-size, ^ h is an unbiased estimator of h, is the thermal noise, and k  N (0, I) is a standard normal vector, independently drawn across different iterations.
Suppose we start at (µ1, 1). Plugging h  -G^µ1 and h  -g^ + G^1 into (8), we obtain, for {Xi}ni=1  Pk , {w(j)}jn=1  µ1 and Xireal  Preal, {(j)}jn=1  1, {Xi(j)}  P(j) , the following update rules:



1 nn

k+1 = k +   nn

fw(j) (Xi)

i=1 j=1



wk+1

=

wk

+

w



1 n

n

fwk (Xireal)

-

1 nn

n

n
fwk

i=1 i=1 j=1

 Xi(j)  .

The theory of (Welling & Teh, 2011) states that, for large enough k, the iterates of SGLD above (approximately) generate samples according to the probability measures (µ2, 2). We can then apply this process recursively to obtain samples from (µ3, 3), (µ4, 4), ...(µT , T ). Finally, since the entropic MD and MP output the averaged measure (µ¯T , ¯T ), it suffices to pick a random index t^  {1, 2, ..., T } and then output samples from (µt^, t^).
Putting Step 1-3 together, we obtain Algorithm 4 and 5 in Appendix D.
Remark. In principle, any first-order sampling method is valid above. In the experimental section, we also use a RMSProp-preconditioned version of the SGLD (Li et al., 2016).

6

Under review as a conference paper at ICLR 2019

4.2 Summarizing Samples by Averaging: A Simple yet Effective Heuristic Although Algorithm 4 and 5 are implementable, they are quite complicated and resourceintensive, as the total computational complexity is O(T 2). This high complexity comes from the fact that, when computing the stochastic derivatives, we need to store all the historical samples and evaluate new gradients at these samples.
An intuitive approach to alleviate the above issue is to try to summarize each distribution by only one parameter. To this end, the mean of the distribution is the most natural candidate, as it not only stablizes the algorithm, but also is often easier to acquire than the actual samples. For instance, computing the mean of distributions of the form e-hdz, where h is a loss function defined by deep neural networks, has been empirically proven successful in (Chaudhari et al., 2017; 2018; Dziugaite & Roy, 2018) via SGLD. In this paper, we adopt the same approach as in (Chaudhari et al., 2017) where we use exponential damping (the  term in Algorithm 3) to increase stability. Algorithm 3, dubbed the Mirror-GAN, shows how to encompass this idea into entropic MD; the pseudocode for the similar Mirror-Prox-GAN can be found in Algorithm 6 of Appendix D.

Algorithm 3: Mirror-GAN: Approximate Mirror Decent for GANs

Input: w¯1, ¯1  random initialization, {t}Tt=1, { t}Tt=1, {Kt}Tt=-11,  (see Appendix D for meaning of the hyperparameters).
for t = 1, 2, . . . , T - 1 do

w¯t, wt(1)  wt;

¯t, t(1)  t;

for k = 1, 2, . . . , Kt do

Generate t(k+1) =

A = {X1, . .

t(k)

+

t n



.

,

Xn}  Pt(k) ; XiA fwt (Xi)

+

 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

Generate B = {X1, . . . , Xn}  Pt ;

wt(k+1)

=

wt(k)

+

t n

w

fwt(k) (Xireal)

-

t n

w

fwt(k) (Xi) +

Xireal B

Xi B

w¯t  (1 - )w¯t + wt(k+1); ¯t  (1 - )¯t + t(k+1) ;
wt+1  (1 - )wt + w¯t; t+1  (1 - )t + ¯t;
return wT , T .

2t tN (0, I);

5 Experimental Evidence
The purpose of our experiments is twofold. First, we use established baselines to demonstrate that Mirror- and Mirror-Prox-GAN consistently achieve better or comparable performance than common algorithms. Second, we report that our algorithms are stable and always improve as the training process goes on. This is in contrast to unstable training algorithms, such as Adam, which often collapse to noise as the iteration count grows. (Cha, 2017).
We use visual quality of the generated images to evaluate different algorithms. We avoid reporting numerical metrics, as recent studies (Barratt & Sharma, 2018; Borji, 2018; Lucic et al., 2018) suggest that these metrics might be flawed. Setting of the hyperparameters and more auxiliary results can be found in Appendix E.

5.1 Synthetic Data
We repeat the synthetic setup as in (Gulrajani et al., 2017). The tasks include learning the distribution of 8 Gaussian mixtures, 25 Gaussian mixtures, and the Swiss Roll. For

7

Under review as a conference paper at ICLR 2019

both the generator and discriminator, we use two MLPs with three hidden layers of 512
neurons. We choose SGD and Adam as baselines, and we compare them to Mirror- and Mirror-Prox-GAN. All algorithms are run up to 105 iterations4. The results of 25 Gaussian
mixtures are shown in Figure 1; An enlarged figure of 25 Gaussian Mixtures and other cases
can be found in Appendix E.1.

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(a) SGD

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(b) Adam

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0
(c) Mirror-GAN

1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(d) Mirror-Prox-GAN

Figure 1: Fitting 25 Gaussian mixtures up to 105 iterations. Blue dots represent the true distribution and red ones are from the trained generator.

As Figure 1 shows, SGD performs poorly in this task, while the other algorithms yield reasonable results. However, compared to Adam, Mirror- and Mirror-Prox-GAN fit the true distribution better in two aspects. First, the modes found by Mirror- and Mirror-ProxGAN are more accurate than the ones by Adam, which are perceivably biased. Second, Mirror- and Mirror-Prox-GAN perform much better in capturing the variance (how spread the blue dots are), while Adam tends to collapse to modes. These observations are consistent throughout the synthetic experiments; see Appendix E.1.

5.2 Real Data
For real images, we use the LSUN bedroom dataset (Yu et al., 2015). We have also conducted a similar study with MNIST; see Appendix E.2.1 for details.
We use the same architecture (DCGAN) as in (Radford et al., 2015) with batch normalization. As the networks become deeper in this case, the gradient magnitudes differ significantly across different layers. As a result, non-adaptive methods such as SGD or SGLD do not perform well in this scenario. To alleviate such issues, we replace SGLD by the RMSProppreconditioned SGLD (Li et al., 2016) for our sampling routines. For baselines, we consider two adaptive gradient methods: RMSprop and Adam.
Figure 2 shows the results at the 105th iteration. The RMSProp and Mirror-GAN produce images with reasonable quality, while Adam outputs noise. The visual quality of MirrorGAN is better than RMSProp, as RMSProp sometimes generates blurry images (the (3, 3)and (1, 5)-th entry of Figure 8.(b)).
It is worth mentioning that Adam can learn the true distribution at intermediate iterations, but later on suffers from mode collapse and finally degenerates to noise; see Appendix E.2.2.

6 Conclusions
Our goal of systematically understanding and expanding on the game theoretic perspective of mixed NE along with stochastic Langevin dynamics for training GANs is a promising research vein. While simple in retrospect, we provide guidelines in developing approximate infinite-dimensional prox methods that mimic closely the provable optimization framework to learn the mixed NE of GANs. Our proposed Mirror- and Mirror-Prox-GAN algorithm feature cheap per-iteration complexity while rapidly converging to solutions of good quality.
4One iteration here means using one mini-batch of data. It does not correspond to the T in our algorithms, as there might be multiple SGLD iterations within each time step t.
8

Under review as a conference paper at ICLR 2019

(a) RMSProp

(b) Adam

(c) Mirror-GAN

Figure 2: Dataset LSUN bedroom, 105 iterations.

References
Martin Arjovsky, Soumith Chintala, and L´eon Bottou. Wasserstein gan. arXiv preprint arXiv:1701.07875, 2017.
Sanjeev Arora, Rong Ge, Yingyu Liang, Tengyu Ma, and Yi Zhang. Generalization and equilibrium in generative adversarial nets (gans). In International Conference on Machine Learning, pp. 224­232, 2017.
Maximilian Balandat, Walid Krichene, Claire Tomlin, and Alexandre Bayen. Minimizing regret on reflexive banach spaces and nash equilibria in continuous zero-sum games. In Advances in Neural Information Processing Systems, pp. 154­162, 2016.
David Balduzzi, Sebastien Racaniere, James Martens, Jakob Foerster, Karl Tuyls, and Thore Graepel. The mechanics of n-player differentiable games. In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp. 354­363, StockholmsmA~ d'ssan, Stockholm Sweden, 10­15 Jul 2018. PMLR.
Shane Barratt and Rishi Sharma. A note on the inception score. arXiv preprint arXiv:1801.01973, 2018.
Ali Borji. Pros and cons of gan evaluation measures. arXiv preprint arXiv:1802.03446, 2018.
Sebastien Bubeck. Orf523: Mirror descent, part i/ii, 2013a. URL https://blogs. princeton.edu/imabandit/2013/04/16/orf523-mirror-descent-part-iii/.
Sebastien Bubeck. Orf523: Mirror descent, part ii/ii, 2013b. URL https://blogs. princeton.edu/imabandit/2013/04/18/orf523-mirror-descent-part-iiii/.
Sebastien Bubeck. Orf523: Mirror prox, 2013c. URL https://blogs.princeton.edu/ imabandit/2013/04/23/orf523-mirror-prox/.
Junbum Cha. Implementations of (theoretical) generative adversarial networks and comparison without cherry-picking. https://github.com/khanrc/tf.gans-comparison, 2017.
Pratik Chaudhari, Anna Choromanska, Stefano Soatto, Yann LeCun, Carlo Baldassi, Christian Borgs, Jennifer Chayes, Levent Sagun, and Riccardo Zecchina. Entropy-sgd: Biasing gradient descent into wide valleys. In International Conference on Learning Representations, 2017.
Pratik Chaudhari, Adam Oberman, Stanley Osher, Stefano Soatto, and Guillaume Carlier. Deep relaxation: partial differential equations for optimizing deep neural networks. Research in the Mathematical Sciences, 5(3):30, Jun 2018.
9

Under review as a conference paper at ICLR 2019
Partha Dasgupta and Eric Maskin. The existence of equilibrium in discontinuous economic games, i: Theory. The Review of economic studies, 53(1):1­26, 1986.
Constantinos Daskalakis, Andrew Ilyas, Vasilis Syrgkanis, and Haoyang Zeng. Training GANs with optimism. In International Conference on Learning Representations, 2018.
Gintare Karolina Dziugaite and Daniel Roy. Entropy-sgd optimizes the prior of a pacbayes bound: Generalization properties of entropy-sgd and data-dependent priors. In International Conference on Machine Learning, pp. 1376­1385, 2018.
Ian Gemp and Sridhar Mahadevan. Global convergence to the equilibrium of gans using variational inequalities. arXiv preprint arXiv:1808.01531, 2018.
J Willard Gibbs. Elementary principles in statistical mechanics. Yale University Press, 1902.
Gauthier Gidel, Hugo Berard, Pascal Vincent, and Simon Lacoste-Julien. A variational inequality perspective on generative adversarial nets. arXiv preprint arXiv:1802.10551, 2018a.
Gauthier Gidel, Reyhane Askari Hemmat, Mohammad Pezeshki, Gabriel Huang, Remi Lepriol, Simon Lacoste-Julien, and Ioannis Mitliagkas. Negative momentum for improved game dynamics. arXiv preprint arXiv:1807.04740, 2018b.
Irving L Glicksberg. A further generalization of the kakutani fixed point theorem, with application to nash equilibrium points. Proceedings of the American Mathematical Society, 3(1):170­174, 1952.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural information processing systems, pp. 2672­2680, 2014.
Robert M Gray. Entropy and information theory. Springer Science & Business Media, 2011.
Paulina Grnarova, Kfir Y Levy, Aurelien Lucchi, Thomas Hofmann, and Andreas Krause. An online learning approach to generative adversarial networks. In International Conference on Learning Representations, 2018.
Ishaan Gulrajani, Faruk Ahmed, Martin Arjovsky, Vincent Dumoulin, and Aaron C Courville. Improved training of wasserstein gans. In Advances in Neural Information Processing Systems, pp. 5767­5777, 2017.
Paul R Halmos. Measure theory, volume 18. Springer, 2013.
Phillip Isola, Jun-Yan Zhu, Tinghui Zhou, and Alexei A Efros. Image-to-image translation with conditional adversarial networks. arXiv preprint, 2017.
Anatoli Juditsky and Arkadi Nemirovski. First order methods for nonsmooth convex largescale optimization, ii: utilizing problems structure. Optimization for Machine Learning, pp. 149­183, 2011.
Taeksoo Kim, Moonsu Cha, Hyunsoo Kim, Jung Kwon Lee, and Jiwon Kim. Learning to discover cross-domain relations with generative adversarial networks. In International Conference on Machine Learning, pp. 1857­1865, 2017.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International Conference on Learning Representations, 2015.
Chunyuan Li, Changyou Chen, David E Carlson, and Lawrence Carin. Preconditioned stochastic gradient langevin dynamics for deep neural networks. In AAAI, 2016.
Tengyuan Liang and James Stokes. Interaction matters: A note on non-asymptotic local convergence of generative adversarial networks. arXiv preprint arXiv:1802.06132, 2018.
10

Under review as a conference paper at ICLR 2019
Mario Lucic, Karol Kurach, Marcin Michalski, Sylvain Gelly, and Olivier Bousquet. Are gans created equal? a large-scale study. In Advances in neural information processing systems, 2018.
Panayotis Mertikopoulos, Houssam Zenati, Bruno Lecouat, Chuan-Sheng Foo, Vijay Chandrasekhar, and Georgios Piliouras. Mirror descent in saddle-point problems: Going the extra (gradient) mile. arXiv preprint arXiv:1807.02629, 2018.
Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. The numerics of gans. In Advances in Neural Information Processing Systems, pp. 1825­1835, 2017.
Arkadi Nemirovski. Prox-method with rate of convergence o (1/t) for variational inequalities with lipschitz continuous monotone operators and smooth convex-concave saddle point problems. SIAM Journal on Optimization, 15(1):229­251, 2004.
AS Nemirovsky and DB Yudin. Problem complexity and method efficiency in optimization. 1983.
Yurii Nesterov. Primal-dual subgradient methods for convex problems. Mathematical programming, 120(1):221­259, 2009.
Frans A Oliehoek, Rahul Savani, Jose Gallego, Elise van der Pol, and Roderich Groß. Beyond local nash equilibria for adversarial networks. arXiv preprint arXiv:1806.07268, 2018.
Albert Pumarola, Antonio Agudo, Aleix M Martinez, Alberto Sanfeliu, and Francesc Moreno-Noguer. Ganimation: Anatomically-aware facial animation from a single image. In Proceedings of the European Conference on Computer Vision (ECCV), pp. 818­833, 2018a.
Albert Pumarola, Antonio Agudo, Alberto Sanfeliu, and Francesc Moreno-Noguer. Unsupervised person image synthesis in arbitrary poses. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 8620­8628, 2018b.
Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. arXiv preprint arXiv:1511.06434, 2015.
Casper Kaae Sønderby, Jose Caballero, Lucas Theis, Wenzhe Shi, and Ferenc Husz´ar. Amortised map inference for image super-resolution. 2017.
Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26­31, 2012.
Zhaowen Wang, Ding Liu, Jianchao Yang, Wei Han, and Thomas Huang. Deep networks for image super-resolution with sparse prior. In Proceedings of the IEEE International Conference on Computer Vision, pp. 370­378, 2015.
Max Welling and Yee W Teh. Bayesian learning via stochastic gradient langevin dynamics. In Proceedings of the 28th International Conference on Machine Learning (ICML-11), pp. 681­688, 2011.
Fisher Yu, Ari Seff, Yinda Zhang, Shuran Song, Thomas Funkhouser, and Jianxiong Xiao. Lsun: Construction of a large-scale image dataset using deep learning with humans in the loop. arXiv preprint arXiv:1506.03365, 2015.
Jun-Yan Zhu, Taesung Park, Phillip Isola, and Alexei A Efros. Unpaired image-to-image translation using cycle-consistent adversarial networks. In IEEE International Conference on Computer Vision, 2017.
11

Under review as a conference paper at ICLR 2019

A A Framework for Infinite-Dimensional Mirror Descent
A.1 A note on the regularity
It is known that the (negative) Shannon entropy is not Fr´echet differentiable in general. However, below we show that the Fr´echet derive can be well-defined if we restrict the probability measures to within the set M(Z) :={all probability measures on Z that admit densities w.r.t. the Lebesgue measure,
and the density is continuous and positive almost everywhere on Z}. We will also restrict the set of functions to be bounded and integrable:
F(Z) := {all bounded integrable functions on Z}. It is important to notice that µ  M(Z) and h  F (Z) implies µ = MD (µ, h)  M(Z); this readily follows from the formula (7).

A.2 Properties of Entropic Mirror Map

The total variation of a (possibly non-probability) measure µ  M(Z) is defined as (Halmos, 2013)

µ TV = sup hdµ = sup µ, h .

h L 1

h L 1

We depart from the fundamental Gibbs Variational Principle, which dates back to the earliest work of statistical mechanics (Gibbs, 1902). For two probability measures µ, µ , denote their relative entropy by (the reason for this notation will become clear in (14))

dµ

D(µ, µ ) :=

dµ log . Z dµ

Theorem 3 (Gibbs Variation Principle). Let h  F(Z) and µ  M(Z) be a reference measure. Then

log ehdµ = sup µ, h - D(µ, µ ),
Z µM(Z)

(9)

and equality is achieved by dµ

=

eh dµ Z ehdµ

.

Part of the following theorem is folklore in the mathematics and learning community. However, to the best of our knowledge, the relation to the entropic MD has not been systematically studied before, as we now do.
Theorem 4. For a probability measure dµ = dz, let (µ) =  log dz be the negative Shannon entropy, and let  (h) = log Z ehdz. Then

1.  is the Fenchel conjugate of :

 (h) = sup µ, h - (µ);
µM(Z )
(µ) = sup µ, h -  (h).
hF (Z)

(10) (11)

2. The derivatives admit the expression

d(µ) = 1 + log  = arg max µ, h -  (h);
hF (Z)

d (h) =

ehdz Z ehdz

= arg max
µM(Z )

µ, h

- (µ).

(12) (13)

3. The Bregman divergence of  is the relative entropy:

D(µ, µ ) = (µ) - (µ ) - µ - µ , d(µ )

=

dµ dµ log . Z dµ

(14)

12

Under review as a conference paper at ICLR 2019

4.  is 4-strongly convex with respect to the total variation norm: For all   (0, 1),

(µ + (1 - )µ )  (µ) + (1 - )(µ ) - 1 · 4(1 - ) µ - µ 2

2 TV

.

(15)

5. The following duality relation holds: For any constant C, we have

µ, µ  M(Z), D(µ, µ ) = D (d(µ ), d(µ)) = D (d(µ ) + C, d(µ)) . (16)

6. 

is

1 4

-smooth

with

respect

to

· L :

1 h, h  F (Z), d (h) - d (h ) TV  4 h - h L .

(17)

7. Alternative to (17), we have the equivalent characterization of  :

h, h  F(Z),

 (h)   (h ) + d (h ), h - h

+1·1 24

h-h

2 L

.

(18)

8. Similar to (16), we have h, h , D (h, h ) = D(d (h ), d (h)).

(19)

9. The following three-point identity holds for all µ, µ , µ  M(Z): µ - µ, d(µ ) - d(µ) = D(µ, µ ) + D(µ , µ) - D(µ , µ ).

(20)

10. Let the Mirror Descent iterate be defined as in (7). Then the following statements are equivalent:

(a) µ+ = MD (µ, h). (b) There exists a constant C such that d(µ+) = d(µ) - h + C.
In particular, for any µ , µ  M(Z) we have Let µ - µ , h = µ - µ , d(µ) - d(µ+) .

(21)

Proof.

1. Equation (10) is simply the Gibbs variational principle (9) with dµ  dz. By (10), we know that

h  F (Z), (µ)  µ, h - log ehdz.
Z

(22)

But for dµ = dz, the function h := 1 + log  saturates the equality in (22).

2. We prove a more general result on the Bregman divergence D in (23) below.
Let dµ = dz, dµ =  dz, and dµ =  dz  M(Z). Let > 0 be small enough such that ( +  )dz is absolutely continuous with respect to dµ ; note that this is possible because µ, µ , and µ  M(Z). We compute

+ 

D( +  ,  ) = ( +  ) log
Z



 



=  log +  log 1 +

+  log +  log 1 +

Z Z

 Z Z



(=i)

  log +

+



 log

+

2

2 + o( )

Z

Z

Z

Z



= D(,  ) +


Z

1 + log 

+ o( ),

13

Under review as a conference paper at ICLR 2019

where (i) uses log(1 + t) = t + o(t) as t  0. In short, for all µ , µ  M(Z),



dµD(µ, µ )(µ ) =

µ , 1 + log 

(23)

which

means

dµD(µ,

µ

)

=

1

+

log

 

.

The formula (12) is the special case

when

dµ  dz.

We now turn to (13). For every h  F(Z), we need to show that the following holds for every h  F(Z):

 (h + h ) -  (h) = log eh+ h dz - log ehdz =
ZZ

eh

h
Z

Z eh dz + o( ). (24)

Define an auxiliary function

T ( ) := log

Z

eh Z eh

e

h

dz.

Notice that T (0) = 0 and T is smooth as a function of . Thus, by the Intermediate Value Theorem,

 (h + h ) -  (h) = T ( ) - T (0) = ( - 0) · d T (·) d

for some  [0, ]. A direct computation shows

d T (·) d

eh+ h

=

h
Z

Z eh+ h dz.

Hence it suffices to prove

eh+ h Z eh+ h

=

eh Z eh

+ o(1)

in

.

To this end, let C =

sup |h | < . Then

eh Z eh

e-2

C

eh+ h Z eh+ h



eh Z eh

e2

C.

It remains to use et = 1 + t + o(t) and  .

3. Let dµ = dz and dµ =  dz. We compute

D(µ, µ ) = (µ) - (µ ) - µ - µ , d(µ )

=  log dz -  log  dz - µ - µ , 1 + log 
ZZ
 =  log dz
Z dµ
= dµ log . Z dµ

by (12)

4. Define µ = µ + (1 - )µ . By (14) and the classical Pinsker's inequality (Gray, 2011), we have

(µ)  (µ) + (1 - )(µ - µ ), d(µ) + 2 (1 - )(µ - µ ) T2 V, (µ )  (µ) + (µ - µ), d(µ) + 2 (µ - µ ) T2 V.

(25) (26)

Equation (15) follows by multiplying with  and 1 -  respectively and summing the two inequalities up.

14

Under review as a conference paper at ICLR 2019

5. Let µ = dz and µ =  dz. Then, by the definition of Bregman divergence and (12), (13),

D (d(µ ), d(µ)) =  (d(µ )) -  (d(µ)) -

e1+log dz Z e1+log  , 1 + log 

- 1 - log 

= log

e1+log  - log

e1+log  +

  log

Z Z Z



=

 log Z

= D(µ, µ )

since Z dz = Z  dz = 1. This proves the first equality. For the second equality, we write

D (d(µ ) + C, d(µ)) =  (d(µ ) + C) -  (d(µ)) -

e1+log dz Z e1+log  , 1 + log 

+ C - 1 - log 

= log e1+log  +C - log e1+log  +  log  - C Z Z Z

 =  log
Z

= D(µ, µ ) = D (d(µ ), d(µ))

where we have used the first equality in the last step.

6. Let µh = d (h), µh = d (h ), and µ = µh + (1 - )µh for some   (0, 1). By Pinsker's inequality and (14), we have

(µ)  (µh) +

µ - µh, d(µh)

+2

µ - µh

2 TV

,

(µ)  (µh ) + µ - µh , d(µh )

+ 2 µ - µh

2 TV

.

(27) (28)

Now, notice that

µ - µh, d(µh) = µ - µh, d(d (h))

=

µ - µh, d

ehdz Z eh

by (13)

= µ - µh, 1 + h - log eh
Z
= µ - µh, h

by (12)

and, similarly, we have µ - µh , d(µh ) = µ - µh , h . Multiplying (27) by  and (28) by 1 - , summing the two up, and using the above equalities, we get

(µ) -

(µh) + (1 - )(µh )

+ (1 - ) µh - µh , h - h

 2(1 - ) µh - µh

2 TV

.

By (15), we know that

(µ) -

(µh) + (1 - )F (µh )

 -2(1 - ) µh - µh

2 TV

.

Moreover, by definition of the total variation norm, it is clear that

µh - µh , h - h  µh - µh TV h - h L . Combing the last three inequalities gives (17).

(29)

7.

Let K

be

a

positive

integer and

k  {0, 1, 2, . . . , K}.

Set

k

=

k K

and

h

=h-h.

Then

 (h) -  (h ) =  (h + K h ) -  (h + 0h )
K -1
=  (h + k+1h ) -  (h + kh ) .
k=0

(30)

15

Under review as a conference paper at ICLR 2019

By convexity of  , we have

 (h + k+1h ) -  (h + kh )  d (h + k+1h ), (k+1 - k)h

1

= K

d (h + k+1h ), h

.

(31)

By (29) and (17), we may further upper bound (31) as



(h

+ k+1h

)-

(h

+ kh

)

1 K

1 K

1 K

d (h ), h + d (h + k+1h ) - d (h ), h

d (h ), h d (h ), h

+ d (h + k+1h ) - d (h ) TV h

+ k+1 4

h

2 L

.

(32)

L

Summing up (32) over k, we get, in view of (30),

 (h) -  (h )  d (h ), h = d (h ), h

1 +h
4

K -1

2 L

k+1

k=0

+ 1 · K+1 h 4 2K

2 L

.

Since K is arbitrary, we may take K   in (33), which is (18).

(33)

8. Straightforward calculation shows

D (h, h ) = log

eh - log
Z

eh -
Z

Z

eh eh

(h - h ) .

On the other hand, by definition of the Bregman divergence and (12), (13), we have

D(d (h ), d (h)) =

Z

eh Z eh

h

- log

eh -
Z

Z

eh Z eh h + log

eh
Z

- 1 + h - log eh
ZZ

eh Z eh

-

eh Z eh

=

Z

eh eh (h - h) - log

eh + log
Z

eh
Z

=  (h) -  (h ) - d (h ), h - h

= D (h, h ).

9. By definition of the Bregman divergence, we have D(µ, µ ) = (µ) - (µ ) - µ - µ , d(µ ) , D(µ , µ) = (µ ) - (µ) - µ - µ, d(µ) ,
D(µ , µ ) = (µ ) - (µ ) - µ - µ , d(µ ) . Equation (20) then follows by straightforward calculations.
10. First, let µ+ = MD (µ, h). Then if µ+ = +dz and µ = dz, then (7) implies e-h
+ = Z e-h . By (12), we therefore have
d(µ+) = 1 + log +
= 1 + log  - h - log e-h
Z

16

Under review as a conference paper at ICLR 2019

whence (21) holds with C = - log Z e-h.
Conversely, assume that d(µ+) = d(µ) - h + C for some constant C, and apply d to both sides. The left-hand side becomes

d d(µ+) = d (1 + log +)

=

+dz +dz

=

+dz

=

dµ+,

where as the formula (13) implies that

e1+log -h+C d (d(µ) - h + C) = Z e1+log -h+C dz
e-hdz = Z e-h
e-hdµ = Z e-hdµ .

Combining the two equalities gives dµ+ =

e-h dµ Z e-hdµ

which

exactly

means

µ+

=

MD (µ, h).

B Proof of Convergence Rates for Infinite-Dimensional Mirror Descent

B.1 Mirror Descent, Deterministic Derivatives

By the definition of the algorithm, (21), and the three-point identity (20), we have, for any µ  M(W),

1

µt - µ, -g + Gt

= 

µt - µ, d(µt) - d(µt+1)

1 =


D(µ, µt) - D(µ, µt+1) + D(µt, µt+1)

.

(34)

By item 10 of Theorem 4, there exists a constant Ct such that d(µt+1) = d(µt) -  (-g + Gt) + Ct.
Using (16), we see that

(35)

D(µt, µt+1) = D (d(µt+1), d(µt))

= D d(µt+1) - Ct, d(µt)

Consequently, we have

1 8

d(µt+1) - Ct - d(µt)

2 L

2 =
8

-g + Gt

2 L



2M 2 .

8

by (18) by (35)

T

µt - µ, -g + Gt

=

T

1 

D(µ, µt) - D(µ, µt+1) + D(µt, µt+1)

t=1 t=1

 D(µ, µ1) + M 2T . 8

(36)

17

Under review as a conference paper at ICLR 2019

Exactly the same argument applied to t's yields, for any   M(),

T

t - , -Gµt

 D(, 1) + M 2T . 8

t=1

(37)

Summing up (36) and (37), substituting µ  µNE,   NE and dividing by T , we get

1T T
t=1

µt - µNE, -g + Gt + t - NE, -Gµt)



D0

+

M 2 .

T 4

(38)

The left-hand side of (38) can be simplified to

1T T
t=1

µt - µNE, -g + Gt + t - NE, -Gµt

1T =
T
t=1

µNE - µt, g - µNE, Gt + µt, GNE

= µNE, g - G¯T - µ¯T , g - GNE . (39)

By definition of the Nash Equilibrium, we have

which implies

µ¯T , g - GNE  µNE, g - GNE  µNE, g - G¯T , µ¯T , g - GNE  µ¯T , g - G¯T  µNE, g - G¯T ,

(40)

| µ¯T , g - G¯T - µNE, g - GNE |  µNE, g - G¯T - µ¯T , g - GNE . Combining (51)-(54), we conclude that

(41)

2 =
M

D0 T



| µ¯T , g - G¯T - µNE, g - GNE |  M

D0 . T

B.2 Mirror Descent, Stochastic Derivatives

We first write µt - µ, (-g^ + G^t) = µt - µ, (-g + Gt) + µt - µ,  - g^ + G^t + g - Gt .

Taking conditional expectation and using the unbiasedness of stochastic derivatives, we conclude that
E µt - µ, (-g^ + G^t) = µt - µ, (-g + Gt) .

Therefore, using exactly the same argument leading to (36), we may obtain

T
E

µt - µ, -g^ + G^t

 ED(µ, µ1) + M 2T . 8

t=1

The rest is the same as with deterministic derivatives.

C Proof of Convergence Rates for Infinite-Dimensional Mirror-Prox

We first need a technical lemma, which is Lemma 6.2 of (Juditsky & Nemirovski, 2011) tailored to our infinite-dimensional setting. We give a slightly different proof.
Lemma 5. Given any µ  M(Z) and h, h  F (Z), let µ = MD (µ~, h) and µ~+ = MD (µ~, h ). Let  be -strongly convex (recall that  = 4 when  is the entropy). Then, for any µ  M(Z), we have

µ - µ , h



D(µ

, µ~) - D(µ

, µ~+) +

2 2

h-h

2 L

-

 2

µ - µ~

2 TV

.

(42)

18

Under review as a conference paper at ICLR 2019

Proof. Recall from (15) that entropy is -strongly convex with respect to · TV. We first write

µ - µ , h = µ~+ - µ , h + µ - µ~+, h + µ - µ~+, (h - h) .

(43)

For the first term, (20) and (21) implies

µ~+ - µ , h = µ~+ - µ , d(µ~) - d(µ~+) = -D(µ~+, µ~) - D(µ , µ~+) + D(µ , µ~).

(44)

Similarly, the second term of the right-hand side of (43) can be written as

µ - µ~+, h = -D(µ, µ~) - D(µ~+, µ) + D(µ~+, µ~).

(45)

Ho¨lder's inequality for the third term gives

µ - µ~+, (h - h)  µ - µ~+ TV (h - h) L

 2

µ - µ~+

2 TV

+

1 2

(h

- h)

2 L

.

Finally, recall that  is -strongly convex, and hence we have

 - D(µ~+, µ)  - 2

µ - µ~+

2 TV

,

 -D(µ, µ~)  - 2

µ - µ~

2 TV

.

The lemma follows by combining inequalities (44)-(47) in (43).

(46) (47)

C.1 Mirror-Prox, Deterministic Derivatives

Let



=

4,

µ¯T

:=

1 T

T t=1

µt,

and

¯T

:=

1 T

T t=1

t.

In Lemma 5, substituting µ  µNE, µ~  µ~t, h  -g + G~t (so that µ = µt) and h  -g + Gt (so that µ~+ = µ~t+1), we get

µt - µNE, (-g + Gt) Similarly, we have



D(µNE,

µ~t)-D(µNE,

µ~t+1)+

2 2

G(t - ~t)

2 L

-

 2

µ~t - µt

2 TV

.

(48)

t - NE, -Gµt



D(NE,

~t)-D(NE,

~t+1)+

2 2

G(µt - µ~t)

2 L

-

 2

~t - t

2 TV

.

(49)

Since G(t - ~t) L  L · t - ~t TV and G(µt - µ~t) L  L · µt - µ~t TV, summing up (48) and (49) yields

µt - µNE, (-g + Gt) + t - NE, -Gµt)  D(µNE, µ~t) - D(µNE, µ~t+1) + D(NE, ~t) - D(NE, ~t+1)

+ 2L2 -  2 2

µ~t - µt

2 TV

+

~t - t

2 TV

 D(µNE, µ~t) - D(µNE, µ~t+1) + D(NE, ~t) - D(NE, ~t+1)

if





 L

=

4 L

.

Summing

up

the

last

inequality

over

t

and

using

D(·, ·)



0,

we

obtain

1T T
t=1

µt - µNE, (-g + Gt) + t - NE, -Gµt)

The left-hand side of (50) can be simplified to

 D(µNE, µ~1) + D(NE, ~1) = D0 . TT (50)

1T T
t=1

µt - µNE, (-g + Gt) +

t - NE, -Gµt)

)=

 T

T

t=1

µNE - µt, g - µNE, Gt + µt, GNE

=  µNE, g - G¯T - µ¯T , g - GNE . (51)

19

Under review as a conference paper at ICLR 2019

By definition of the (µNE, NE), we have

µ¯T , g - GNE  µNE, g - GNE  µNE, g - G¯T , µ¯T , g - GNE  µ¯T , g - G¯T  µNE, g - G¯T ,

which implies

| µ¯T , g - G¯T - µNE, g - GNE |  µNE, g - G¯T - µ¯T , g - GNE .

Combining (50)-(53), we conclude

 4 L



| µ¯T , g - G¯T

-

µNE, g - GNE

|  D0 . T

(52) (53)

C.2 Mirror-Prox, Stochastic Derivatives

Let  = 4, µ¯T :=

min  ,
3L

D0 6T 2

.

1 T

T t=1

µt,

and

¯T

:=

1 T

T t=1

t.

Set the step-size to  =

In Lemma 5, substituting µ  µNE, µ~  µ~t, h  -g^ + G^~t (so that µ = µt), and h  -g^ + G^t (so that µ~+ = µ~t+1), we get

µt - µNE, (-g^ + G^t)

2  D(µNE, µ~t)-D(µNE, µ~t+1)+ 2

G^t - G^~t

2 -
L 2

µ~t - µt

2 TV

.

(54)

Note that

E

G^t - G^~t 2  3
L

E

G^t - Gt

2
+E
L

Gt - G~t

2 L

+

E

G~t - G^~t 2
L

 62 + 3L2E

t - ~t

2 TV

.

Therefore, taking expectation conditioned on the history for both sides of (54), we get

µt - µNE, (-g + Gt)

322 32L2  ED(µNE, µ~t)-ED(µNE, µ~t+1)+  + 2 E

t - ~t

2TV-

 2

E

µ~t - µt

2 TV

.

Similarly, we have

t - NE, -Gµt



ED(NE,

~t)-ED(NE,

~t+1)+

322 

+

32L2 2

E

µt - µ~t

T2 V-

 2

E

~t - t

2 TV

.

Summing up the last two inequalities over t with    then yields
3L

1T T
t=1

µt - µNE, -g + Gt + t - NE, -Gµt)

 D0 + 62  max 2 T 

 62D0 , 2 3LD0
T T

by definition of . The rest is the same as with deterministic derivatives.

D Omitted Pseudocodes in the Main Text
We use the following notation for the hyperparameters of our algorithms: n : number of samples in the data batch. n : number of samples for each probability measure. t : SGLD step-size at iteration t. t : thermal noise of SGLD at iteration t.
Kt : warmup steps for SGLD at iteration t.  : exponential damping factor in the weighted average.
The approximate infinite-dimensional entropic MD and MP in Section 4.1 are depicted in Algorithm 4 and 5, respectively. Algorithm 6 gives the heuristic version of the entropic Mirror-Prox.

20

Under review as a conference paper at ICLR 2019

Algorithm 4: Approx Inf Mirror Decent

Input: W [1], [1]  n samples from random initialization,

{t}Tt=-11, { t}Tt=-11, {K}Tt=-11, n, n . for t = 1, 2, . . . , T - 1 do

C  ts=1W [s], D  st=1[s] ;

wt(1)  UNIF(W [t]), t(1)  UNIF([t]);

for k = 1, 2, . . . , Kt, . . . , Kt + n do

Generate t(k+1) =

A = {X1, . . .

t(k)

+

t nn



,

Xn} 
Xi A

Pt(k) ;
wC

fw (Xi )

+

 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

B  {} ;

for each   D do

Generate B~ = {X1, . . . , Xn}  P; B  B  B~;

wt(k+1)

=

wt(k)

+

tt n

w

fwt(k) (Xireal) -

t nn

w

fwt(k) (Xi) +

Xireal B

Xi B

2t tN (0, I);

W [t + 1]  wt(K+1), . . . , wt(K+n )
idx  UNIF(1, 2, . . . , T ); return W [idx], [idx].

,

[t + 1]  t(K+1), . . . , t(K+n ) ;

E Details and More Results of Experiments
This section contains all the details regarding our experiments, as well as more results on synthetic and real datasets.
Network Architectures: For all experiments, we consider the gradient-penalized discriminator (Gulrajani et al., 2017) as a soft constraint alternative to the original Wasserstein GANs, as it is known to achieve much better performance. The gradient penalty parameter is denoted by  below.
For synthetic data, we use fully connected networks for both the generator and discriminator. They consist of three layers, each of them containing 512 neurons, with ReLU as nonlinearity.
For MNIST, we use convolutional neural networks identical to (Gulrajani et al., 2017) as the generator and discriminator.5 The generator uses a sigmoid function to map the output to range [0, 1].
For LSUN bedroom, we use DCGAN (Radford et al., 2015), except that the number of the channels in each layer is half of the original model, and the last sigmoid function of the discriminator is removed. The output of the generator is mapped to [0, 1] by hyperbolic tangent and a linear transformation. The architecture contains batch normalization layer to ensure the stability of the training. For our Mirror- and Mirror-Prox-GAN, the Gaussian noise from SGLD is not added to parameters in batch normalization layers, as the batch normalization creates strong dependence among entries of the weight matrix and was not covered by our theory.
Hyperparameter setting: The hyperparameter setting is summarized in Table 1. For baselines (SGD, RMSProp, Adam), we use the settings identical to (Gulrajani et al., 2017). For our proposed Mirror- and Mirror-Prox-GAN, we set the damping factor  to be 0.9. For
5Their code is available on https://github.com/igul222/improved_wgan_training.
21

Under review as a conference paper at ICLR 2019

Algorithm 5: Approx Inf Mirror-Prox

Input: W~ [1], ~ [1]  n samples from random initialization,

{t}Tt=1, { t}Tt=1, {Kt}Tt=1, n, n . for t = 1, 2, . . . , T do

C  W~ [t]  ts-=11W [s] , D  ~ [t]  ts-=11[s] ;

wt(1)  UNIF(W~ [t]), t(1)  UNIF(~ [t]); for k = 1, 2, . . . , Kt, . . . , Kt + n do

Generate t(k+1) =

A = {X1, . . .

t(k)

+

t nn



,

Xn} 
Xi A

Pt(k) ;
wC

fw (Xi )

+

 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

B  {};

for each   D do

Generate B~ = {X1, . . . , Xn}  P; B  B  B~;

wt(k+1)

=

wt(k)

+

tt n

w

fwt(k) (Xireal) -

t nn

w

fwt(k) (Xi) +

Xireal B

Xi B

2t tN (0, I);

W [t]  wt(K+1), . . . , wt(K+n ) , [t]  t(K+1), . . . , t(K+n ) ;

C  st=1W [s], D  ts=1[s] ;

w~t(+1)1  UNIF(W~ [t]), ~t(+1)1  UNIF(~ [t]) ;

for k = 1, 2, . . . , Kt, . . . , Kt + n do

Generate A = {X1, . . . , Xn}  P~t(k) ;

~t(+k+1 1)

=

~t(+k)1

+

t nn



Xi A

wC

 fw(Xi) + 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

B  {};

for each   D do

Generate B~ = {X1, . . . , Xn}  P; B  B  B~;

w~t(+k+1 1)

=

w~ t(+k)1

+

tt n

w

fw~t(+k)1 (Xireal) -

t nn

w

fw~t(+k)1 (Xi ) +

Xireal B

Xi B

2t tN (0, I);

W~ [t + 1]  w~t(+K1+1), . . . , w~t(+K1+n )
idx  UNIF(1, 2, . . . , T ); return W [idx], [idx].

,

~ [t + 1]  ~t(+K1+1), . . . , ~t(+K1+n ) ;

Kt, t and t, we use the simple exponential scheduling:

Kt = (1 + 10-5)t . t =  × (1 - 10-5)t,
t = × (1 - 5 × 10-5)t,

 in Table 1. in Table 1.

The idea is that the initial iterations are very noisy, and hence it makes sense to take less
SGLD steps. As the iteration counts grow, the algorithms learn more meaningful parameters,
and we should increase the number of SGLD steps as well as decreasing the step-size t and thermal noise t to make the sampling more accurate. This is akin to the warmup steps in the sampling literature.

22

Under review as a conference paper at ICLR 2019

Algorithm 6: Mirror-Prox-GAN: Approximate Mirror-Prox for GANs

Input: w~1, ~1  random initialization, w0  w~1, 0  ~1, {t}Tt=1, { t}Tt=1, {Kt}Tt=1, . for t = 1, 2, . . . , T do

w¯t, w¯t+1, w~t(1), w~t(+1)1  w~t, ¯t, ¯t+1, ~t(1), ~t(+1)1  ~t;

for k = 1, 2, . . . , Kt do

Generate t(k+1) =

A = {X1, . .

t(k)

+

t n



.

,

Xn}  Pt(k) ; XiA fw~t (Xi)

+

 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

Generate B = {X1, . . . , Xn}  P~t ;

wt(k+1)

=

wt(k)

+

t n

w

fwt(k) (Xireal)

-

t n

w

fwt(k) (Xi) +

Xireal B

Xi B

w¯t  (1 - )w¯t + wt(k+1); ¯t  (1 - )¯t + t(k+1) ;
wt  (1 - )wt-1 + w¯t; t  (1 - )t-1 + ¯t;

2t tN (0, I);

for k = 1, 2, . . . , Kt do

Generate ~t(+k+1 1) =

A= ~t(+k)1

{X1, . . .

+

t n



,

Xn}  P ;~t(+k)1 XiA fwt (Xi)

+

 2t

tN (0, I);

Generate B = {X1real, . . . , Xnreal}  Preal;

Generate B = {X1, . . . , Xn}  Pt ;

wt(+k+1 1)

=

wt(+k)1

+

t n

w

fwt(+k)1 (Xireal)

-

t n

w

fwt(+k)1 (Xi ) +

Xireal B

Xi B

w¯t+1  (1 - )w¯t+1 + wt(+k+11); ¯t+1  (1 - )¯t+1 + t(+k+1 1) ;
w~t+1  (1 - )w~t + w¯t+1; ~t+1  (1 - )~t + ¯t+1;
return wT , T .

2t tN (0, I);

Algorithm Dataset Step-size  Gradient penalty  Noise Batch Size n

SGD SM
10-2 0.1
1024 50

RMSProp L
10-4 10
64

Adam SML
10-4 0.1 10
1024 50 64

Etropic MD/MP

SM 10-2

L 10-4

0.1 10 10-2 10-3 10-6

1024 50 64

Table 1: Hyperparameter setting. "S", "M", "L" stands for synthetic data, MNIST and LSUN bedroom, respectively. MD for LSUN bedroom uses a RMSProp preconditioner, so the stepsize is the same as one in RMSProp.

23

Under review as a conference paper at ICLR 2019

1.5 1.5

1.0 1.0

0.5 0.5

0.0 0.0

0.5 0.5

1.0 1.0

1.5 1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5

(a) SGD

(b) Adam

1.5 1.5

1.0 1.0

0.5 0.5

0.0 0.0

0.5 0.5

1.0 1.0

1.5 1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5

(c) Mirror-GAN

(d) Mirror-Prox-GAN

Figure 3: Fitting 8 Gaussian mixtures up to 105 iterations.

2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(a) SGD
2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.0 0.5 0.0 0.5 1.0 1.5
(c) Mirror-GAN

2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.0 0.5 0.0 0.5 1.0 1.5
(b) Adam
2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.0 0.5 0.0 0.5 1.0 1.5
(d) Mirror-Prox-GAN

Figure 4: Fitting the `Swiss Roll' up to 105 iterations.

24

Under review as a conference paper at ICLR 2019

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(a) SGD

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(b) Adam

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(c) Mirror-GAN

1.5

1.0

0.5

0.0

0.5

1.0

1.5 1.5

1.0 0.5 0.0 0.5 1.0
(d) Mirror-Prox-GAN

1.5

Figure 5: Fitting 25 Gaussian mixtures up to 105 iterations.

E.1 Synthetic Data
Figure 3, 4, and 5 show results on learning 8 Gaussian mixtures, 25 Gaussian mixtures, and the Swiss Roll. As in the case for 25 Gaussian mixtures, we find that Mirror- and MirrorProx-GAN can better capture the variance of the true distribution, as well as finding the unbiased modes.
In Figure 6, we plot the data generated after 104, 2 × 104, 5 × 104, 8 × 104, and 105 iterations by different algorithms fro 25 Gaussian mixtures. It is clear that Mirror- and Mirror-ProxGAN find the modes of the distribution faster. In practice, it was observed that the noise introduced by SGLD quickly drives the iterates to non-trivial parameter regions, whereas SGD tends to get stuck at very bad local minima. Adam, as an adaptive algorithm, is capable of escaping bad local minima, however at a rate slower than Mirror- and Mirror-Prox-GAN. The quality of Adam's final solution is also not as good as Mirror- and Mirror-Prox-GAN; see the discussions in Section 5.1.
E.2 Real Data
E.2.1 MNSIT
Results on MNIST dataset are shown in Figure 7. The models are trained by each algorithm for 105 iterations. We can see that all algorithms achieve comparable performance. Therefore, the dataset seems too weak to be a discriminator for different algorithms.

25

Under review as a conference paper at ICLR 2019

104 iterations
2 1 0 1 2
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
2.5 2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
1.5 1.0 0.5 0.0 0.5 1.0 1.5
2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
10 1 2

2 × 104 iterations
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
2.5 2.0 1.5 1.0 0.5 0.0 0.5 1.0 1.5
4 3 2 10 1
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5

5 × 104 iterations
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(a) SGD
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5 2.0
(b) Adam

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0
(c) Mirror-GAN

1.5

1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
(d) Mirror-Prox-GAN

8 × 104 iterations
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5

105 iterations
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5
1.5 1.0 0.5 0.0 0.5 1.0 1.5

Figure 6: Learning 25 Gaussian mixtures accross different iterations.

26

Under review as a conference paper at ICLR 2019

(a) True Data

(b) SGD

(c) Adam

(d) Mirror-GAN

(e) Mirror-Prox-GAN

Figure 7: True MNIST images and samples generated by different algorithms.

27

Under review as a conference paper at ICLR 2019

E.2.2 LSUN Bedroom
More results on the LSUN bedroom dataset are shown in Figure 8. We show images generated after 4×104, 8×104, and 105 iterations by each algorithm. We can see that the Mirror-GAN (with RMSProp-preconditioned SGLD) outperforms vanilla RMSProp. Adam was able to obtain meaningful images in early stages of training. However, further iterations do not improve the image quality of Adam. In contrast, they lead to severe mode collapse at the 8 × 104th iteration, and converge to noise later on.

4 × 104 iterations

8 × 104 iterations

105 iterations

(a) RMSProp

(b) Adam

(c) Mirror-GAN, Algorithm 3
Figure 8: Image generated by RMSProp, A2d8am and Mirror-GAN on the LSUN bedroom dataset.

