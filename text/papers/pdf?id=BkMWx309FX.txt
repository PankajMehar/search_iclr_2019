Under review as a conference paper at ICLR 2019
REINFORCEMENT LEARNING WITH PERTURBED RE-
WARDS
Anonymous authors Paper under double-blind review
ABSTRACT
Recent studies have shown the vulnerability of reinforcement learning (RL) models in noisy settings. The sources of noises differ across scenarios. For instance, in practice, the observed reward channel is often subject to noise (e.g., when observed rewards are collected through sensors), and thus observed rewards may not be credible as a result. Also, in applications such as robotics, a deep reinforcement learning (DRL) algorithm can be manipulated to produce arbitrary errors. In this paper, we consider noisy RL problems where observed rewards by RL agents are generated with a reward confusion matrix. We call such observed rewards as perturbed rewards. We develop an unbiased reward estimator aided robust RL framework that enables RL agents to learn in noisy environments while observing only perturbed rewards. Our framework draws upon approaches for supervised learning with noisy data. The core ideas of our solution include estimating a reward confusion matrix and defining a set of unbiased surrogate rewards. We prove the convergence and sample complexity of our approach. Extensive experiments on different DRL platforms show that policies based on our estimated surrogate reward can achieve higher expected rewards, and converge faster than existing baselines. For instance, the state-of-the-art PPO algorithm is able to obtain 67.5% and 46.7% improvements in average on five Atari games, when the error rates are 10% and 30% respectively.
1 INTRODUCTION
Designing a suitable reward function plays a critical role in building reinforcement learning models for real-world applications. Ideally, one would want to customize reward functions to achieve application-specific goals (Hadfield-Menell et al., 2017). In practice, however, it is difficult to design a function that produces credible rewards in the presence of noise. This is because the output from any reward function is subject to multiple kinds of randomness:
· Inherent Noise. For instance, sensors on a robot will be affected by physical conditions such as temperature and lighting, and therefore will report back noisy observed rewards.
· Application-Specific Noise. In machine teaching tasks (Thomaz et al., 2006), when an RL agent receives feedback/instructions from people, different human instructors might provide drastically different feedback due to their personal styles and capabilities. This way the RL agent (machine) will obtain reward with bias.
· Adversarial Noise. Adversarial perturbation has been widely explored in different learning tasks and shows strong attack power against different machine learning models. For instance, Huang et al. (2017) has shown that by adding adversarial perturbation to each frame of the game, they can mislead RL policies arbitrarily.
Assuming an arbitrary noise model makes solving this noisy RL problem extremely challenging. Instead, we focus on a specific noisy reward model which we call perturbed rewards, where the observed rewards by RL agents are generated according to a reward confusion matrix. This is not a very restrictive setting to start with, even considering that the noise could be adversarial: Given that arbitrary pixel value manipulation attack in RL is not very practical, adversaries in real-world have high incentives to inject adversarial perturbation to the reward value by slightly modifying it. For instance, adversaries can manipulate sensors via reversing the reward value.
1

Under review as a conference paper at ICLR 2019
In this paper, we develop an unbiased reward estimator aided reward robust reinforcement learning framework that enables an RL agent to learn in a noisy environment with observing only perturbed rewards. Our solution framework builds on existing reinforcement learning algorithms, including the recently developed DRL ones. The main challenge is that the observed rewards are likely to be biased, and in RL or DRL the accumulated errors could amplify the reward estimation error over time. We do not require any assumption on knowing the true distribution of reward or adversarial strategies, other than the fact that the generation of noises follow an unknown reward confusion matrix. Instead, we address the issue of estimating the reward confusion matrices by proposing an efficient and flexible estimation module. Everitt et al. (2017) provided preliminary studies for the noisy reward problem and gave some general negative results. The authors proved a No Free Lunch theorem, which is, without any assumption about what the reward corruption is, all agents can be misled. Our results do not contradict with the results therein, as we consider a specific noise generation model (that leads to a set of perturbed rewards). We analyze the convergence and sample complexity for the policy trained based on our proposed method using surrogate rewards in RL, using Q-Learning as an example.
We conduct extensive experiments on OpenAI Gym (Brockman et al., 2016) (AirRaid, Alien, Carnival, MsPacman, Pong, Phoenix, Seaquest), and test various RL and DRL algorithms including Q-Learning, CEM, SARSA, DQN, Dueling DQN, DDPG, NAF, and PPO. We show that the proposed reward robust RL method achieves comparable performance with the policy trained using the true rewards. In some cases, our method even achieves higher cumulative reward - this is surprising to us at first, but we conjecture that the inserted noise together with our noisy-removal unbiased estimator adds another layer of explorations, which proves to be beneficial in some settings. This merits a future study.
Our contributions are summarized as follows: (1) We adapt and generalize the idea of defining a simple but effective unbiased estimator for true rewards using observed and perturbed rewards to the reinforcement learning setting. The proposed estimator helps guarantee the convergence to the optimal policy even when the RL agents only have noisy observations of the rewards. (2) We analyze the convergence to the optimal policy and finite sample complexity of our reward robust RL methods, using Q-Learning as the running example. (3) Extensive experiments on OpenAI Gym show that our proposed algorithms perform robustly even at high noise rates.
1.1 RELATED WORK
Robust Reinforcement Learning It is known that RL algorithms are vulnerable to noisy environments (Irpan, 2018). Recent studies (Huang et al., 2017; Kos & Song, 2017; Lin et al., 2017) show that learned RL policies can be easily misled with small perturbations in observations. The presence of noise is very common in real-world environments, especially in robotics-relevant applications. Consequently, robust (adversarial) reinforcement learning (RRL/RARL) algorithms have been widely studied, aiming to train a robust policy which is capable of withstanding perturbed observations (Teh et al., 2017; Pinto et al., 2017; Gu et al., 2018) or transferring to unseen environments (Rajeswaran et al., 2016; Fu et al., 2017). However, these robust RL algorithms mainly focus on noisy vision observations, instead of the observed rewards.
Learning with Noisy Data Learning appropriately with biased data has received quite a bit of attention in recent machine learning studies Natarajan et al. (2013); Scott et al. (2013); Scott (2015); Sukhbaatar & Fergus (2014); van Rooyen & Williamson (2015); Menon et al. (2015). The idea of above line of works is to define unbiased surrogate loss function to recover the true loss using the knowledge of the noises. We adapt these approaches to reinforcement learning. Though intuitively the idea should apply in our RL settings, our work is the first one to formally establish this extension both theoretically and empirically. Our quantitative understandings will provide practical insights when implementing reinforcement learning algorithms in noisy environments.
2 PROBLEM FORMULATION AND PRELIMINARIES
In this section, we define our problem of learning from perturbed rewards in reinforcement learning. Throughout this paper, we will use perturbed reward and noisy reward interchangeably, as each shot of our sequential decision making setting is similar to the "learning with noisy data" setting in super-
2

Under review as a conference paper at ICLR 2019

vised learning (Natarajan et al., 2013; Scott et al., 2013; Scott, 2015; Sukhbaatar & Fergus, 2014). In what follow, we formulate our Markov Decision Process (MDP) problem and the reinforcement learning (RL) problem with perturbed (noisy) rewards.

2.1 REINFORCEMENT LEARNING: THE NOISE-FREE SETTING

Our RL agent interacts with an unknown environment and attempts to maximize the total of his

collected reward. The environment is formalized as a Markov Decision Process (MDP), denot-

ing as M = S, A, R, P,  . At each time t, the agent in state st  S takes an action at  A, which returns a reward r(st, at, st+1)  R (which we will also shorthand as rt), and leads to the next state st+1  S according to a transition probability kernel P, which encodes the probability P(st+1|st, at). Commonly P is unknown to the agent. The agent's goal is to learn the opti-
mal policy, a conditional distribution (a|s) that maximizes the state's value function. The value

function calculates the cumulative reward the agent is expected to receive given he would follow

the current policy  after observing the current state st: V (s) = E

 k=1

 k rt+k

|

st

=

s

,

where 0 <   1 is a discount factor. Intuitively, the agent evaluates how preferable each

state is given the current policy. From the Bellman Equation, the optimal value function is given

by V (s) = maxaA st+1S Pa(st, st+1) [rt + V (st+1)] . It is a standard practice for RL algorithms to learn a state-action value function, for example the Q-function. Q-function calculates

the expected cumulative reward if agent chooses a in the current state and follows  thereafter:

Q(s, a) = E [r(st, at, st+1) + V (st+1) | st = s, at = a] .

2.2 PERTURBED REWARD IN RL
In many practical settings, our RL agent does not observe the reward feedbacks perfectly. We consider the following MDP with perturbed reward, denoting as M~ = S, A, R, R~, P,  : instead of observing rt  R at each time t directly (following his action), our RL agent only observes a perturbed version of rt, denoting as r~t  R~. For most of our presentations, we focus on the cases where R, R~ are finite sets; but our results generalize to the continuous reward settings.
The generation of r~ follows a certain function C : S × R  R~. To let our presentation stay focused, we consider the following simple state-independent flipping error rates model: if the rewards are binary (consider +1 and -1 for simplicity), r~(st, at, st+1) (r~t) can be characterized by the following noise rate parameters e+, e-: e+ = P(r~(st, at, st+1) = -1|r(st, at, st+1) = +1), e- = P(r~(st, at, st+1) = +1|r(st, at, st+1) = -1) When the signal levels are beyond binary, suppose there are M outcomes in total, denoting as [R0, R1, · · · , RM-1]. r~t will be generated according to the following confusion matrix CM×M where each entry cj,k indicates the flipping probability for generating a perturbed outcome: cj,k = P(r~t = Rk|rt = Rj). Again we'd like to note that we focus on settings with finite reward levels for most of our paper, but we provide discussions in Section 3.1 on how to handle continuous rewards with discretizations.
In the paper, we do not assume knowing the noise rates (i.e., the reward confusion matrices), which is different from the assumption of knowing them as adopted in many supervised learning works Natarajan et al. (2013). Instead we will estimate the confusion matrices (Section 3.3).

3 LEARNING WITH PERTURBED REWARDS
In this section, we first introduce an unbiased estimator for binary rewards in our reinforcement learning setting when the error rates are known. This idea is inspired by Natarajan et al. (2013), but we will extend the method to the multi-outcome, as well as the continuous reward settings.
3.1 UNBIASED ESTIMATOR FOR TRUE REWARD
With the knowledge of noise rates (reward confusion matrices), we are able to establish an unbiased approximation of the true reward in a similar way as done in Natarajan et al. (2013). We will call such a constructed unbiased reward as a surrogate reward. To give an intuition, we start with replicating the results for binary reward R = {-1, +1} in our RL setting:

3

Under review as a conference paper at ICLR 2019

Lemma 1. Let r be bounded. Then, if we define,

r^(st, at, st+1)

:=

(1 - e-r~)r~(st, at, st+1) - er~ · (-r~(st, at, st+1)) 1 - e+ - e-

we have for any r(st, at, st+1), Er~|r[r^(st, at, st+1)] = r(st, at, st+1).

(1)

In the standard supervised learning setting, the above property guarantees convergence - as more training data are collected, the empirical surrogate risk converges to its expectation, which is the same as the expectation of the true risk (due to the unbiasedness property). This is also the intuition why we would like to replace the reward terms with surrogate rewards in our RL algorithms.

The above idea can be generalized to the multi-outcome setting in a fairly straight-forward way. Define R^ := [r^(r~ = R0), r^(r~ = R1), ..., r^(r~ = RM-1)], where r^(r~ = Rm) denotes the value of the surrogate reward when the observed reward is Rk. Let R = [R0; R1; · · · ; RM-1] be the bounded
reward matrix with M values. We have the following results:

Lemma 2. Suppose CM×M is invertible. With defining:

R^ = C-1 · R.

(2)

we have for any r(st, at, st+1), Er~|r[r^(st, at, st+1)] = r(st, at, st+1).

Continuous reward When the reward signal is continuous, we discretize it into M intervals and view each interval as a reward level, with its value approximated by its middle point. With increasing M , this quantization error can be made arbitrarily small. Our method is then the same as the solution for the multi-outcome setting, except for replacing rewards with discretized ones. Note that the finerdegree quantization we take, the smaller the quantization error - but we would suffer from learning a bigger reward confusion matrix. This is a trade-off question that can be addressed empirically.

So far we have assumed knowing the confusion matrices, but we will address this additional estimation issue in Section 3.3, and present our complete algorithm therein.

3.2 CONVERGENCE AND SAMPLE COMPLEXITY: Q-LEARNING

We now analyze the convergence and sample complexity of our surrogate reward based RL algorithms (with assuming knowing C), taking Q-Learning as an example.
Convergence guarantee First, the convergence guarantee is stated in the following theorem:
Theorem 1. Given a finite MDP, denoting as M^ = S, A, R^, P,  , the Q-learning algorithm with surrogate rewards, given by the update rule,

Qt+1(st, at) = (1 - t)Q(st, at) + t r^t +  max Q(st+1, b) , bA
converges w.p.1 to the optimal Q-function as long as t t =  and t t2 < .

(3)

Note that the term on the right hand of Eqn. (3) includes surrogate reward r^ estimated using Eqn. (1) and Eqn. (2). Theorem 1 states that that agents will converge to the optimal policy w.p.1 with replacing the rewards with surrogate rewards, despite of the noises in observing rewards. This result is not surprising - though the surrogate rewards introduce larger variance, we are grateful of their unbiasedness, which grants us the convergence.
Sample complexity To establish our sample complexity results, we firstly introduce a generative model following previous literature (Kearns & Singh, 1998; 2000; Kearns et al., 1999). This is a practical MDP setting to simplify the analysis.
Definition 1. A generative model G(M) for an MDP M is a sampling model which takes a stateaction pair (st, at) as input, and outputs the corresponding reward r(st, at) and the next state st+1 randomly with the probability of Pa(st, st+1), i.e., st+1  P(·|s, a).

Exact value iteration (using Q function) is impractical if the agents follow the generative models above exactly (Gatsby, 2003). Consequently, we introduce a phrased Q-Learning which is similar to the ones presented in Gatsby (2003); Kearns & Singh (1998) for the convenience of proving our sample complexity results. We briefly outline phrased Q-Learning as follows - the complete description (Algorithm 2) can be found in Appendix A.

4

Under review as a conference paper at ICLR 2019

Definition 2. Phased Q-Learning algorithm takes m samples per phase by calling generative model G(M). It uses collected m samples to estimate the transition probability P and update the estimated value function per phase. Calling generative model G(M^ ) means that surrogate rewards are
returned and used to update value function per phase.

The sample complexity of Phrased Q-Learning is given as follows:

Theorem 2. (Upper Bound) Let r  [0, Rmax] be bounded reward, C be an invertible reward confusion matrix with det(C) denoting its determinant. For an appropriate choice of m, the Phrased

Q-Learning algorithm calls the generative model G(M^ ) O

|S ||A|T 2 (1- )2 det(C)2

log

|S||A|T 

times, and

returns a policy such that for all state s  S, |V(s) - V (s)|  , w.p.  1 - , 0 <  < 1.

Theorem 2 states that, to guarantee the convergence to optimal policy, the number of samples needed

is no more than O(1/det(C)2) times of the one needed when the RL agent observes true rewards

perfectly. This additional constant is the price we pay for the noise presented in our learning envi-

ronment. When the noise level is high, we expect to see a much higher 1/det(C)2; otherwise when

we are in a low-noise regime , Q-Learning can be very efficient with surrogate reward (Kearns &

Singh, 2000). Note that Theorem 2 gives the upper bound in discounted MDP setting; for undis-

counted setting ( = 1), the upper bound is at the order of O

|S||A|T 3 2 det(C)2

log

|S ||A|T 

. Lower bound

result is omitted due to the lack of space. The idea of constructing MDP is similar to Gatsby (2003).

While the surrogate reward guarantees the unbiasedness, we sacrifice the variance at each of our learning steps, and this in turn delays the convergence (as also evidenced in the sample complexity bound). It can be verified that the variance of surrogate reward is bounded when C is invertible, and it is always higher than the variance of true reward. This is summarized in the following theorem:

Theorem 3. Let r  [0, Rmax] be bounded reward and confusion matrix C is invertible. Then, the

variance

of

surrogate

reward

r^ is

bounded

as

follows:

Var(r)



Var(r^)



M2 det(C)2

·

Rm2 ax.

To give an intuition of the bound, when we have binary reward, the variance for surrogate reward

bounds as follows:

Var(r)



Var(r^)



.4Rm2 ax
(1-e+ -e- )2

As

e-

+

e+



1, the variance becomes

unbounded and the proposed estimator is no longer effective, nor will it be well-defined. In practice,

there is a trade-off question between bias and variance by tuning a linear combination of R and R^ ,

i.e., Rproxy = R + (1 - )R^ , and choosing an appropriate   [0, 1].

3.3 ESTIMATION OF CONFUSION MATRICES

In Section 3.1 we have assumed the knowledge of reward confusion matrices, in order to compute the surrogate reward. This knowledge is often not available in practice. Estimating these confusion matrices is challenging without knowing any ground truth reward information; but we'd like to note that efficient algorithms have been developed to estimate the confusion matrices in supervised learning settings (Liu & Liu, 2015; Bekker & Goldberger, 2016; Khetan et al., 2017; Hendrycks et al., 2018). The idea in these algorithms is to dynamically refine the error rates based on aggregated rewards. Note this approach is not different from the inference methods in aggregating crowdsourcing labels, as referred in the literature (Dawid & Skene, 1979; Karger et al., 2011; Liu et al., 2012). We adapt this idea to our reinforcement learning setting, which is detailed as follows.

At each training step, the RL agent collects the noisy reward and the current state-action pair. Then, for each pair in S × A, the agent predicts the true reward based on accumulated historical observa-
tions of reward for the corresponding state-action pair via, e.g., averaging (majority voting). Finally,
with the predicted true reward and the accuracy (error rate) for each state-action pair, the estimated reward confusion matrices C~ are given by

c~i,j

=

(s,a)S×A

# [r~(s, a) = Rj|r¯(s, a) #[r¯(s, a) = Ri]

=

Ri] ,

(4)

where in above # [·] denotes the number of state-action pair, which satisfies the condition [·] in the set of observed rewards R~(s, a) (see Algorithm 1 and 3); r¯(s, a) and r~(s, a) denote predicted true rewards (using majority voting) and observed rewards when the state-action pair is (s, a). The above
procedure continues with more observations arriving.

5

Under review as a conference paper at ICLR 2019

Our final definition of surrogate reward is nothing different from Eqn. (2) but with replacing a known reward confusion matrix C with our estimated one C~ in the definition of r^. We denote this reward as r.
We present (Reward Robust RL) in Algorithm 11. Note that the Algorithm is rather generic, and we can plug in any exisitng RL algorithm into our reward robust one, with only changes in replacing the rewards with our estimated surrogate rewards.

Algorithm 1 Reward Robust RL (sketch)
Input: M~ , , , R~(s, a) Output: Q(s), (s, t)
Initialize value function Q(s, a) arbitrarily. while Q is not converged do
Initialize state s  S while s is not terminal do
Choose a from s using policy derived from Q Take action a, observe s and noisy reward r~ if collecting enough r~ for every S × A pair then
Get predicted true reward r¯ using majority voting Estimate confusion matrix C~ based on r~ and r¯ (Eqn. 4) Obtain surrogate reward r (R^ = (1 - ) · R +  · C-1R) Update Q using surrogate reward ss return Q(s) and (s)

4 EXPERIMENTS

In this section, reward robust RL is tested in different games, with different noise settings. Due to space limit, more experimental results can be found in Appendix D.

4.1 EXPERIMENTAL SETUP
Environments and RL Algorithms To fully test the performance under different environments, we evaluate the proposed robust reward RL method on two classic control games (CartPole, Pendulum) and seven Atari 2600 games (AirRaid, Alien, Carnival, MsPacman, Pong, Phoenix, Seaquest), which encompass a large variety of environments, as well as rewards. Specifically, the rewards could be unary (CartPole), binary (most of Atari games), multivariate (Pong) and even continuous (Pendulum). A set of state-of-the-art reinforcement learning algorithms are experimented with while training under different amounts of noise (See Table 3)2. For each game and algorithm, three policies are trained based on different random initialization to decrease the variance.

Reward Post-Processing For each game and RL algorithm, we test the performances for learning with true rewards, learning with noisy rewards and learning with surrogate rewards. Both symmetric and asymmetric noise settings with different noise levels are tested. For symmetric noise, the confusion matrices are symmetric. As for asymmetric noise, two types of random noise are tested: 1) rand-one, each reward level can only be perturbed into another reward; 2) rand-all, each reward could be perturbed to any other reward, via adding a random noise matrix. To measure the amount of noise w.r.t confusion matrices, we define the weight of noise  in Appendix B.2. The larger  is, the higher the noise rates are.

4.2 ROBUSTNESS EVALUATION
CartPole The goal in CartPole is to prevent the pole from falling by controlling the cart's direction and velocity. The reward is +1 for every step taken, including the termination step. When the cart or pole deviates too much or the episode length is longer than 200, the episode terminates. Due to the unary reward {+1} in CartPole, a corrupted reward -1 is added as the unexpected error (e- = 0). As a result, the reward space R is extended to {+1, -1}. Five algorithms Q-Learning (1992), CEM (2006), SARSA (1998), DQN (2016) and DDQN (2016) are evaluated.
In Figure 1, we show that our estimator successfully produces meaningful surrogate rewards that adapt the underlying RL algorithms to the noisy settings, without any assumption of the true distribution of rewards. With the noise rate increasing (from 0.1 to 0.9), the models with noisy rewards converge slower due to larger biases. However, we observe that the models always converge to the best score 200 with the help of surrogate rewards.
1One complete Q-Learning implementation (Algorithm 3) is provided in Appendix C. 2The detailed settings are accessible in Appendix B.

6

Under review as a conference paper at ICLR 2019

 = 0.3

 = 0.7

(a) Q-Learning

(b) CEM

(c) SARSA

(d) DQN

(e) DDQN

Figure 1: Learning curves from five RL algorithms on CartPole game with true rewards (r) , noisy rewards (r~) and estimated surrogate rewards (r) ( = 1) . Note that reward confusion matrices C are unknown to the agents here. Full results are in Appendix D.2 (Figure 4).

In some circumstances (slight noise - see Figure 4a, 4b, 4c, 4d), the surrogate rewards even lead to faster convergence. This points out an interesting observation: learning with surrogate reward even outperforms the case with observing the true reward. We conjecture that the way of adding noise and then removing the bias introduces implicit exploration. This implies that for settings even with true reward, we might consider manually adding noise and then remove it in expectation.
Pendulum The goal in Pendulum is to keep a frictionless pendulum standing up. Different from the CartPole setting, the rewards in pendulum are continuous: r  (-16.28, 0.0]. The closer the reward is to zero, the better performance the model achieves. Following our extension (see Section 3.1), the (-17, 0] is firstly discretized into 17 intervals: (-17, -16], (-16, -15], · · · , (-1, 0], with its value approximated using its maximum point. After the quantization step, the surrogate rewards can be estimated using multi-outcome extensions presented in Section 3.1.

 = 0.3

 = 0.7

(a) DDPG (symmetric) (b) DDPG (rand-one) (c) DDPG (rand-all)

(d) NAF (rand-all)

Figure 2: Learning curves from DDPG and NAF on Pendulum game with true rewards (r) , noisy rewards (r~) and surrogate rewards (r^) ( = 1) . Both symmetric and asymmetric noise are conduced in the experiments. Full results are in Appendix D.2 (Figure 7).
Table 1: Average scores of various RL algorithms on CartPole and Pendulum with noisy rewards (r~) and surrogate rewards under known (r^) or estimated (r) noise rates. Note that the results for last two algorithms DDPG (rand-one) & NAF (rand-all) are on Pendulum, but the others are on CartPole.

Noise Rate  = 0.1
 = 0.3

Reward
r~ r^ r
r~ r^ r

Q-Learn
170.0 165.8 181.9
134.9 149.3 161.1

CEM
98.1 108.9 99.3
28.8 85.9 81.8

SARSA
165.2 173.6 171.5
144.4 152.4 159.6

DQN
187.2 200.0 200.0
173.4 175.3 186.7

DDQN
187.8 181.4 185.6
168.6 198.7 200.0

DDPG
-1.03 -0.87 -0.90
-1.23 -1.03 -1.05

NAF
-4.48 -0.89 -1.13
-4.52 -1.15 -1.36

7

Under review as a conference paper at ICLR 2019
We experiment two popular algorithms, DDPG (2015) and NAF (2016) in this game. In Figure 2, both algorithms perform well with surrogate rewards under different amounts of noise. In most cases, the biases were corrected in the long-term, even when the amount of noise is extensive (e.g.,  = 0.7). The quantitative scores on CartPole and Pendulum are given in Table 1, where the scores are averaged based on the last thirty episodes. The full results ( > 0.5) can be found in Appendix D.1, so does Table 2. Our reward robust RL method is able to achieve consistently good scores. Atari We validate our algorithm on seven Atari 2600 games using the state-of-the-art algorithm PPO (Schulman et al., 2017). The games are chosen to cover a variety of environments. The rewards in the Atari games are clipped into {-1, 0, 1}. We leave the detailed settings to Appendix B.

Figure 3: Learning curves from PPO on Pong-v4 game with true rewards (r) , noisy rewards (r~) and surrogate rewards ( = 1) (r^) . The noise rates increase from 0.1 to 0.9, with a step of 0.1.
Results for PPO on Pong-v4 in symmetric noise setting are presented in Figure 3. Due to limited space, more results on other Atari games and noise settings are given in Appendix D.3. Similar to previous results, our surrogate estimator performs consistently well and helps PPO converge to the optimal policy. Table 2 shows the average scores of PPO on five selected Atari games with different amounts of noise (symmetric & asymmetric). In particular, when the noise rates e+ = e- > 0.3, agents with surrogate rewards obtain significant amounts of improvements in average scores. We do not present the results for the case with unknown C because the state-space (image-input) is very large for Atari games, which is difficult to handle with the solution given in Section 3.3.
Table 2: Average scores of PPO on five selected games with noisy rewards (r~) and surrogate rewards (r^). The experiments are repeated three times with different random seeds.

Noise Rate e- = e+ = 0.1 e- = 0.1, e+ = 0.3 e- = e+ = 0.3

Reward
r~ r^
r~ r^
r~ r^

Lift ()
67.5%
20.3%
46.7%

Mean
2044.2 3423.1
770.5 926.6
1180.1 1730.8

Alien
1814.8 1741.0
893.3 973.7
543.1 1637.7

Carnival
1239.2 3630.3
841.8 955.2
919.8 966.1

Phoenix
4608.9 7586.3
250.7 643.9
2600.3 4171.5

MsPacman
1709.1 2547.3
1151.1 1307.1
1109.6 1470.2

Seaquest
849.2 1610.6
715.7 753.1
727.8 408.6

5 CONCLUSION
Only an underwhelming amount of reinforcement learning studies have focused on the settings with perturbed and noisy rewards, despite of the fact that such noises are common when exploring a real-world scenario, that faces sensor errors or adversarial examples. We adapt the ideas from supervised learning with noisy examples (Natarajan et al., 2013), and propose a simple but effective RL framework for dealing with noisy rewards. The convergence guarantee and finite sample complexity of Q-Learning with estimated surrogate rewards are given. To validate the effectiveness of our approach, extensive experiments are conducted on OpenAI Gym, showing that surrogate rewards successfully rescue models from misleading rewards even at high noise rates.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Alan Joseph Bekker and Jacob Goldberger. Training deep neural-networks based on unreliable labels. In ICASSP, pp. 2682­2686. IEEE, 2016.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and Wojciech Zaremba. Openai gym, 2016.
Alexander Philip Dawid and Allan M Skene. Maximum likelihood estimation of observer error-rates using the em algorithm. Applied statistics, pp. 20­28, 1979.
Prafulla Dhariwal, Christopher Hesse, Oleg Klimov, Alex Nichol, Matthias Plappert, Alec Radford, John Schulman, Szymon Sidor, and Yuhuai Wu. Openai baselines. https://github.com/ openai/baselines, 2017.
Tom Everitt, Victoria Krakovna, Laurent Orseau, and Shane Legg. Reinforcement learning with a corrupted reward channel. In IJCAI, pp. 4705­4713. ijcai.org, 2017.
Justin Fu, Katie Luo, and Sergey Levine. Learning robust rewards with adversarial inverse reinforcement learning. CoRR, abs/1710.11248, 2017.
Machandranath Kakade Gatsby. On the sample complexity of reinforcement learning sham. 2003.
Shixiang Gu, Timothy P. Lillicrap, Ilya Sutskever, and Sergey Levine. Continuous deep q-learning with model-based acceleration. In ICML, volume 48 of JMLR Workshop and Conference Proceedings, pp. 2829­2838. JMLR.org, 2016.
Zhaoyuan Gu, Zhenzhong Jia, and Howie Choset. Adversary a3c for robust reinforcement learning, 2018. URL https://openreview.net/forum?id=SJvrXqvaZ.
Dylan Hadfield-Menell, Smitha Milli, Pieter Abbeel, Stuart J Russell, and Anca Dragan. Inverse reward design. In Advances in Neural Information Processing Systems, pp. 6765­6774, 2017.
Dan Hendrycks, Mantas Mazeika, Duncan Wilson, and Kevin Gimpel. Using trusted data to train deep networks on labels corrupted by severe noise. CoRR, abs/1802.05300, 2018.
Sandy Huang, Nicolas Papernot, Ian Goodfellow, Yan Duan, and Pieter Abbeel. Adversarial attacks on neural network policies. arXiv preprint arXiv:1702.02284, 2017.
Alex Irpan. Deep reinforcement learning doesn't work yet. https://www.alexirpan.com/ 2018/02/14/rl-hard.html, 2018.
Tommi S. Jaakkola, Michael I. Jordan, and Satinder P. Singh. Convergence of stochastic iterative dynamic programming algorithms. In NIPS, pp. 703­710. Morgan Kaufmann, 1993.
David R Karger, Sewoong Oh, and Devavrat Shah. Iterative learning for reliable crowdsourcing systems. In Advances in neural information processing systems, pp. 1953­1961, 2011.
Michael J. Kearns and Satinder P. Singh. Finite-sample convergence rates for q-learning and indirect algorithms. In NIPS, pp. 996­1002. The MIT Press, 1998.
Michael J. Kearns and Satinder P. Singh. Bias-variance error bounds for temporal difference updates. In COLT, pp. 142­147. Morgan Kaufmann, 2000.
Michael J. Kearns, Yishay Mansour, and Andrew Y. Ng. A sparse sampling algorithm for nearoptimal planning in large markov decision processes. In IJCAI, pp. 1324­1231. Morgan Kaufmann, 1999.
Ashish Khetan, Zachary C. Lipton, and Anima Anandkumar. Learning from noisy singly-labeled data. CoRR, abs/1712.04577, 2017.
Jernej Kos and Dawn Song. Delving into adversarial attacks on deep policies. CoRR, abs/1705.06452, 2017.
9

Under review as a conference paper at ICLR 2019
Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. CoRR, abs/1509.02971, 2015.
Yen-Chen Lin, Zhang-Wei Hong, Yuan-Hong Liao, Meng-Li Shih, Ming-Yu Liu, and Min Sun. Tactics of adversarial attack on deep reinforcement learning agents. In IJCAI, pp. 3756­3762. ijcai.org, 2017.
Qiang Liu, Jian Peng, and Alexander T Ihler. Variational inference for crowdsourcing. In Proc. of NIPS, 2012.
Yang Liu and Mingyan Liu. An online learning approach to improving the quality of crowdsourcing. In Proceedings of the 2015 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, SIGMETRICS '15, pp. 217­230, New York, NY, USA, 2015. ACM. ISBN 978-1-4503-3486-0. doi: 10.1145/2745844.2745874. URL http://doi.acm.org/10.1145/2745844.2745874.
Aditya Menon, Brendan Van Rooyen, Cheng Soon Ong, and Bob Williamson. Learning from corrupted binary labels via class-probability estimation. In International Conference on Machine Learning, pp. 125­134, 2015.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin A. Riedmiller. Playing atari with deep reinforcement learning. CoRR, abs/1312.5602, 2013.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529, 2015.
Nagarajan Natarajan, Inderjit S Dhillon, Pradeep K Ravikumar, and Ambuj Tewari. Learning with noisy labels. In Advances in neural information processing systems, pp. 1196­1204, 2013.
Lerrel Pinto, James Davidson, Rahul Sukthankar, and Abhinav Gupta. Robust adversarial reinforcement learning. In ICML, volume 70 of Proceedings of Machine Learning Research, pp. 2817­2826. PMLR, 2017.
Matthias Plappert. keras-rl. https://github.com/keras-rl/keras-rl, 2016.
Aravind Rajeswaran, Sarvjeet Ghotra, Sergey Levine, and Balaraman Ravindran. Epopt: Learning robust neural network policies using model ensembles. CoRR, abs/1610.01283, 2016.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. CoRR, abs/1707.06347, 2017.
Clayton Scott. A rate of convergence for mixture proportion estimation, with application to learning from noisy labels. In AISTATS, 2015.
Clayton Scott, Gilles Blanchard, Gregory Handy, Sara Pozzi, and Marek Flaska. Classification with asymmetric label noise: Consistency and maximal denoising. In COLT, pp. 489­511, 2013.
Sainbayar Sukhbaatar and Rob Fergus. Learning from noisy labels with deep neural networks. arXiv preprint arXiv:1406.2080, 2(3):4, 2014.
Richard S. Sutton and Andrew G. Barto. Reinforcement learning - an introduction. Adaptive computation and machine learning. MIT Press, 1998.
Istvan Szita and Andra´s Lo¨rincz. Learning tetris using the noisy cross-entropy method. Neural Computation, 18(12):2936­2941, 2006.
Yee Whye Teh, Victor Bapst, Wojciech M. Czarnecki, John Quan, James Kirkpatrick, Raia Hadsell, Nicolas Heess, and Razvan Pascanu. Distral: Robust multitask reinforcement learning. In NIPS, pp. 4499­4509, 2017.
Andrea Lockerd Thomaz, Cynthia Breazeal, et al. Reinforcement learning with human teachers: Evidence of feedback and guidance with implications for learning performance. 2006.
10

Under review as a conference paper at ICLR 2019 John N. Tsitsiklis. Asynchronous stochastic approximation and q-learning. Machine Learning, 16
(3):185­202, 1994. Hado van Hasselt, Arthur Guez, and David Silver. Deep reinforcement learning with double q-
learning. In AAAI, pp. 2094­2100. AAAI Press, 2016. Brendan van Rooyen and Robert C Williamson. Learning in the presence of corruption. arXiv
preprint arXiv:1504.00091, 2015. Ziyu Wang, Tom Schaul, Matteo Hessel, Hado van Hasselt, Marc Lanctot, and Nando de Freitas.
Dueling network architectures for deep reinforcement learning. In ICML, volume 48 of JMLR Workshop and Conference Proceedings, pp. 1995­2003. JMLR.org, 2016. Christopher J. C. H. Watkins and Peter Dayan. Q-learning. In Machine Learning, pp. 279­292, 1992. Christopher John Cornish Hellaby Watkins. Learning from Delayed Rewards. PhD thesis, King's College, Cambridge, UK, May 1989.
11

Under review as a conference paper at ICLR 2019

A PROOFS

Proof of Lemma 1. It is easy to validate the unbiasedness of proposed estimator directly. To get an intuitive understanding of how we derive the proposed method, rewrite Eqn. (1) as follows:

(1 - e-)r^- + e-r^+ = r- (1 - e+)r^+ + e+r^- = r+

where r-, r+ are the binary levels of true rewards; r^- and r^+ denote the value of the surrogate reward when the observed reward is r- and r+. Solving the equations above, we could obtain the surrogate binary rewards:



 

r^-



=

(1 - e+)r- - e-r+ 1 - e- - e+

  

r^+

=

(1 - e-)r+ - e+r- 1 - e- - e+

Or written in another way:

r^ = (1 - e-r~)r~ - er~ · (-r~) 1 - e+ - e-

Proof of Lemma 2. The idea of constructing unbiased estimator is easily adapted to multi-outcome
reward settings via writing out the conditions for the unbiasedness property (s.t. Er~|r[r^] = r.). For simplicity, we shorthand r^(r~ = Ri) as R^i in the following proofs. Similar to Lemma 1, we need to solve the following set of functions to obtain r^:

 R0 = c0,0 · R^0 + c0,1 · R^1 + · · · + c0,M-1 · R^M-1



  

R1 = c1,0 · R^0 + c1,1 · R^1 + · · · + c1,M-1 · R^M-1

 ···



 

RM -1

=

cM -1,0

·

R^0

+

cM -1,1

·

R^1

+

·

·

·

+

cM -1,M -1

·

R^ M -1

where R^i denotes the value of the surrogate reward when the observed reward is Ri. Define R := [R0; R1; · · · ; RM-1], and R^ := [R^0, R^1, ..., R^M-1], then the above equations are equivalent to:
R = C · R^ . If the confusion matrix C is invertible, we obtain the surrogate reward:

R^ = C-1 · R.

Furthermore, the probabilities for observing surrogate rewards can be written as follows:



P^ = [p^1, p^2, · · · , p^M ] =  pjcj,1, pjcj,2, · · · , pjcj,M  ,

jj

j

where p^i = j pjcj,i, and p^i, pi represent the probabilities of occurrence for surrogate reward R^i and true reward Ri respectively.

Corollary 1. Let p^i and pi denote the probabilities of occurrence for surrogate reward r^(r~ = Ri) and true reward Ri. Then the surrogate reward satisfies,

Pa(s, st+1)r(st, a, st+1) = pj Rj = p^j R^j .

s S

jj

(5)

Proof of Corollary 1. From Lemma 2, we have,

Pa(st, st+1)r(st, a, st+1) =

Pa(st, st+1, Rj )Rj

st S

st+1S;Rj R

=

Pa(st, st+1)Rj =

pj Rj = pj Rj .

Rj R st+1S

Rj R

j

12

Under review as a conference paper at ICLR 2019

Consequently,

p^jR^j =

pkck,j R^j = pk ck,j R^j

j jk

kj

= pkRk =

Pa(st, st+1)r(st, a, st+1).

k stS

To establish Theorem 1, we need an auxiliary result (Lemma 3) from stochastic process approximation, which is widely adopted for the convergence proof for Q-Learning (Jaakkola et al., 1993; Tsitsiklis, 1994). Lemma 3. The random process {t} taking values in Rn and defined as
t+1(x) = (1 - )t(x) + Ft(x)
converges to zero w.p.1 under the following assumptions:
· 0    1, t  =  and t 2 < ; · ||E [Ft(x)|Ft] ||W  ||t||, with  < 1;
· var [Ft(x)|Ft]  C(1 + ||t||W2 ), for C > 0.

Proof of Lemma 3. See previous literature (Jaakkola et al., 1993; Tsitsiklis, 1994).

Proof of Theorem 1. For the simplicity of notations, we abbreviate st, st+1, Qt, Qt+1, rt, r^t and t as s, s , Q, Q , r, r^, and , respectively.
Subtracting from both sides the quantity Q(s, a) in Eqn. (3):

Q (s, a) - Q(s, a) = (1 - ) (Q(s, a) - Q(s, a)) +  r^ +  max Q(s , b) - Q(s, a) .
bA
Let t(s, a) = Q(s, a) - Q(s, a) and Ft(s, a) = r^ +  maxbA Q(s , b) - Q(s, a). t+1(s , a) = (1 - )t(s, a) + Ft(s, a).
In consequence,

E [Ft(x)|Ft] =

P (s, s , r^) r^ +  max Q(s , b) - Q(s, a)

bA

s S;r^R

= P (s, s , r^)r^ + P(s, s )  max Q(s , b) - r -  max Q(s , b)

bA

bA

s S;r^R

s S

= P (s, s , r^)r^ - P(s, s )r + P(s, s ) max Q(s , b) - max Q(s , b)

bA

bA

s S;r^R

s S

s S

= p^jr^j - P(s, s )r + P(s, s ) max Q(s , b) - max Q(s , b)

bA

bA

j s S

s S

= P(s, s ) max Q(s , b) - max Q(s , b)

bA

bA

s S

(using Eqn. (5))

  P(s, s ) max |Q(s , b) - Q(s , b)|
bA s S

=  P(s, s )||Q - Q|| = ||Q - Q|| = ||t||.

s S

13

Under review as a conference paper at ICLR 2019

Finally,

 

2

Var

[Ft(x)|Ft]

=

E

r^ 

+



max
bA

Q(s

,

b)

-

P (s, s , r^)

r^ +  max Q(s , b)

 

bA



s S;r^R

= Var r^ +  max Q(s , b)|Ft
bA
.
Because r^ is bounded, it can be easily verified that Var [Ft(x)|Ft]  C(1 + ||t||W2 )
for some constant C. Then, due to the Lemma 3, t converges to zero w.p.1, i.e., Q (s, a) converges to Q(s, a).

The procedure of Phrased Q-Learning is described as Algorithm 2:

Algorithm 2 Phrased Q-Learning
Input: G(M): generative model of M = (S, A, R, P, ), T : number of iterations. Output: V^ (s): value function, ^(s, t): policy function. 1: Set V^T (s) = 0 2: for t = T - 1, · · · , 0 do
1. Calling G(M) m times for each state-action pair.

2. Set

P^a(st, st+1)

=

#[(st, at)  m

st+1]

V^ (s) = max

P^a(st, st+1) rt + V^ (st+1)

aA

st+1 S

^(s, t) = arg max V^ (s)

aA

3: return V^ (s) and ^(s, t)

Note that P^ here is the estimated transition probability, which is different from P in Eqn. (5).
To obtain the sample complexity results, the range of our surrogate reward needs to be known. Assuming reward r is bounded in [0, Rmax], Lemma 4 below states that the surrogate reward is also bounded, when the confusion matrices are invertible:
Lemma 4. Let r  [0, Rmax] be bounded, where Rmax is a constant; suppose CM×M , the confusion matrix, is invertible with its determinant denoting as det(C). Then the surrogate reward satisfies

0



|r^|



M det(C) Rmax.

(6)

Proof of Lemma 4. From Eqn. (2), we have,
R^ = C-1 · R = adj(C) · R, det(C)
where adj(C) is the adjugate matrix of C; det(C) is the determinant of C. It is known from linear algebra that,
adj(C)ij = (-1)i+j · Mji,

14

Under review as a conference paper at ICLR 2019

where Mji is the determinant of the (M - 1) × (M - 1) matrix that results from deleting row j and column i of C. Therefore, Mji is also bounded:

Mji 

|sgn()| cm,n

Sn

m=1

M -1

m=0

M -1
cm,n
n=0

= 1M = 1,

where the sum is computed over all permutations  of the set {0, 1, · · · , M - 2}; c is the element
of Mji; sgn() returns a value that is +1 whenever the reordering given by  can be achieved by successively interchanging two entries an even number of times, and -1 whenever it can not.

Consequently,

R^i =

j

|adj(C)ij | det(C)

·

|Rj |



M det(C)

·

Rmax.

Proof of Theorem 2. From Hoeffding's inequality, we easily obtain:



P

Pa(st, st+1)Vt+1(st+1) -

P^a(st, st+1)Vt+1(st+1)  

st+1 S

st+1 S

 2 exp

-2m 2(1 - )2 Rm2 ax

,

because Vt(st) is bounded within

.Rmax
1-

In the same way, r^t

is bounded by

M det(C)

· Rmax from

Lemma 4. We then have,



P

 

Pa(st, st+1, r^t)r^t -

P^a(st, st+1, r^t)r^t



 



2

exp



st+1 S

st+1 S

r^t R^

r^t R^

-2m 2det(C)2 M 2Rm2 ax

.

Further, due to the unbiasedness of surrogate rewards, we have

Pa(st, st+1)rt =

Pa(st, st+1, r^t)r^t.

st+1 S

st+1 S ;r^t R^

As a result,

Vt(s) - V^t(s)

= max
aA

Pa(st, st+1) rt + Vt+1(st+1)

st+1 S

- max
aA

P^a(st, st+1) r^t + Vt+1(st+1)

st+1 S



1

+



max
aA

Pa(st, st+1)Vt+1(st+1) -

P^a(st, st+1)Vt+1(st+1)

st+1 S

st+1 S

+ max

Pa(st, st+1)rt -

Pa(st, st+1, r^t)r^t

aA

st+1 S

st+1 S ;r^t R^

  max
sS

Vt+1(s) - V^t+1(s)

+

1+

2

In the same way,

Vt(s) - V^t(s)

  max
sS

Vt+1(s) - V^t+1(s)

+

1+

2

15

Under review as a conference paper at ICLR 2019

Recursing the two equations in two directions (0  T ), we get

max V (s) - V^ (s)  ( 1 +  2) + ( 1 +  2) + · · · + T -1( 1 +  2)
sS

=

(

1

+

 2)(1 - 1-

T )

max V (s) - V^ (s)  ( 1 +  2)(1 - T ) sS 1 - 

Combining these two inequalities above we have:

max |V (s) -
sS

V

(s)|



( 2

1

+  2)(1 - 1-

T )



( 2

1+ 1-

2

)

.

Let 1 = 2, so maxsS |V (s) - V (s)|  as long as

1=

2



(1 - ) .
2(1 + )

For arbitrarily small

, by choosing m appropriately, there always exists

1=

2

=

(1-) 2(1+)

such

that

the policy error is bounded within . That is to say, the Phrased Q-Learning could converge to near

optimal policy within finite steps using our proposed surrogate rewards.

Finally, there are |S||A|T transitions under which these conditions must hold, where |·| represent the

number of elements in a specific set. Using union bound, the probability of failure in any condition

is smaller than

2|S||A|T · exp

-m

2(1 - )2 2(1 + )2

·

min{(1

-

)2,

|C2| M2

}

.

We set the error rate less than , and m should satisfy that

1 |S||A|T m = O 2(1 - )2det(C)2 log 

In consequence, after m|S||A|T calls, which is, O

|S ||A|T 2 (1- )2 det(C)2

log

|S ||A|T 

, the value function

converges to the optimal one for every state s, with probability greater than 1 - .

The above bound is for discounted MDP setting with 0 <  < 1. For undiscounted setting  = 1, since the total error (for entire trajectory of T time-steps) has to be bounded by , therefore, the error for each time step has to be bounded by T . Repeating our anayslis, we obtain the following upper bound:
|S||A|T 3 |S||A|T O 2det(C)2 log 

Proof of Theorem 3.

Var(r^) - Var(r) = E (r^ - E[r^])2 - E (r - E[r])2

= E[r^2] - E[r^]2 + E[r2] - E[r]2

 2 

 2

=

p^j R^j 2 - 

p^j R^j 

- 

pj Rj 2 - 

pj Rj 

 

jj

jj

= p^j R^j 2 - pj Rj 2 =

pici,j R^j 2 -

pj

j j ji

j

 = pj  cj,iR^i2 -

2 cj,iR^i  .

ji

i

2
cj.iR^i
i

16

Under review as a conference paper at ICLR 2019

Using CauchySchwarz inequality,

So we get,

cj,iR^i2 =

cj,i2 ·

i ii

 cj,i

R^i

2


2
cj,iR^i .
i

Var(r^) - Var(r)  0.

On the other hand,

 2

Var(r^) = p^jR^j2 -  p^jR^j  p^jR^j2

jj j



M2 p^j det(C)2

·

Rm2 ax

=

M2 det(C)2

· Rm2 ax.

j

B EXPERIMENTAL SETUP
We set up our experiments within the popular OpenAI baselines (Dhariwal et al., 2017) and keras-rl (Plappert, 2016) framework. Specifically, we integrate the algorithms (CEM, Q-Learning, SARSA, DQN, Dueling-DQN, DDPG, NAF and PPO) and interact with OpenAI Gym (Brockman et al., 2016) environments.

B.1 RL ALGORITHMS

A set of state-of-the-art reinforcement learning algorithms are experimented with while training under different amounts of noise, including Q-Learning (Watkins, 1989; Watkins & Dayan, 1992), Cross-Entropy Method (CEM) (Szita & Lo¨rincz, 2006), Deep SARSA (Sutton & Barto, 1998), Deep Q Learning (DQN) (Mnih et al., 2013; 2015; van Hasselt et al., 2016), Dueling DQN (DDQN) (Wang et al., 2016), Deep Deterministic Policy Gradient (DDPG) (Lillicrap et al., 2015), Continuous DQN (NAF) (Gu et al., 2016) and Proximal Policy Optimization (PPO) (Schulman et al., 2017) algorithms. For each game and algorithm, three policies are trained based on different random initialization to decrease the variance in experiments.

Table 3: RL algorithms utilized in the robustness evaluation.

Environment
CartPole
Pendulum Atari Games

RL Algorithm
Q-Learning (1989) CEM (2006)
SARSA (1998) DQN (2013; 2015)
DDQN (2016) DDPG (2015) NAF (2016) PPO (2017)

B.2 POST-PROCESSING REWARDS

We explore both symmetric and asymmetric noise of different noise levels. For symmetric noise, the confusion matrices are symmetric, which means the probabilities of corruption for each reward choice are equivalent. For instance, a confusion matrix

C=

0.8 0.2

0.2 0.8

says that r1 could be corrupted into r2 with a probability of 0.2 and so does r2 (weight = 0.2).
As for asymmetric noise, two types of random noise are tested: 1) rand-one, each reward level can only be perturbed into another reward; 2) rand-all, each reward could be perturbed to any other reward. To measure the amount of noise w.r.t confusion matrices, we define the weight of noise as follows:
C = (1 - ) · I +  · N,   [0, 1],

17

Under review as a conference paper at ICLR 2019

where  controls the weight of noise; I and N denote the identity and noise matrix respectively. Suppose there are M outcomes for true rewards, N writes as:

n0,0 N = ···

n0,1 · · · n0,M-1

··· ···

··· ,

nM-1,0 nM-1,1 · · · nM-1,M-1

where for each row i, 1) rand-one: randomly choose j, s.t ni,j = 1 and ni,k = 0 if k = j; 2) randall: generate M random numbers that sum to 1, i.e., j ni,j = 1. For the simplicity, for symmetric noise, we choose N as an anti-identity matrix. As a result, ci,j = 0, if i = j or i + j = M .

B.3 TRAINING DETAILS
CartPole and Pendulum The policies use the default network from keras-rl framework. which is a five-layer fully connected network 3. There are three hidden layers, each of which has 16 units and followed by a rectified nonlinearity. The last output layer is activated by the linear function. For CartPole, We trained the models using Adam optimizer with the learning rate of 1e-3 for 10,000 steps. The exploration strategy is Boltzmann policy. For DQN and Dueling-DQN, the update rate of target model and the memory size are 1e-2 and 50, 000. For Pendulum, We trained DDPG and NAF using Adam optimizer with the learning rate of 5e-4 for 150, 000 steps. the update rate of target model and the memory size are 1e-3 and 100, 000.

Atari Games We adopt the pre-processing steps as well as the network architecture from Mnih et al. (2015). Specifically, the input to the network is 84×84×4, which is a concatenation of the last 4 frames and converted into 84 × 84 gray-scale. The network comprise three convolutional layers and two fully connected layers4. The kernel size of three convolutional layer are 8 × 8 with stride 4 (32 filters), 4 × 4 with stride 2 (64 filters) and 3 × 3 with stride 1 (64 filters), respectively. Each
hidden layer is followed by a rectified nonlinearity. Except for Pong where we train the policies for 3e7 steps, all the games are trained for 5e7 steps with the learning rate of 3e-4. Note that the rewards in the Atari games are discrete and clipped into {-1, 0, 1}. Except for Pong game, in which r = -1 means missing the ball hit by the adversary, the agents in other games attempt to get higher
scores in the episode with binary rewards 0 and 1.

C ESTIMATION OF CONFUSION MATRICES
As stated in Section 3.3, the confusion matrix can be estimated dynamically based on the aggregated answers, similar to previous literature in supervised learning (Khetan et al., 2017). To get a concrete view, we take Q-Learning for an example, and the algorithm is called Reward Robust Q-Learning (Algorithm 3). Note that is can be extended to other RL algorithms by plugging confusion matrix estimation steps and the computed surrogate rewards, as shown in the experiments (Figure 4).
To validate the effectiveness of robust reward algorithms (like Algorithm 3), where the noise rates are unknown to the agents, we conduct the same experiments in CartPole. The only difference is the noisy rates are unknown this time. Besides, we discretize the observation (velocity, angle, etc.) to construct a set of states and implement like Algorithm 3. The  is set 1.0 in the experiments.
Figure 4 are learning curves from five algorithms with different kinds of rewards. The trends are very similar to Figure 1, which means, the proposed estimation algorithms successfully obtain the approximate confusion matrices, and are robust in the unknown noise environments. From Figure 5, we can observe that the estimation of confusion matrices converges very fast. The results are inspiring because we don't assume any additional knowledge about noise or true reward distribution in the implementation.
3https://github.com/keras-rl/keras-rl/examples 4https://github.com/openai/baselines/tree/master/baselines/common
18

Under review as a conference paper at ICLR 2019
Algorithm 3 Reward Robust Q-Learning
Input: M~ = (S, A, R~, P, ): MDP with corrupted reward channel T : transition function T : S × A  S N  N: upper bound of collected noisy rewards   (0, 1): learning rate in the update rule   (0, 1): weight of unbiased surrogate reward R~(s, a): set of observed rewards when the state-action pair is (s, a).
Output: Q(s): value function; (s, t): policy function Initialize Q: S × A  R arbitrarily Set confusion matrix C~ as zero while Q is not converged do Start in state s  S while s is not terminal do Calculate  according to Q and exploration strategy a  (s) s  T (s, a) Observe noisy reward r~(s, a) and add it to R~(s, a) if (s,a) |R~(s, a)|  N then Get predicted true reward r¯(s, a) using majority voting in every R~(s, a) Estimate confusion matrix C~ based on r~(s, a) and r¯(s, a) (Eqn. (4)) Empty all the sets of observed rewards R~(s, a) Obtain surrogate reward r(s, a) using Rproxy = (1 - ) · R +  · C-1R Q(s , a)  (1 - ) · Q(s, a) +  · (r^(s, a) +  · maxa Q(s , a )) ss return Q(s) and (s)

(a) Q-Learning

(b) CEM

(c) SARSA

(d) DQN

(e) Dueling-DQN

Figure 4: Complete learning curves from five reward robust RL algorithms (see Algorithm 3) on CartPole game with true rewards (r) , noisy rewards (r~) ( = 1) and estimated surrogate rewards (r) . Note that confusion matrices C are unknown to the agents here. From top to the bottom, the noise rates are 0.1, 0.3, 0.7 and 0.9.

19

Under review as a conference paper at ICLR 2019

(a) Q-Learning

(b) CEM

(c) SARSA

(d) DQN

(e) Dueling-DQN

Figure 5: Estimation analysis from five reward robust RL algorithms (see Algorithm 3) on CartPole game. The upper figures are the convergence curves of estimated error rates (from 0.1 to 0.9), where the solid and dashed lines are ground truth and estimation, respectively; The lower figures are the absolute difference between the estimation and ground truth of confusion matrix C (normalized matrix norm).

D SUPPLEMENTARY EXPERIMENTAL RESULTS

D.1 SUPPLEMENTARY QUANTITATIVE RESULTS
Table 4: Complete average scores of various RL algorithms on CartPole and Pendulum with noisy rewards (r~) and surrogate rewards under known (r^) or estimated (r) confusion matrices. Note that the results for last two algorithms DDPG (rand-one) & NAF (rand-all) are on Pendulum, but the others are on CartPole. The experiments are repeated three times with different random seeds.

Noise Rate  = 0.1  = 0.3  = 0.7

Reward
r~ r^ r
r~ r^ r
r~ r^ r

Q-Learn
170.0 165.8 181.9
134.9 149.3 161.1
56.6 177.6 172.1

CEM
98.1 108.9 99.3
28.8 85.9 81.8
19.2 87.1 83.0

SARSA
165.2 173.6 171.5
144.4 152.4 159.6
12.6 151.4 174.4

DQN
187.2 200.0 200.0
173.4 175.3 186.7
17.2 185.8 189.3

DDQN
187.8 181.4 185.6
168.6 198.7 200.0
11.8 195.2 191.3

DDPG
-1.03 -0.87 -0.90
-1.23 -1.03 -1.05
-8.76 -1.09
­

NAF
-4.48 -0.89 -1.13
-4.52 -1.15 -1.36
-7.35 -2.26
­

Table 5: Complete average scores of PPO on five selected Atari games with noisy rewards (r~) and surrogate rewards (r^). The experiments are repeated three times with different random seeds.

Noise Rate e- = e+ = 0.1 e- = 0.1, e+ = 0.3 e- = e+ = 0.3 e- = e+ = 0.7 e- = 0.9, e+ = 0.7 e- = e+ = 0.9

Reward
r~ r^
r~ r^
r~ r^
r~ r^
r~ r^
r~ r^

Lift ()
­ 67.5%
­ 20.3%
­ 46.7%
­ 557.3%
­ 106.9%
­ 482.3%

Mean
2044.2 3423.1
770.5 926.6
1180.1 1730.8
296.8 1951.0
382.6 791.5
588.8 3428.8

Alien
1814.8 1741.0
893.3 973.7
543.1 1637.7
485.4 1799.2
410.2 693.5
540.6 1901.3

Carnival
1239.2 3630.3
841.8 955.2
919.8 966.1
380.3 1045.2
67.0 918.1
6.3 4261.7

Phoenix
4608.9 7586.3
250.7 643.9
2600.3 4171.5
126.5 4970.4
174.1 298.9
1410.8 6758.6

MsPacman
1709.1 2547.3
1151.1 1307.1
1109.6 1470.2
491.5 1447.8
620.1 1312.0
535.4 2515.1

Seaquest
849.2 1610.6
715.7 753.1
727.8 408.6
0.0 492.5
641.7 735.1
588.8 1707.1

20

Under review as a conference paper at ICLR 2019 D.2 VISUALIZATIONS ON CONTROL GAMES

(a) Q-Learning

(b) CEM

(c) SARSA

(d) DQN

(e) Dueling-DQN

Figure 6: Complete learning curves from five RL algorithms on CartPole game with true rewards (r) , noisy rewards (r~) and surrogate rewards (r^) ( = 1) . From top to the bottom, the noise rates are 0.1, 0.3, 0.7 and 0.9, respectively.

(a) DDPG (symmetric) (b) DDPG (rand-one) (c) DDPG (rand-all) (d) NAF (rand-all)
Figure 7: Complete learning curves from DDPG and NAF on Pendulum game with true rewards (r) , noisy rewards (r~) and surrogate rewards (r^) ( = 1) . Both symmetric and asymmetric noise
are conduced in the experiments. From top to the bottom, the noise rates are 0.1, 0.3, 0.5 and 0.7, respectively.
21

Under review as a conference paper at ICLR 2019 D.3 VISUALIZATIONS ON ATARI GAMES5 D.3.1 PONG
Asymmetric Noise (rand-one)

D.3.2 AIRRAID

Asymmetric Noise (rand-all)

5For the clarity purpose, we remove the learning curves (blue ones in previous figures) with true rewards except for Pong-v4 game.
22

Under review as a conference paper at ICLR 2019 D.3.3 ALIEN
D.3.4 CARNIVAL
D.3.5 MSPACMAN
23

Under review as a conference paper at ICLR 2019 D.3.6 PHOENIX D.3.7 SEAQUEST
24

