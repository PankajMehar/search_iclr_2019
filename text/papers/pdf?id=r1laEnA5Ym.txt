Under review as a conference paper at ICLR 2019
A VARIATIONAL INEQUALITY PERSPECTIVE ON GENERATIVE ADVERSARIAL NETWORKS
Anonymous authors Paper under double-blind review
ABSTRACT
Generative adversarial networks (GANs) form a generative modeling approach known for producing appealing samples, but they are notably difficult to train. One common way to tackle this issue has been to propose new formulations of the GAN objective. Yet, surprisingly few studies have looked at optimization methods designed for this adversarial training. In this work, we cast GAN optimization problems in the general variational inequality framework. Tapping into the mathematical programming literature, we counter some common misconceptions about the difficulties of saddle point optimization and propose to extend techniques designed for variational inequalities to the training of GANs. We apply averaging, extrapolation and a novel computationally cheaper variant that we call extrapolation from the past to the stochastic gradient method (SGD) and Adam.
1 INTRODUCTION
Generative adversarial networks (GANs) (Goodfellow et al., 2014) form a generative modeling approach known for producing realistic natural images (Karras et al., 2018) as well as high quality super-resolution (Ledig et al., 2017) and style transfer (Zhu et al., 2017). Nevertheless, GANs are also known to be difficult to train, often displaying an unstable behavior (Goodfellow, 2016). Much recent work has tried to tackle these training difficulties, usually by proposing new formulations of the GAN objective (Nowozin et al., 2016; Arjovsky et al., 2017). Each of these formulations can be understood as a two-player game, in the sense of game theory (Von Neumann and Morgenstern, 1944), and can be addressed as a variational inequality problem (VIP) (Harker and Pang, 1990), a framework that encompasses traditional saddle point optimization algorithms (Korpelevich, 1976).
Solving such GAN games is traditionally approached by running variants of stochastic gradient descent (SGD) initially developed for optimizing supervised neural network objectives. Yet it is known that for some games (Goodfellow, 2016, §8.2) SGD exhibits oscillatory behavior and fails to converge. This oscillatory behavior, which does not arise from stochasticity, highlights a fundamental problem: while a direct application of basic gradient descent is an appropriate method for regular minimization problems, it is not a sound optimization algorithm for the kind of two-player games of GANs. This constitutes a fundamental issue for GAN training, and calls for the use of more principled methods with more reassuring convergence guarantees.
Contributions. We point out that multi-player games can be cast as variational inequality problems and consequently the same applies to any GAN formulation posed as a minimax or non-zero-sum game. We present two techniques from this literature, namely averaging and extrapolation, widely used to solve variational inequality problems (VIP) but which have not been explored in the context of GANs before.1
We extend standard GAN training methods such as SGD or Adam into variants that incorporate these techniques (Alg. 3, 4 are new). We also explain that the oscillations of basic SGD for GAN training previously noticed (Goodfellow, 2016) can be explained by standard variational inequality optimization results and we illustrate how averaging and extrapolation can fix this issue.
1Independent works (Mertikopoulos et al., 2018) and (Yazici et al., 2018) respectively explored extrapolation and averaging in the context of GANs. More details in related work section §6.
1

Under review as a conference paper at ICLR 2019

We introduce a new technique, called extrapolation from the past, that only requires one gradient computation per iteration compared to extrapolation which requires to compute the gradient twice. We prove its convergence in the stochastic variational inequality setting, i.e. when applied to SGD.
Finally, we test these techniques in the context of standard GAN training. We observe a 4%-6% improvement on the inception score (Salimans et al., 2016) of WGAN (Arjovsky et al., 2017) and WGAN-GP (Gulrajani et al., 2017) on the CIFAR-10 dataset.
Outline. §2 presents the background on GAN and optimization, and shows how to cast this optimization as a VIP. §3 presents standard techniques to optimize variational inequalities in a batch setting as well as our new one, extrapolation from the past. §4 considers these methods in the stochastic setting, yielding three corresponding variants of SGD, and provide their respective convergence rates. §6 discusses the related work and §7 presents experimental results.

2 GAN OPTIMIZATION AS A VARIATIONAL INEQUALITY PROBLEM

2.1 GAN FORMULATIONS

The purpose of generative modeling is to generate samples from a distribution q that matches best the true distribution p of the data. The generative adversarial network training strategy can be understood as a game between two players called generator and discriminator. The former produces a sample that the latter has to classify between real or fake data. The final goal is to build a generator able to produce sufficiently realistic samples to fool the discriminator.

In the original GAN paper (Goodfellow et al., 2014), the GAN objective is formulated as a zero-sum
game where the cost function of the discriminator D is given by the negative log-likelihood of the binary classification task between real or fake data generated from q by the generator,

min


max


L(,

)

d=ef

- E [log
xp

D(x)]

-
x

E [log(1
q

-

D(x

))]

.

(1)

However Goodfellow et al. (2014) recommends to use in practice a second formulation, called non-saturating GAN. This formulation is a non-zero-sum game where the aim is to jointly minimize:

L()(, ) d=ef - E log D(x )
x q

and

L()(,

)

d=ef

-E
xp

log

D(x)

-
x

E log(1-D(x
q

))

.

(2)

The dynamics of this formulation have the same stationary points as the zero-sum one (1) but are claimed to provide "much stronger gradients early in learning" (Goodfellow et al., 2014) .

2.2 EQUILIBRIUM

The minimax formulation (1) is theoretically convenient because a large literature on games studies this problem and provides guarantees on the existence of equilibria. Nevertheless, practical considerations lead the GAN literature to consider a different objective for each player as formulated in (2). In that case, the two-player game problem (Von Neumann and Morgenstern, 1944) consists in finding the following Nash equilibrium:

  arg min L()(, ) and   arg min L()(, ) .





(3)

Only when L() = -L() is the game called a zero-sum game and (3) can be formulated as a minimax problem. One important point to notice is that the two optimization problems in (3) are coupled and have to be considered jointly from an optimization point of view.

Standard GAN objectives are non-convex (i.e. each cost function is non-convex), and thus such (pure) equilibria may not exist. As far as we know, not much is known about the existence of these equilibria for non-convex losses (see Heusel et al. (2017) and references therein for some results). In our theoretical analysis in §4, our assumptions (monotonicity (24) of the operator and convexity of the constraints set) imply the existence of an equilibrium.

In this paper, we focus on ways to optimize these games, assuming that an equilibrium exists. As is often standard in non-convex optimization, we also focus on finding points satisfying the necessary

2

Under review as a conference paper at ICLR 2019

stationary conditions. As we mentioned previously, one difficulty that emerges in the optimization of such games is that the two different cost functions of (3) have to be minimized jointly in  and . Fortunately, the optimization literature has for a long time studied so-called variational inequality problems, which generalize the stationary conditions for two-player game problems.

2.3 VARIATIONAL INEQUALITY PROBLEM FORMULATION

We first consider the local necessary conditions that characterize the solution of the smooth two-player game (3), defining stationary points, which will motivate the definition of a variational inequality. In the unconstrained setting, a stationary point is a couple (, ) with zero gradient:

L()(, ) = L()(, ) = 0 .

(4)

When constraints are present,2 a stationary point (, ) is such that the directional derivative of each cost function is non-negative in any feasible direction (i.e. there is no feasible descent direction):

L()(, ) ( - )  0 and L()(, ) ( - )  0 ,  (, )   × . (5) Defining  d=ef (, ),  d=ef (, ),  d=ef  × , Eq. (5) can be compactly formulated as:

F () ( - )  0 ,    where F () d=ef L()(, ) L()(, ) . (6)

These stationary conditions can be generalized to any continuous vector field: let   Rd and F :   Rd be a continuous mapping. The variational inequality problem (Harker and Pang, 1990)
(depending on F and ) is:

find    such that F () ( - )  0 ,    .

(VIP)

We call optimal set the set  of    verifying (VIP). The intuition behind it is that any    is a fixed point of the constrained dynamic of F (constrained to ).

We have thus showed that both saddle point optimization and non-zero sum game optimization, which encompasses the large majority of GAN variants proposed in the literature, can be cast as Variational Inequality Problems. In the following section, we turn to suitable optimization techniques for such problems.

3 OPTIMIZATION OF VARIATIONAL INEQUALITIES (BATCH SETTING)
Let us begin by looking at techniques that were developed in the optimization literature to solve (VIP). We present the intuitions behind them as well as their performance on a simple bilinear problem (see Fig. 1). Our goal here is to provide mathematical insights into the techniques of averaging (§3.1) and extrapolation (§3.2), to inspire their application to extending other optimization algorithm. We then propose a novel variant of the extrapolation technique in §3.3 extrapolation from the past. We here treat the batch setting, i.e. considering that the operator F () as defined in Eq. 6 yields an exact full gradient. We will present extensions of these techniques to the stochastic setting later in §4.
The two standard methods studied in the VIP literature are the gradient method (Bruck, 1977) and the extragradient method (Korpelevich, 1976). The iterates of the basic gradient method are given by t+1 = P[t - F (t)] where P[·] is the projection onto the constraints set (if constraints are present) associated to (VIP). These iterates are known to converge linearly under an additional assumption on the operator3 (Chen and Rockafellar, 1997), but oscillate for a bilinear operator as shown in Fig. 1. On the other hand, the uniform average of these iterates converge for any bounded monotone operator with a O(1/ t) rate (Nedic´ and Ozdaglar, 2009), motivating the presentation of averaging in §3.1. By contrast, the extragradient method (extrapolated gradient) does not require any averaging to converge for monotone operators (in the batch setting), and can even converge at the faster O(1/t) rate (Nesterov, 2007). The idea of this method is to compute a lookahead step (see intuition on extrapolation in §3.2) in order to compute a more stable direction to follow.
2An example of constraint for GANs is to clip the parameters of the discriminator (Arjovsky et al., 2017). 3Strong monotonicity, a generalization of strong convexity. See §A.

3

Under review as a conference paper at ICLR 2019

3.1 AVERAGING

More generally, we consider a weighted averaging scheme with weights t  0. This weighted averaging scheme have been proposed for the first time for (batch) VIP by Bruck (1977),

¯ T d=ef

T -1 t=0

tt

,

ST

T -1

ST d=ef

t .

t=0

Averaging schemes can be efficiently implemented in an online fashion noticing that,

(7)

¯t = (1 - ~t)¯t-1 + ~tt where 0  ~t  1 .

(8)

For instance, setting ~t

=

1 t

provides uniform averaging (t

=

1) and ~t

=

1-

<

1 pro-

vides geometric averaging also known as exponential moving averaging (t = t). Averaging is

experimentally compared with the other techniques presented in this section in Fig. 1.

In order to illustrate how averaging tackle the oscillatory behavior in game optimization, we consider

a toy example where the discriminator and the generator are linear: D(x) = T x and G(z) = z

(implicitly defining q). By replacing these expressions in the WGAN objective,4 we get the following

bilinear objective:

min max T E[x] - T E[z] .
 ,||||1

(9)

A similar task was presented by Nagarajan and Kolter (2017) where they consider a quadratic discriminator instead of a linear one, and show that gradient descent is not necessarily asymptotically stable. The bilinear objective has been extensively used (Goodfellow, 2016; Mescheder et al., 2018; Yadav et al., 2018) to highlight the difficulties of gradient descent for saddle point optimization. Yet, ways to cope with this issue have been proposed decades ago in the context of mathematical programming. Simplifying further by setting the dimension to 1 and centering the equilibrium to the origin, Eq. 9 becomes:

min max  ·  and (, ) = (0, 0) .
R R

(10)

The operator associated with this minimax game is F (, ) = (, -). There are several ways to compute the discrete updates of this dynamics. The two most common ones are the simultaneous and the alternated gradient update rules,

Simultaneous update:

t+1 = t - t , t+1 = t + t

Alternated update:

t+1 = t - t . t+1 = t + t+1

(11) Interestingly, these two choices give rise to have a completely different behavior. The norm of the simultaneous updates diverges geometrically whereas the alternated iterates are bounded but do not converge to the equilibrium. As a consequence, their respective uniform average have a different behavior, as highlighted in the following proposition (more details and proof in §B.1):

Proposition 1. The simultaneous iterates diverge geometrically and the alternated iterates defined in (11) are bounded but do not converge to 0 as

Simultaneous: t2+1 + 2t+1 = (1 + 2)(t2 + t2) , Alternated: t2 + 2t = (02 + 20) (12)

where ut = (vt)  ,  > 0 : vt  ut  vt.

The

uniform

average

(¯t, ¯t)

d=ef

1 t

t-1 s=0

(s,

s)

of

the

simultaneous

updates

(resp.

the

alternated

updates) diverges (resp. converges to 0) as,

Simultaneous: ¯t2+¯t2 = 

02 + 20 2t2

(1

+

2)t

, Alternated: ¯t2+¯2t = 

02 + 02 2t2

. (13)

This sublinear convergence result, proved in §B, underlines the benefits of averaging when the sequence of iterates is bounded (i.e. for alternated update rule). When the sequence of iterates is not bounded (i.e. for simultaneous updates) averaging fails to ensure convergence. This theorem also shows how alternated updates may have better convergence properties than simultaneous updates.
4Wasserstein GAN (WGAN) proposed by Arjovsky et al. (2017) boils down to the following minimax formulation: min max,||D||L1 Exp[D(x)] - Ex q [D(x )].

4

Under review as a conference paper at ICLR 2019

3.2 EXTRAPOLATION

Another technique used in the variational inequality literature to prevent oscillations is extrapolation. This concept is anterior to the extragradient method since Korpelevich (1976) mentions that the idea of extrapolated "prices" to give "stability" had been already formulated by Polyak (1963, Chap. II). The idea behind this technique is to compute the gradient at an (extrapolated) point different from the current point from which the update is performed, stabilizing the dynamics:

Compute extrapolated point: t+1/2 = P[t - F (t)] , Perform update step: t+1 = P[t - F (t+1/2)] .

(14) (15)

Note that, even in the unconstrained case, this method is intrinsically different from Nesterov's momentum5 (Nesterov, 1983, Eq. 2.2.9) because of this lookahead step for the gradient computation:

Nesterov's method: t+1/2 = t - F (t) , t+1 = t+1/2 + (t+1/2 - t) . (16)

Nesterov's method does not converge when trying to optimize (10). One intuition explaining why
extrapolation provides better convergence properties than the standard gradient method comes
from Euler's method framework (see for instance (Atkinson, 2003) for more details on that topic). Actually, if we consider a first order approximation of t+1/2, we have t+1/2  t+1 + o() and consequently, the update step (15) is close to an implicit method step:

Implicit step: t+1 = t - F (t+1) .

(17)

In the literature on Euler's method, implicit methods are known to be more stable and to benefit from better convergence properties (Atkinson, 2003) than explicit methods. They are not often used in practice though since they require to solve a potentially non-linear system at each iteration.

Taking back the simplified WGAN toy example (10) from §3.1 we get the following update rules,

Implicit:

t+1 = t - t+1 , t+1 = t + t+1

Extrapolation:

t+1 t+1

= =

t - (t t + (t

+ t) - t)

.

(18)

In the following proposition, we will see that the respective convergence rates of the implicit method and extrapolation are highly similar. Keeping in mind that the latter has the major advantage of being more practical, this proposition clearly underlines the benefits of extrapolation (more details and proof in §B.2),
Proposition 2. The squared norm of the iterates Nt d=ef t2 + t2, where the update rule of t and t are defined in (18), decreases geometrically for any  < 1 as,
Implicit: Nt+1 = 1 - 2 + 4 + O(6) Nt , Extrapolation: Nt+1 = (1 - 2 + 4)Nt . (19)

3.3 EXTRAPOLATION FROM THE PAST

One issue with extrapolation is that the algorithm "wastes" a gradient (14). Indeed we need to compute the gradient at two different positions for every single update of the parameters. We thus propose a new technique that we call extrapolation from the past which only requires to compute one gradient for every update. The idea of this technique is to store and re-use the previous extrapolated gradient to compute the new extrapolation point:

Extrapolation from the past: t+1/2 = P[t - F (t-1/2)] Perform update step: t+1 = P[t - F (t+1/2)] and store: F (t+1/2)

(20) (21)

This update scheme can be related to the optimistic mirror descent (Rakhlin and Sridharan, 2013; Daskalakis et al., 2018) in the unconstrained case, (20) and (21) reduce to:

Optimistic mirror descent (OMD): t+1/2 = t-1/2 - 2F (t-1/2) + F (t-3/2) (22)

However our technique comes from a different perspective, it was motived by VIP and inspired from the extragradient method. Furthermore our technique extends to constrained optimization as show in (20) and (21). It is not clear whether or not a single projection added to (22) provides a provably converging algorithm. Using the VIP point of view we are able to prove a linear convergence rate for a projected version of the extrapolation from the past (see details and proof of Theorem 1 in §B.3). We also extend these results to the stochastic operator setting in §4.

5Sutskever (2013, §7.2) showed the equivalence between "standard momentum" and Nesterov's formulation.

5

Under review as a conference paper at ICLR 2019



1.0 0.5 0.0 -0.5 -1.0
-1

01 

Adam with  = 0.01 Gradient method  = 0.1 Averaging  = 2.0

Extrapolation from the past  = 0.5 Extrapolation  = 0.6

Figure 1: Comparison of the basic gradient method (as well as Adam) with the techniques presented in §3 on the optimization
of (9). Only the algorithms advocated in this paper (Averag-
Start ing, Extrapolation and Extrapolation from the past) converge quickly to the solution. Each marker represents 20 iterations.
2 We compare these algorithms on a non-convex objective in §G.1.

Algorithm 1 AvgSGD

Let 0  
for t = 0 . . . T - 1 do dt  F (t, t)

t+1  P[t - tdt]

end for Return ¯T 

T -1 t=0

t t

T -1 t=0

t

Algorithm 2 AvgExtraSGD

for t = 0 . . . T - 1 do

dt  F (t, t)

t  P[t - tdt]

dt  F (t, t)

t+1  P[t - tdt]

end for

Return ¯T 

T -1 t=0

t t

T -1 t=0

t

Algorithm 3 AvgPastExtraSGD

Let 0   for t = 0 . . . T - 1 do

t  P[t - tdt-1] dt  F (t, t) t+1  P[t - tdt]

end for Return ¯T 

T -1 t=0

t t

T -1 t=0

t

Figure 2: Three variants of SGD using the techniques introduced in §3.

Theorem 1 (Linear convergence of extrapolation from the past). If F is µ-strongly monotone (see

§A for the definition of strong monotonicity) and L-Lipschitz, then the updates (20) and (21) with



=

1 4L

provide

linearly

converging

iterates,

t - 

2 2



1- µ 4L

t

0 - 

2 2

,

t  0 .

(23)

In comparison to the results from (Daskalakis et al., 2018) that hold only for a bilinear objective, we provide a faster convergence rate (linear vs sublinear) on the last iterate for a general (strongly monotone) operator F and any projection on a convex . One thing to notice is that the operator of a bilinear objective is not strongly monotone, but in that case one can use the standard extrapolation method (14) which converge linearly for a (constrained or not) bilinear game (Tseng, 1995, Cor. 3.3).

4 OPTIMIZATION OF VIP WITH STOCHASTIC GRADIENTS
In this section, we consider extensions of the techniques presented in section §3 for optimizing (VIP), to the context of a stochastic operator. In this case, at each time step we no longer have access to the exact gradient F () but to an unbiased stochastic estimate of it F (, ) where   P and F () := EP [F (, )]. This is motivated from the GAN formulation where we only have access to a finite sample estimate of the expected gradient, computed on a mini-batch. For GANs,  is thus a mini-batch of points coming from the true data distribution p and the generator distribution q.
For our analysis, we require at least one of the two following assumptions on the stochastic operator:
Assumption 1. Bounded variance by 2: E[ F () - F (, ) 2]  2 ,    .
Assumption 2. Bounded expected squared norm by M 2: E[ F (, ) 2]  M 2,   .
Assump. 1 is standard in stochastic variational analysis, while Assump. 2 is a stronger assumption sometimes made in stochastic convex optimization. To illustrate how strong Assump. 2 is, note that it does not hold for an unconstrained bilinear objective like in our example 10 in §3. It is thus mainly reasonable for bounded constraint sets. Note that in practice we have  M .
We now present and analyse three algorithms, variants of SGD that are appropriate to solve (VIP). They are given in Fig. 2. The first one Alg. 1 (AvgSGD) is the stochastic extension of the gradient method for solving (VIP); Alg. 2 (AvgExtraSGD) uses extrapolation and Alg. 3 (AvgPastExtraSGD) uses extrapolation from the past. A fourth variant (Alg.5) is proposed in §D. These three algorithms return an average of the iterates. The proofs of the theorems presented in this section are in §F.

6

Under review as a conference paper at ICLR 2019

To handle constraints such as parameter clipping (Arjovsky et al., 2017), we present a projected version of theses algorithms, where P[ ] denotes the projection of  onto  (see §A). Note that when  = Rd, the projection is the identity mapping (unconstrained setting). In order to prove the convergence of these three algorithms we will assume that F is monotone:

(F () - F ( )) ( -  )  0  ,    .

(24)

If F can be written as (6), it implies that the cost functions are convex.6
Assumption 3. F is monotone and  is a compact convex set, such that max,  - 2  R2. In that setting the quantity g() := max F () (¯  - ) is well defined and is equal to 0 if and only if  is a solution of (VIP). Moreover, if we are optimizing a zero-sum game, we have  = (, ),  =  ×  and F (, ) = [L(, ) -L(, )] . Hence, the quantity h(, ) := max L(, ) - min L(, ) is well defined and equal to 0 if and only if (, ) is a Nash equilibrium of the game. The two functions g and h are called merit functions (more details on the concept of merit functions in §C). In the following, we call,

Err()

d=ef

 ,max×L(,

)

-

L(,

maxF () (¯  - )

)

if F (, ) = [L(, ) -L(, )] otherwise.

 

(25)

Averaging. Alg. 1 (AvgSGD) presents the stochastic gradient method with averaging, which reduces to the standard (simultaneous) SGD updates for the two-player games used in the GAN literature, but returning an average of the iterates.

Theorem 2. Under Assump. 1, 2 and 3, SGD with averaging (Alg. 1) with a constant step-size gives,

E[Err(¯T )] 

R2 2T

M2 + 2 +
2

where

¯ T

d=ef

1 T

T -1
t ,

T  1 .

t=0

(26)

Thm. 2 uses a similar proof as (Nemirovski et al., 2009). The constant term (M 2 + 2)/2 in (26) is

called the variance term. This type of bound is standard in stochastic optimization. We also provide

in

§F

a

similar

rate

with

an

extra

log

factor

when

t

=

 .
t

We

show

that

this

variance

term

is

smaller

than the one of SGD with prediction method (Yadav et al., 2018) in §E.

Extrapolations. Alg. 2 (AvgExtraSGD) adds an extrapolation step compared to Alg. 1 in order to reduce the oscillations due to the game between the two players. A theoretical consequence is that it has a smaller variance term than (26). As discussed previously, Assump. 2 made in Thm. 2 for the convergence of Alg. 1 is very strong in the unbounded setting. One advantage of SGD with extrapolation is that Thm. 3 does not require this assumption.

Theorem 3. (Juditsky et al., 2011, Thm. 1) Under Assump. 1 and 3, if E[F ] is L-Lipschitz, then SGD with extrapolation and averaging (Alg. 2) using a constant step-size   1 gives,
3L

E[Err(¯T )]



R2 T

+

7 2 2

where

¯ T

d=ef

1 T

T -1
t ,

T  1 .

t=0

(27)

Since in practice  M , the variance term in (27) is significantly smaller than the one in (26). To summarize, SGD with extrapolation provides better convergence guarantees but requires two gradient computations and samples per iteration. This motivates our new method, Alg. 3 (AvgPastExtraSGD) which uses extrapolation from the past and achieves the best of both worlds.

Theorem 4. Under Assump. 1 and 3, if E[F ] is L-Lipschitz then SGD with extrapolation from the past using a constant step-size   1 , gives that the averaged iterates converge as,
2 3L

E[Err(¯T )]



R2 T

+

13 2 2

where

¯ T

d=ef

1 T

T -1
t

T  1 .

t=0

(28)

The bounds is similar to the one provided in Thm. 3 but each iteration of Alg. 3 is computationally half the cost of an iteration of Alg. 2.

6The convexity of the cost functions in (3) is a necessary condition (not sufficient) for the operator to be monotone. In the context of a zero-sum game, the convexity of the cost functions is a sufficient condition.

7

Under review as a conference paper at ICLR 2019

5 COMBINING THE TECHNIQUES WITH ESTABLISHED ALGORITHMS
In the previous sections we presented several techniques that converge on a simple bilinear example. These techniques can be combined in practice with existing algorithms. We propose to combine them to two standard algorithms used for training deep neural networks: the Adam optimizer (Kingma and Ba, 2015) and the SGD optimizer (Robbins and Monro, 1951). Note that in the case of a two-player game (3), the previous results can be generalized to gradient updates with a different step-size for each player by simply rescaling the objectives L() and L() by a different scaling factor. A detailed pseudo-code for Adam with extrapolation step (Extra-Adam) is given in Algorithm 4.

Algorithm 4 Extra-Adam: proposed Adam with extrapolation step.

input: step-size , decay rates for moment estimates 1, 2, access to the stochastic gradients  t(·) and to the projection P[·] onto the constraint set , initial parameter 0, averaging scheme (t)t1 for t = 0 . . . T - 1 do

Option 1: Standard extrapolation.

Sample new minibatch and compute stochastic gradient: gt   t(t)

Option 2: Extrapolation from the past

Load previously saved stochastic gradient: gt =  t-1/2(t-1/2)

Update estimate of first moment for extrapolation: mt-1/2  1mt-1 + (1 - 1)gt Update estimate of second moment for extrapolation: vt-1/2  2vt-1 + (1 - 2)gt2 Correct the bias for the moments: m^ t-1/2  mt-1/2/(1 - 12t-1), v^t-1/2  vt-1/2/(1 - 22t-1) Perform extrapolation step from iterate at time t: t-1/2  P[t -  mvt-t-11//22+ ]
Sample new minibatch and compute stochastic gradient: gt+1/2   t+1/2(t+1/2)

Update estimate of first moment: mt  1mt-1/2 + (1 - 1)gt+1/2

Update estimate of second moment: vt  2vt-1/2 + (1 - 2)gt2+1/2

Compute bias corrected for first and second moment: m^ t  mt/(1 - 12t), v^t  vt/(1 - 22t)

Perform update step from the iterate at time t:

t+1



P[t

-  m^ t
v^t +

]

end for

Output: T -1/2, T or ¯T =

T -1 t=0

t+1t+1/2

/

T -1 t=0

t+1

(see

(8)

for

online

averaging)

6 RELATED WORK
The extragradient method is the standard algorithm to optimize variational inequalities. This algorithm has been originally introduced by Korpelevich (1976) and extended by Nesterov (2007) and Nemirovski (2004). Stochastic versions of the extragradient have been recently analyzed (Juditsky et al., 2011; Yousefian et al., 2014; Iusem et al., 2017) for stochastic variational inequalities with bounded constraints. A linearly convergent variance reduced version of the stochastic gradient method has been proposed by Palaniappan and Bach (2016) for strongly monotone variational inequalities.
Several methods to stabilize GANs consist in transforming a zero-sum formulation into a more general game that can no longer be cast as a saddle point problem. This is the case of the non-saturating formulation of GANs (Goodfellow et al., 2014; Fedus et al., 2018), the DCGANs (Radford et al., 2016), the gradient penalty7 for WGANs (Gulrajani et al., 2017). Yadav et al. (2018) propose an optimization method for GANs based on AltSGD using a momentum based step on the generator. Daskalakis et al. (2018) proposed a method inspired from game theory. Li et al. (2017) suggest to dualize the GAN objective to reformulate it as a maximization problem and Mescheder et al. (2017) propose to add the norm of the gradient in the objective and provide an interesting perspective on GANs, interpreting the training as the search of a two-player game equilibrium. A study of the continuous version of two player games has been conducted by Ratliff et al. (2016). Interesting non-convex results were proved, for a new notion of regret minimization, by Hazan et al. (2017) and in the context of GANs by Grnarova et al. (2018).
The technique of unrolling steps proposed by Metz et al. (2017) can be confused with extrapolation but is actually fundamentally different: the perspective is try to construct the "true generator objective
7The gradient penalty is only added to the discriminator cost function. Since this gradient penalty depends also on the generator, WGAN-GP cannot be cast as a SP problem and is actually a non-zero sum game.

8

Under review as a conference paper at ICLR 2019

function" unrolling for K steps the updates of the generator and then update the discriminator. Nevertheless the fact that this "true generator function" may not be found with a satisfying accuracy may lead to a different behavior than the one expected.
Regarding the averaging technique, some recent work appear to have already successfully used geometric averaging (7) for GANs in practice, but only briefly mention it (Karras et al., 2018; Mescheder et al., 2018). By contrast the present work formally motivates and justifies the use of averaging for GANs by relating them to the VIP perspective, and sheds light on its underlying intuitions in §3.1. Another independent work (Yazici et al., 2018) made a similar attempt but in the context of regret minimization in games. Mertikopoulos et al. (2018) also independently explored extrapolation providing asymptotic convergence results (i.e. without any rate of convergence) in the context of coherent saddle point. The coherence assumption is slightly weaker than monotonicity.

7 EXPERIMENTS

Our goal in this experimental section is not to provide new state-of-the art results with architectural improvements or a new GAN formulation but to show that using the techniques (with theoretical guarantees in the monotone case) that we introduced earlier allow us to optimize standard GANs in a better way. These techniques, which are orthogonal to the design of new formulations of GAN optimization objectives, and to architectural choices, can potentially be used for the training of any type of GAN. We will compare the following optimization algorithms: baselines are SGD and Adam using either simultaneous updates on the generator and on the discriminator (denoted SimAdam and SimSGD) or k updates on the discriminator alternated with 1 update on the generator (denoted AltSGD{k} and AltAdam{k})8. Variants that use extrapolation are denoted ExtraSGD (Alg. 2) and ExtraAdam (Alg. 4). Variants using extrapolation from the past are PastExtraSGD (Alg. 3) and PastExtraAdam (Alg. 4). We also present results using as output the averaged iterates, adding Avg as a prefix of the algorithm name when we use (uniform) averaging.

7.1 BILINEAR SADDLE POINT (STOCHASTIC)

We evaluate the performance of the various stochastic algorithms first on a simple (n = 103, d = 103)
finite sum bilinear objective (a monotone operator) constrained to [-1, 1]d:

1 n  M (i) +  n
i=1
solved by (, ) s.t.

a(i) +  b(i)
M¯  = -a¯ M¯ T  = -b¯

,

(29)

where a¯ d=ef

1 n

n i=1

a(i),

b¯

d=ef

1 n

n i=1

b(i)

and M¯

d=ef

1 n

n i=1

M

(i).

Marices and vectors

Mk(ij), ak(i), b(ki) ; 1  i  n , 1  j, k  d were

randomly generated, but ensuring that (, ) would

belong to [-1, 1]d. Results are shown in Fig. 3. We can

see that AvgSGD and AvgPastExtraSGD perform the

best on this task.

Distance to the optimum

20.0 17.5 15.0 12.5 10.0 7.5 5.0 2.5
0

AltAdam5 AvgAltAdam5 AltSGD1 AvgAltSGD1 ExtraSGD AvgExtraSGD PastExtraSGD AvgPastExtraSGD

20 40 60 80 Number of gradient computation/n

100

Figure 3: Performance of the considered stochastic optimization algorithms on the bilinear problem (29). Each method uses its respective optimal step-size found by grid-search.

7.2 WGAN AND WGAN-GP ON CIFAR10
We now evaluate the proposed techniques in the context of GAN training, which is a challenging stochastic optimization problem where the objectives of both players are non-convex. We focus on the more davanced Adam variants of optimization algorithms (see Alg. 4 for Adam with extrapolation) and compare them for training a fixed DCGAN architecture (Radford et al., 2016) on the CIFAR10 dataset (Krizhevsky and Hinton, 2009) for two different training objectives: WGAN with weight
8In the original WGAN (Arjovsky et al., 2017) paper the authors use k = 5.

9

Under review as a conference paper at ICLR 2019

Model

WGAN

WGAN-GP

Method
SimAdam AltAdam5 ExtraAdam PastExtraAdam OptimAdam

no averaging
6 .05 ± .12 5 .45 ± .08 6.38 ± .09 5.98 ± 0.15 5.74 ± 0.10

uniform avg
5.83 ± .16 5.72 ± .06 6.38 ± .20 6.07 ± 0.19 5.80 ± 0.08

EMA
6.08 ± .10 5.49 ± .05 6.37 ± .08 6.01 ± 0.11 5.78 ± 0.05

no averaging
6 .00 ± .07 6 .25 ± .05 6.22 ± .04 6.27 ± 0.06
-

uniform avg
6.01 ± .08 6.51 ± .05 6.35 ± .05 6.23 ± 0.13
-

Table 1: Best inception scores (averaged over 5 runs) achieved on CIFAR10 for every considered Adam variant. OptimAdam is the related Optimistic Adam (Daskalakis et al., 2018) algorithm. EMA denotes exponential moving average (with  = 0.999, see Eq. 8). We see that the techniques of extrapolation and averaging consistently enable improvements over the baselines (in italic).

Inception Score Inception Score

6.0

5.5

5.0

4.5

4.0

3.5 3.0
0.0

SimAdam  = 2 · 10-5 ExtraAdam  = 5 · 10-5 PastExtraAdam  = 2 · 10-5

0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0

Number of generator updates

×105

6.5

6.0

5.5

5.0

4.5

4.0

3.5

3.0 AltAdam5 = 1 · 10 -4

2.5 ExtraAdam  = 5 · 10-4 PastExtraAdam  = 1 · 10-4

2.0 0.2 0.4 0.6 0.8 1.0

Wall-Clock time in seconds

×104

Figure 4: Left: Mean and standard deviation of the inception score computed over 5 runs for each method on WGAN trained on CIFAR10. To keep the graph readable we show only SimAdam but AltAdam performs similarly. Middle: Samples from a generator trained as a WGAN using ExtraAdam. Right: WGAN-GP trained on CIFAR10: mean and standard deviation of the inception score computed over 5 runs for each method using the best performing learning rate plotted over wall-clock time; all experiments were run on a NVIDIA Quadro GP100 GPU. We see that ExtraAdam converges faster than the Adam baselines.

clipping (constrained) (Arjovsky et al., 2017), and a WGAN-GP objective (Gulrajani et al., 2017) (a non-zero sum game). Models are evaluated using the inception score (Salimans et al., 2016). For each algorithm we did an extensive search over the hyperparameters of Adam (1 = 0.5 and 2 = 0.9 performed best for all). We ran each with 5 different random seeds for 500,000 iterations.
Table 1 reports the best inception score achieved on this problem by each considered method. We see that the techniques of extrapolation and averaging consistently enable improvements over the baselines (see §G.3 for more experiments on averaging). Fig. 4 shows training curves for each method (for their best performing learning rate), as well as samples from an ExtraAdam-trained WGAN. For training WGAN, using an extrapolation step with Adam (ExtraAdam) outperformed all other methods. For training WGAN-GP, the best results are achieved with uniform averaging of AltAdam5, However its iterations require to update the discriminator 5 times for every generator update. With a small drop in best final score, ExtraAdam can train WGAN-GP significantly faster (see Fig. 4 right) as the discriminator and generator are updated only twice. We also observed that methods based on extrapolation are less sensitive to the choice of learning rate and can be used with higher learning rates with less degradation; see App. §G.2 for more details.

8 CONCLUSION
We newly addressed GAN objectives in the framework of variational inequality. We tapped into the optimization literature to provide more principled sound techniques to optimize such games. We leveraged these techniques to develop practical optimization algorithms suitable for a wide range of GAN training objectives (including non-zero sum games and projections onto constraints). We experimentally verified that this could yield better trained models, achieving to our knowledge the best inception score when optimizing a WGAN objective on the reference unmodified DCGAN architecture (Radford et al., 2016). The presented techniques address a fundamental problem in GAN training in a principled way, and are orthogonal to the design of new GAN architectures and objectives. They are thus likely to be widely applicable, and benefit future development of GANs.
10

Under review as a conference paper at ICLR 2019
REFERENCES
M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein generative adversarial networks. In ICML, 2017.
K. E. Atkinson. An introduction to numerical analysis. John Wiley & Sons, 2003.
S. Boyd and L. Vandenberghe. Convex optimization. Cambridge university press, 2004.
R. E. Bruck. On the weak convergence of an ergodic iteration for the solution of variational inequalities for monotone operators in hilbert space. Journal of Mathematical Analysis and Applications, 1977.
G. H. Chen and R. T. Rockafellar. Convergence rates in forward­backward splitting. SIAM Journal on Optimization, 1997.
G. P. Crespi, A. Guerraggio, and M. Rocca. Minty variational inequality and optimization: Scalar and vector case. In Generalized Convexity, Generalized Monotonicity and Applications, 2005.
C. Daskalakis, A. Ilyas, V. Syrgkanis, and H. Zeng. Training GANs with optimism. In ICLR, 2018.
W. Fedus, M. Rosca, B. Lakshminarayanan, A. M. Dai, S. Mohamed, and I. Goodfellow. Many paths to equilibrium: GANs do not need to decrease a divergence at every step. In ICLR, 2018.
G. Gidel, T. Jebara, and S. Lacoste-Julien. Frank-wolfe algorithms for saddle point problems. In AISTATS, 2017.
I. Goodfellow. Nips 2016 tutorial: Generative adversarial networks. arXiv:1701.00160, 2016.
I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Generative adversarial nets. In NIPS, 2014.
P. Grnarova, K. Y. Levy, A. Lucchi, T. Hofmann, and A. Krause. An online learning approach to generative adversarial networks. In ICLR, 2018.
I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. C. Courville. Improved training of wasserstein GANs. In NIPS, 2017.
P. T. Harker and J.-S. Pang. Finite-dimensional variational inequality and nonlinear complementarity problems: a survey of theory, algorithms and applications. Mathematical programming, 1990.
E. Hazan, K. Singh, and C. Zhang. Efficient regret minimization in non-convex games. In ICML, 2017.
M. Heusel, H. Ramsauer, T. Unterthiner, B. Nessler, and S. Hochreiter. GANs trained by a two time-scale update rule converge to a local Nash equilibrium. In NIPS, 2017.
A. Iusem, A. Jofré, R. I. Oliveira, and P. Thompson. Extragradient method with variance reduction for stochastic variational inequalities. SIAM Journal on Optimization, 2017.
A. Juditsky, A. Nemirovski, and C. Tauvel. Solving variational inequalities with stochastic mirror-prox algorithm. Stochastic Systems, 2011.
T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive growing of gans for improved quality, stability, and variation, 2018.
D. P. Kingma and J. Ba. Adam: A method for stochastic optimization. In ICLR, 2015.
G. Korpelevich. The extragradient method for finding saddle points and other problems. Matecon, 12, 1976.
A. Krizhevsky and G. Hinton. Learning multiple layers of features from tiny images. Master's thesis, University of Toronto, Canada, 2009.
T. Larsson and M. Patriksson. A class of gap functions for variational inequalities. Math. Program., 1994.
11

Under review as a conference paper at ICLR 2019
C. Ledig, L. Theis, F. Huszár, J. Caballero, A. Cunningham, A. Acosta, A. P. Aitken, A. Tejani, J. Totz, Z. Wang, et al. Photo-realistic single image super-resolution using a generative adversarial network. In CVPR, 2017.
Y. Li, A. Schwing, K.-C. Wang, and R. Zemel. Dualing GANs. In NIPS, 2017.
P. Mertikopoulos, H. Zenati, B. Lecouat, C.-S. Foo, V. Chandrasekhar, and G. Piliouras. Mirror descent in saddle-point problems: Going the extra (gradient) mile. arXiv, 2018.
L. Mescheder, S. Nowozin, and A. Geiger. The numerics of GANs. In NIPS, 2017.
L. Mescheder, A. Geiger, and S. Nowozin. Which training methods for GANs do actually converge? In ICML, 2018.
L. Metz, B. Poole, D. Pfau, and J. Sohl-Dickstein. Unrolled generative adversarial networks. In ICLR, 2017.
V. Nagarajan and J. Z. Kolter. Gradient descent GAN optimization is locally stable. In NIPS, 2017.
A. Nedic´ and A. Ozdaglar. Subgradient methods for saddle-point problems. J Optim Theory Appl, 2009.
A. Nemirovski. Prox-method with rate of convergence O(1/t) for variational inequalities with lipschitz continuous monotone operators and smooth convex-concave saddle point problems. SIAM J. Optim., 2004.
A. Nemirovski, A. Juditsky, G. Lan, and A. Shapiro. Robust stochastic approximation approach to stochastic programming. SIAM Journal on optimization, 2009.
Y. Nesterov. Introductory Lectures On Convex Optimization. Springer, 1983.
Y. Nesterov. Dual extrapolation and its applications to solving variational inequalities and related problems. Math. Program., 2007.
S. Nowozin, B. Cseke, and R. Tomioka. f-GAN: Training generative neural samplers using variational divergence minimization. In NIPS, 2016.
B. Palaniappan and F. Bach. Stochastic variance reduction methods for saddle-point problems. In NIPS, 2016.
B. T. Polyak. Gradient methods for minimizing functionals. Zhurnal Vychislitel'noi Matematiki i Matematicheskoi Fiziki, 1963.
A. Radford, L. Metz, and S. Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. In ICLR, 2016.
A. Rakhlin and K. Sridharan. Online learning with predictable sequences. In COLT, 2013.
L. J. Ratliff, S. A. Burden, and S. S. Sastry. On the characterization of local nash equilibria in continuous games. 2016.
H. Robbins and S. Monro. A stochastic approximation method. The Annals of Mathematical Statistics, 1951.
T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Radford, and X. Chen. Improved techniques for training GANs. In NIPS, 2016.
I. Sutskever. Training recurrent neural networks. PhD thesis, 2013.
P. Tseng. On linear convergence of iterative methods for the variational inequality problem. Journal of Computational and Applied Mathematics, 1995.
J. Von Neumann and O. Morgenstern. Theory of games and economic behavior. Princeton University Press, 1944.
12

Under review as a conference paper at ICLR 2019 A. Yadav, S. Shah, Z. Xu, D. Jacobs, and T. Goldstein. Stabilizing adversarial nets with prediction
methods. In ICLR, 2018. Y. Yazici, C.-S. Foo, S. Winkler, K.-H. Yap, G. Piliouras, and V. Chandrasekhar. The unusual
effectiveness of averaging in gan training. arXiv preprint arXiv:1806.04498, 2018. F. Yousefian, A. Nedic´, and U. V. Shanbhag. Optimal robust smoothing extragradient algorithms for
stochastic variational inequality problems. In CDC. IEEE, 2014. J.-Y. Zhu, T. Park, P. Isola, and A. A. Efros. Unpaired image-to-image translation using cycle-
consistent adversarial networks. In ICCV, 2017.
13

Under review as a conference paper at ICLR 2019

A DEFINITIONS
In this section we recall usual definitions and lemmas from convex analysis. We start with the definitions and lemmas regarding the projection mapping.

A.1 PROJECTION MAPPING

Definition 1. The projection P onto  is defined as,

P( )  arg min

-

2 2

.

 

(30)

When  is a convex set this projection is unique. This is a consequence of the following lemma that we will use in the following sections: the non-expansiveness of the projection onto a convex set.
Lemma 1. Let  a convex set, the projection mapping P : Rd   is nonexpansive, i.e.,

P() - P( ) 2   -  2 , ,    .

(31)

This is standard convex analysis result which can be found for instance in (Boyd and Vandenberghe, 2004). The following Lemma is also standard in convex analysis and its proof uses similar arguments as the proof of Lemma 1.

Lemma 2. Let    and + d=ef P( + u) then for all    we have,

+ - 

2 2



-

2 2

+

2u

(+ -  ) -

+ - 

2 2

.

(32)

Proof of Lemma 2. We start by simply developing,

+ - 

2 2

=

(+ - ) + ( - 

)

2 2

=

-

2 2

+

2(+

-

)

( -  ) +

+ - 

2 2

=

-

2 2

+

2(+

-

)

(+ -  ) -

+ - 

2 2

.

Then since + is the projection onto the convex set  of  + u we have that (+ - ( + u)) (+ -  )  0 ,    , leading to the result of the Lemma.

A.2 SMOOTHNESS AND MONOTONICITY OF THE OPERATOR

Another important property used is the Lipschitzness of an operator.

Definition 2. A mapping F : Rp  Rd is said to be L-Lipschitz if,

F () - F ( ) 2  L  -  2 , ,    .

(33)

Definition 3. A differentiable function f :   R is said to be µ-strongly convex if

f ()  f ( ) + f ( )

( -  ) + µ 2

-

2 2

,    .

(34)

Definition 4. A function (, )  L(, ) is said convex-concave if L(·, ) is convex for all

   and L(, ·) is concave for all   . An L is said to be µ-strongly convex concave if

(,

)



L(,

)

-

µ 2



2 2

+

µ 2



2 2

is

convex

concave.

Definition 5. For µ > 0, an operator F :   Rd is said to be µ-strongly monotone if

(F () - F ( ))

( -  )  µ  - 

2 2

.

(35)

B GRADIENT METHODS ON UNCONSTRAINED BILINEAR GAMES

In this section we will prove the results provided in §3, namely Proposition 1, Proposition 2 and Theorem 1. For Proposition 1 and 2 let us recall the context. We wanted to derive properties of some gradient methods on the following simple illustrative example

min max  · 
R R

(36)

14

Under review as a conference paper at ICLR 2019

B.1 PROOF OF PROPOSITION 1

Let us first recall the proposition:

Proposition' 1. The simultaneous iterates diverge geometrically and the alternated iterates defined in (11) are bounded but do not converge to 0 as
Simultaneous: t2+1 + 2t+1 = (1 + 2)(t2 + 2t ) , Alternated: t2 + t2 = (02 + 02) (37)
where ut = (vt)  ,  > 0 : vt  ut  vt.

The

uniform

average

(¯t, ¯t)

d=ef

1 t

t-1 s=0

(s,

s)

of

the

simultaneous

updates

(resp.

the

alternated

updates) diverges (resp. converges to 0) as,

Simultaneous: ¯t2+¯2t = 

02 + 20 2t2

(1

+

2)t

, Alternated: ¯t2+¯2t = 

02 + 02 2t2

. (38)

Proof. Let us start with the simultaneous update rule:
t+1 = t - t t+1 = t + t .
Then we have, t2+1 + 2t+1 = (t - t)2 + (t + t)2 = (1 + 2)(t2 + t2) .
The update rule (39) also gives us,
t = t - t+1 t+1 = t+1 - t .
Summing these equation for 0  t  T - 1 we get, ¯T2 + ¯T2 = (0 - T )2 + (0 - T )2 = ((1 + 2)T + 1)(02 + 20) - 20T - 20T =  (1 + 2)T ((02 + 20)

(39)
(40) (41)
(42)
(43) (44) (45)

Let continue start with the alternated update rule

t+1 = t - t t+1 = t + t+1 = t + (t - t)

(46)

Then we have

t+1 t+1

=

1 

- 1 - 2

t t

(47)

by simple linear algebra, for  < 2, the matrix M d=ef

1 

- 1 - 2

has two complex conjugate

eigenvalues which are

± = 1 -   ± i

4 - 2 2

(48)

and their squared magnitude is equal to det(M ) = 1 - 2 + 2 = 1. We can diagonalize M meaning that there exist P an invertible matrix such that M = P -1 diag(+, -)P . Then, we have

t t

= Mt

0 0

= P -1 diag(+t , t-)P

0 0

(49)

and consequently,

t2 + t2 =

22

t t

=

P diag(t+, t-)P

0 0

 P -1 P (02 + 20)

CC

(50)

15

Under review as a conference paper at ICLR 2019

where

· C is the norm in C2 and P

:= maxuC2

Pu C uC

is

the

induced

matrix

norm.

The

same

way we have

02 + 20 =

M -t

t t

2

=

P diag(-+t, --t)P

t t

C

2
 P -1
C

P (t2 + t2)

(51)

Hence, if 02 + 02 > 0 the sequence (t, t) is bounded but do not converge to 0. Moreover the update rule gives us,

t = t - t+1 t = t - t-1




     

 T

T -1
t
t=0

=

0

- T

T

     

 T

T -1
t

=

T -1

- 0 T

+ 0



  

¯T





  

¯T



= =

0 - T T
T -1 - 0 + 0 T

t=0

(52)

Consequently, since t2 + t2 = O(02 + 02),

¯t2 + ¯t2 = O

02 + 20 t

(53)

B.2 IMPLICIT AND EXTRAPOLATION METHOD

In this section we will prove a slightly more precise proposition than Proposition 2,

Proposition' 2. The squared norm of the iterates Nt d=ef t2 + 2t , where the update rule of t and t defined in (18), decrease geometrically for any 0 <  < 1 as,

Implicit:

Nt+1 =

1

Nt + 2

,

Extrapolation: Nt+1 = (1 - 2 + 4)Nt ,

t  0

(54)

Proof. Let us recall the update rule for the Implicit method

t+1 = t - t+1  t+1 = t + t+1

(1 + 2)t+1 = t - t (1 + 2)t+1 = t + t

Then, Implying that

(1 + 2)2(t2+1 + 2t+1) = (t - t)2 + (t + t)2 = t2 + 2t + +2(t2 + t2)

t2+1

+ 2t+1

=

t2 + 2t 1 + 2

For the extrapolation method we have the update rule

t+1 = t - (t + t) t+1 = t + (t - t)

Implying that,
t2+1 + 2t+1 = (t - (t + t))2 + (t + (t - t))2 = t2 + 2t - 22(2 + 2) + 2((t - t)2 + (t + t)2) = (1 - 2 + 4)(t2 + 2t )

(55)
(56) (57) (58)
(59)
(60) (61) (62)

16

Under review as a conference paper at ICLR 2019

B.3 EXTRAPOLATION FROM THE PAST

Let us recall what we call projected extrapolation form the past, where we used the notation t = t+1/2 for compactness,

Extrapolation from the past: t = P[t - F (t-1)] Perform update step: t+1 = P[t - F (t)] and store: F (t)

(63) (64)

where P[·] is the projection onto the constraint set . An operator F :   Rd is said to be µ-strongly monotone if

(F () - F ( ))

( -  )  µ  - 

2 2

.

(65)

If F is strongly monotone we can prove the following theorem:

Theorem' 1. If F is µ-strongly monotone (see §A for the definition of strong monotonicity) and

L-Lipschitz,

then

the

updates

(20)

and

(21)

with



=

1 4L

provide

linearly

converging

iterates,

t - 

2 2



1- µ 4L

t

0 - 

2 2

,

t  0 .

(66)

Proof. In order to prove tis theorem we will prove a slightly more general result,

t+1 - 

2 2

+

t-1 - t

2 2



1- µ 4L

(

t - 

2 2

+

t-1 - t-2

2 2

)

.

implying that

t+1 - 

2 2



t+1 - 

2 2

+

t-1 - t

2 2



1- µ 4L

t

0 - 

2 2

.

with the convention that 0 = -1 = -2. Let us first proof three technical lemmas,

Lemma 3. If F is µ-strongly monotone we have,

µ

t - 

2 2

-

2

t - t

2 2

 2F (t) (t - ) ,

    .

(67) (68)
(69)

Proof. By strong monotonicity and optimality of ,

2µ

t - 

2 2



2F

()

(t - ) + 2µ

t - 

2 2



2F (t)

(t - )

(70)

and

then

we

use the inequality

2

t

- 

2 2



t

- 

2 2

-

2

t - t

2 2

to

get the result

claimed.

Lemma 4. If F is L-Lipschitz, we have for any   ,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

-

t - t

2 2

+

t2L2

t-1 - t

2 2

.

(71)

Proof. Applying Lemma 2 for (, u, +,  ) = (t, -tF (t), t+1, ) and (, u, +,  ) = (t, -tF (t-1), t, t+1), we get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t)

(t+1 - ) -

t+1 - t

2 2

(72)

and

t - t+1

2 2



t - t+1

2 2

-

2tF

(t-1)

(t - t+1) -

t - t

2 2

.

Summing (72) and (73) we get,

(73)

t+1 - 

2 2



t - 

2 2

-

2tF

(t)

(t+1 - )

- 2tF (t-1)

(t - t+1) -

t - t

2 2

-

t - t+1

2 2

=

t - 

2 2

-

2tF

(t)

(t - ) -

t - t

2 2

-

t - t+1

2 2

- 2t(F (t-1) - F (t)) (t - t+1) .

(74) (75)
(76)

17

Under review as a conference paper at ICLR 2019

Then, we can use the Young's inequality 2a

b

a

2 2

+

b

2 2

to

get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t)

(t - ) + t2

F (t-1) - F (t)

2 2

+

t - t+1

2 2

-

t - t

2 2

-

t - t+1

2 2

(77)

=

t - 

2 2

-

2tF

(t)

(t - ) + t2

F (t-1) - F (t)

2 2

-

t - t

2 2



t - 

2 2

-

2tF

(t)

(t - ) + t2L2

t-1 - t

2 2

-

t - t

2 2

.

(78)

Lemma 5. For all t  0, if we set -2 = -1 = 0 we have

t-1 - t

2 2



4

t - t

2 2

+

4t2-1L2

t-1 - t-2

2 2

-

t-1 - t

2 2

.

Proof. We start with

a+b

2 2



2

a

2+2

b

2.

t-1 - t

2 2



2

t - t

2 2

+

2

t - t-1

2 2

.

Moreover, since the projection is contractive we have that

t - t-1

2 2



t-1 - t-1F (t-1) - t-1 - t-1F (t-2)

2 2

= t2-1

F (t-1) - F (t-2)

2 2

 t2-1L2

t-1 - t-2

2 2

.

Combining (80) and (83) we get,

t-1 - t

2 2

=

2

t-1 - t

2 2

-

t-1 - t

2 2

4

t - t

2 2

+

4

t - t-1

2 2

-

t-1 - t

2 2

4

t - t

2 2

+

4t2-1L2

t-1 - t-2

2 2

-

t-1 - t

2 2

.

(79)
(80)
(81) (82) (83)
(84) (85) (86)

Proof of Theorem 1. Let    be an optimal point of (VIP). Combining Lemma 3 and Lemma 4 we get,

tµ

t - 

2 2

-

2

t - t

2 2



t-

2 2

-

t+1-

2 2

+t2L2

t-1-t

22-

t-t

2 2

leading to,

t+1 - 

2 2



(1

-

tµ)

t - 

2 2

+

t2L2

t-1 - t

2 2

-

(1

-

2tµ)

t - t

2 2

(87)

Now using Lemma 5 we get,

t+1 - 

2 2



(1

-

tµ)

t - 

2 2

+

t2L2(4t2-1L2

t-1 - t-2

2 2

-

t-1 - t 22)

- (1 - 2tµ - 4t2L2)

t - t

2 2

(88)

Now

with

t

=

1 4L



1 4µ

we

get,

t+1 - 

2 2



1- µ 4L

t - 

2 2

+

1 16

1 4

t-1 - t-2

2 2

-

t-1 - t

2 2

Hence,

using

the

fact

that

µ 4L



1 4

we

get,

t+1 - 

2 2

+

1 16

t-1 - t

2 2



1- µ 4L

t - 

2 2

+

1 16

t-1 - t-2

2 2

.

(89)

18

Under review as a conference paper at ICLR 2019

C MORE ON MERIT FUNCTIONS

In this section, we will present how to handle unbounded constaints set  with a more refined merit function than (25) used in the main paper. Let F the continuous operator and  the constraints set associated with the VIP

find    such that F () ( - )  0 ,    .

(VIP)

When the operator F is monotone, we have that F () ( - )  F () ( - ) , , . Hence, in this case (VIP) implies a stronger formulation sometimes called Minty variational inequality (Crespi et al., 2005):

find    such that F () ( - )  0 ,    .

(MVI)

This formulation is stronger in the sense that if (MVI) holds for some   , then (VIP) holds too. A merit function useful for our analysis can be derived from this formulation. Roughly, a merit function is a convergence measure. More formally, a function g :   R is called a merit function if g is non-negative such that g() = 0     (Larsson and Patriksson, 1994). A way to derive a merit function from (MVI) would be to use g() = sup F () ( - ) which is zero if and only if (MVI) holds for . To deal with unbounded constraint sets (leading to a potentially infinite valued function outside of the optimal set), we use the restricted merit function (Nesterov, 2007):

ErrR(t) d=ef

max

F () (t - ) .

, -0 R

(90)

This function acts as merit function for (VIP) on the interior of the open ball of radius R around 0,

as shown in Lemma 1 of Nesterov (2007). That is, let R d=ef   { :  - 0 < R}. Then for any point ^  R, we have:

ErrR(^ ) = 0  ^    R.

(91)

The reference point 0 is arbitrary, but in practice it is usually the initialization point of the algorithm. R has to be big enough to ensure that R contains a solution. ErrR measures how much (MVI) is violated on the restriction R. Such merit function is standard in the variational inequality literature. A similar one is used in (Nemirovski, 2004; Juditsky et al., 2011). When F is derived from the
gradients (5) of a zero-sum game, we can define a more interpretable merit function. One has to be
careful though when extending properties from the minimization setting to the saddle point setting
(e.g. the merit function used by Yadav et al. (2018) is vacuous for a bilinear game as explained in
App C.2).

In the appendix we adopt a set of assumptions a little more general than the one in the main paper

Assumption 4.

· F is monotone and  is convex and closed.

· R is set big enough such that R > 0 -  and F is a monotone operator.

Contrary to Assumption 3, in Assumption 4 the constraints set in no longer assumed to be bounded. Assumption 4 is more general than Assumption 3 since that if  is bounded then with R set to the diameter of , Assumption 4 is true.

C.1 MORE GENERAL MERIT FUNCTIONS

In the appendix we will note Err(RVI) the restricted merit function defined in (90). Let us recall its definition,

Err(RVI)(t) d=ef

max
, -0

F ()
R

(t - ) .

(92)

When the objective is a saddle point problem i.e.,

F (, ) = [L(, ) -L(, )]

(93)

and L is convex-concave (see Definition 4 in §A), we can use another merit function than (92) on R that is more interpretable and more directly related to the cost function of the minimax formulation:

Err(RSP)(t, t) d=ef

max
,

L(t, ) - L(, t) .

(,)-(0,0) R

(94)

19

Under review as a conference paper at ICLR 2019

In particular, if the equilibrium (, )    R and we have that L(·, ) and -L(, ·) are µ-strongly convex (see §A), then the merit function for saddle points upper bounds the distance for (, )  R to the equilibrium as:

ErrR(SP)(, ) 

µ (
2

 - 

2 2

+

 - 

22) .

(95)

In the appendix, we provide our convergence results with the merit functions (92) and (94), depending on the setup:



ErrR

(

)

d=ef

 

Err(RSP)() ErrR(VI)()

if F is a SP operator (5) otherwise.

(96)

C.2 ON THE IMPORTANCE OF THE MERIT FUNCTION
In this section, we illustrate the fact that one has to be careful when extending results and properties from the minimization setting to the minimax setting (and consequently to the variational inequality setting). Another candidate as a merit function for saddle point optimization would be to naturally extend the suboptimality f () - f () used in standard minimization (i.e. find  the minimizer of f ) to the gap P (, ) = L(, ) - L(, ). In a previous analysis of a modification of the stochastic gradient descent (SGD) method for GANs, Yadav et al. (2018) gave their convergence rate on P that they called the "primal-dual" gap. Unfortunately, if we do not assume that the function L is strongly convex-concave (a stronger assumption defined in §A and which fails for bilinear objective e.g.), P may not be a merit function. It can be 0 for a non optimal point, see for instance the discussion on the differences between (94) and P in (Gidel et al., 2017, Section 3). In particular, for the simple 2D bilinear example L(, ) =  · , we have that  =  = 0 and thus P (, ) = 0 ,  .

C.3 VARIATIONAL INEQUALITIES FOR NON-CONVEX COST FUNCTIONS
When the cost functions defined in (3) are non-convex, the operator F is no longer monotone. Nevertheless, (VIP) and (MVI) can still be defined, though a solution to (MVI) is less likely to exist. We note that (VIP) is a local condition for F (as only evaluating F at the points ). On the other hand, an appealing property of (MVI) is that it is a global condition. In the context of minimization of a function f for example (where F = f ), if  solves (MVI) then  is a global minimum of f (and not just a stationary point for the solution of (MVI); see Proposition 2.2 from Crespi et al. (2005)).
A less restrictive way to consider variational inequalities in the non-monotone setting is to use a local version of (MVI). If the cost functions are locally convex around the optimal couple (, ) and if our iterates eventually fall and stay into that neighborhood, then we can consider our restricted merit function ErrR(·) with a well suited constant R and apply our convergence results for monotone operators.

D ANOTHER WAY OF IMPLEMENTING EXTRAPOLATION TO SGD
We now introduce another way to combine extrapolation and SGD. This extension is very similar to Alg. 5, the only difference is that it re-uses the minibatch sample of the extrapolation step for the update of the current point. The intuition is that it correlates the estimator of the gradient of the extrapolation step and the one of the update step leading to a better correction of the oscillations which are also due to the stochasticity. One emerging issue (for the analysis) of this method is that since t depend on t, the quantity F (t, t) is a biased estimator of F (t).
20

Under review as a conference paper at ICLR 2019

Algorithm 5 Re-used minibatches for stochastic extrapolation (ReExtraSGD)

1: Let 0  

2: for t = 0 . . . T - 1 do

3: Sample t  P

4: t d=ef P[t - tF (t, t)]

5: t+1 d=ef P[t - tF t, t ]

6: end for

7: Return ¯T =

T -1 t=0

t

t/

T -1 t=0

t

Extrapolation step Update step wit the same sample

Theorem 5. Assume that t - 0  R, t  0 where (t)t0 are the iterates of Alg. 5. Under Assumption 1 and 4, for any T  1, Alg. 5 with constant step-size   1 has the following
2L
convergence properties:

E[ErrR(¯T )]



R2 T

+

2 

+ 4L2(4R2 2

+ 2)

where

¯ T

d=ef

1 T

T -1
t .

t=0

Particularly, t

=

 T

gives E[ErrR(¯T )] 

O(1) .
T

The assumption that the sequence of the iterates provided by the algorithm is bounded is strong, but has been also done for instance in (Yadav et al., 2018). The proof of this result is provided in §F.

E VARIANCE COMPARISON BETWEEN AVGSGD AND SGD WITH PREDICTION
METHOD
To compare the variance term of AvgSGD in (26) with the one of the SGD with prediction method (Yadav et al., 2018), we need to have the same convergence certificate. Fortunately, their proof can be adapted to our convergence criterion (using Lemma 6 in §F), revealing an extra 2/2 in the variance term from their paper. The resulting variance can be summarized with our notation as (M 2(1 + L) + 2)/2 where the L is the Lipschitz constant of the operator F . Since M , their variance term is then 1 + L time larger than the one provided by the AvgSGD method.

F PROOF OF THEOREMS

This section is dedicated on the proof of the theorems provided in this paper in a slightly more general form working with the merit function defined in (96). First we prove an additional lemma necessary to the proof of our theorems.

Lemma 6. Let F be a monotone operator and let (t), (t), (zt), (t), (t) and (t) be six random sequences such that, for all t  0

2tF (t) (t - )  Nt - Nt+1 + t2(M1(t, t) + M2(t, t)) + 2tt (zt - ) ,

where Nt = N (t, t-1, t-2)  0 and we extend (t) with -2 = -1 = 0. Let also assume

that with N0



R,

E[

t

2 2

]



2,

E[t|zt, 0, . . . , t-1]

= 0,

E[M1(t, t)]  M1 and

E[M2(t, t)]  M2 , then,

E[ErrR(¯T )]



R2 ST

+

M1

+ M2 2ST

+ 2

T -1
t2
t=0

(97)

where ¯ T d=ef

T -1 t=0

tt/ST

and ST

d=ef

T -1 t=0

t.

21

Under review as a conference paper at ICLR 2019

Proof of Lemma 6. We sum (6) for 0  t  T - 1 to get,

T -1
2 tF (t) (t - ) 
t=0
T -1
(Nt - Nt+1) + t2((M1(t, t) + M2(t, t)) + 2tt (zt - )
t=0

.

We will then upper bound each sum in the right-hand side,

(98)

t (zt - ) = t (zt - ut) + t (ut - )

where ut+1 d=ef P(ut - tt) and u0 d=ef 0. Then,

ut+1 - 

2 2



ut - 

2 2

-

2tt

(ut

-

)

+

t2

t

2 2

leading to

2tt (zt - )  2tt (zt - ut) +

ut - 

2 2

-

ut+1 - 

2 2

+

t2

t

2 2

(99)

Then noticing that z0 d=ef 0, back to (98) we get a telescoping sum,

T -1

T -1

2 tF (t) (t-)  2N0+

t2((M1(t, t)+M2(t, t))+ t 22)+2tt (zt-ut) .

t=0 t=0

(100)

If F is the operator of a convex-concave saddle point (5), we get, with t = (t, t)

F (t) (t - )  L(t, t) (t - ) - L(t, t) (t - )  L(t, ) - L(t, t) + L(t, t) - L(, t) (by convexity and concavity) = L(t, ) - L(, t)

then by convexity of L(·, ) and concavity of L(, ·), we have that,

2ST

T -1 t=0

t ST

F (t)

(t

- )



2ST

T -1 t=0

t ST

(L(t, ) - L(,

t))



2¯ST (L(¯t,

) - L(¯, t))

(101)

Otherwise if the operator F is just monotone since F (t) (t - )  F ( ) (t - ) we have that

T -1

T -1

2ST tF (t) (t - )  2ST tF ( ) (t - ) = 2ST F ( ) (¯t - )

t=0 t=0

(102)

In both cases, we can now maximize the left hand side respect to  (since the RHS does not depend on ) to get,

T -1

2ST ErrR(¯t)  2R2 +

t2((M1(t, t) + M2(t, t)) + t 22) + 2tt (zt - ut) . (103)

t=0

Then taking the expectation, since E[t|zt, ut] = E[t|zt, 0, . . . , t-1] = 0,

Et [

t

2 2

]



2,

Et [M1(t, t)]  M1 and

Et [M2(t, t)]  M2 , we get that,

E[ErrR(¯T )]



R2 ST

+

M1

+ M2 2ST

+ 2

T -1
t2
t=0

(104)

22

Under review as a conference paper at ICLR 2019

F.1 PROOF OF THM.2

First let us state Theorem 2 in its general form,

Theorem' 2. Under Assumption 1, 2 and 4, Alg. 1 with constant step-size  has the following convergence rate for all T  1,

E[ErrR(¯T )] 

R2 2T

M2 + 2 +
2

where

¯ T

d=ef

1 T

T -1
t .

t=0



Particularly,



=

R
T (M 2+2)

gives

E[ErrR(¯T )]



R

M 2+2 .
T

(105)

Proof of Theorem 2. Let any    such that 0 -  2  R,

t+1 - 

2 2

=

P(t - tF (t, t)) - 

2 2



t - tF (t, t)) - 

2 2

(projections are non-contractive, Lemma 1)

=

t - 

2 2

-

2tF

(t,

t)

(t - ) +

tF (t, t)

2 2

Then we can make appear the quantity F (t) (t - ) on the left-hand side,

2tF (t)

(t-) 

t-

2 2

-

t+1-

2 2

+t2

F (t, t)

2 2

+2t(F

(t)-F

(t

,

t))

(t-)

(106)

we can sum (106) for 0  t  T - 1 to get,

T -1

2 tF (t) (t - ) 

t=0

T -1

( t - 

2-

t+1 - 

2) + t2

F (t, t)

2 2

+

2tt

(t - )

t=0

(107)

where we noted t d=ef F (t) - F (t, t). By monotonicity, F (t) (t - )  F () (t - ) we get,

T -1

2ST F () (¯T -) 

( t -  2 -

t+1 - 

2) + t2

F (t, t)

2 2

+

2tt

(t - )

,

t=0
(108)

where ST d=ef

T -1 t=0

t

and ¯T

d=ef

1 ST

T -1 t=0

tt.

We will then upper bound each sum in the right hand side,

t (t - ) = t (t - ut) + t (ut - )

where ut+1 d=ef P(ut - tt) and u0 = 0. Then,

ut+1 - 

2 2



ut - 

2 2

-

2tt

(ut

-

)

+

t2

t

2 2

leading to

2tt (t - )  2tt (t - ut) +

ut - 

2 2

-

ut+1 - 

2 2

+

t2

t

2 2

(109)

Then noticing that u0 d=ef 0, back to (108) we get a telescoping sum,

T -1

T -1

2ST F () (¯T - )  2 0 -  2 +

t2(

F (t, t)

2 2

+

t

22) + 2

tt (t - ut)

t=0 t=0

T -1

T -1

 2R +

t2(

F (t, t)

2 2

+

t

22) + 2

tt (t - ut)

t=0 t=0

23

Under review as a conference paper at ICLR 2019

Then the right hand side does not depends on , we can maximize over  to get,

T -1

T -1

2ST ErrR(¯T )  2R +

t2(

F (t, t)

2 2

+

t

22) + 2

tt (t - ut)

t=0 t=0

(110)

Noticing that E[t|t, ut] = 0 (the estimates of F are unbiased), by Assumption 2 E[( F (t, t) 22]  M 2 and by Assumption 1 E[ t 22]  2 we get,

E[ErrR(¯T )] 

R ST

+

M2 + 2 2ST

T -1
t2
t=0

(111)

particularly

for

t

=



and

t

=

 t+1

we

respectively

get,

E[ErrR(¯T )]



2R T

+

 (M 2 2

+

2)

(112)

and

E[ErrR(¯T )]



 4R  T +1-

1

+ 2 ln(T

+ 1) M 2 + 2 T +1-1

(113)

F.2 PROOF OF THM.3

Theorem' 3. Under Assumption 1 and 4, if E[F ] is L-Lipschitz, then Alg. 2 with a constant step-size   1 has the following convergence rate for any T  1,
3L

E[ErrR(¯T )]



R2 T

+

7 2 2

where



Particularly, 

=

2R  7T

gives E[ErrR(¯T )] 

14R .
T

¯ T

d=ef

1 T

T -1
t .

t=0

(114)

Proof of Thm.3. Let any    such that 0 -  2  R. Then, the update rules become t+1 = P(t - tF (t, t)) and t = P(t - F (t, t)). We start by applying Lemma 2 for (, u,  , +) = (t, -F (t, t), , t+1) and (, u,  , +) = (t, -tF (t, t), t+1, t),

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t+1 - ) -

t+1 - t

2 2

t - t+1

2 2



t - t+1

2 2

-

2t

F

(t

,

t

)

(t - t+1) -

t - t

2 2

Then, summing them we get

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t+1 - )

- 2tF (t, t)

(t - t+1) -

t - t

2 2

-

t+1 - t

2 2

leading to

(115)

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - )

+ 2t(F (t, t) - F (t, t))

(t - t+1) -

t - t

2 2

-

t+1 - t

2 2

Then with 2a

b

a

2 2

+

b

2 2

we

get

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - )

-

t - t

2 2

+

t2

F (t, t) - F (t, t)

2 2

Using the inequality

a+b+c

2 2



3(

a

2 2

+

b

2 2

+

c 22) we get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - ) -

t - t

2 2

+ 3t2(

F (t) - F (t, t)

2 2

+

F (t) - F (t, t)

2 2

+

F (t) - F (t)

2 2

)

24

Under review as a conference paper at ICLR 2019

Then we can use the L-Lipschitzness of F to get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - ) -

t - t

2 2

+ 3t2(

F (t) - F (t, t)

2 2

+

F (t) - F (t, t)

2 2

+

L2

t - t 22)

As

we

restricted

the

step-size

to

t



1 3L

we

get,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

+

2t(F

(t)

-

F

(t,

t))

(t - )

+ 3t2

F (t) - F (t, t)

2 2

+

3t2

F (t) - F (t, t)

2 2

We get a particular case of (6) so we can use Lemma 6 where Nt = t -  22,

M1(t, t) = 3

F (t)-F (t, t)

2 2

,

M2(t, t) = 3

F (t)-F (t, t)

2 2

,

t

=

F

(t)-F

(t,

t)

and zt = t. By Assumption 1, M1 = M2 = 32 and by the fact that

E[F (t) - F (t, t) |t, 0, . . . , t-1] = E[E[F (t) - F (t, t) |t]|0, . . . , t-1] = 0

the hypothesis of Lemma 6 hold and we get,

E[ErrR(¯T )]



R2 ST

+

72 2ST

T -1
t2
t=0

(116)

F.3 PROOF OF THM. 4

Theorem' 4. Under Assumption 1, if E[F ] is L-Lipschitz, then AvgPastExtraSGD (Alg. 3) with a constant step-size   1 has the following convergence rate for any T  1,
2 3L

E[ErrR(¯T )]



R2 T

+

13 2 2

where



Particularly, 

=

2R  7T

gives E[ErrR(¯T )] 

14R .
T

¯ T

d=ef

1 T

T -1
t .

t=0

(117)

First let us recall the update rule

t+1 = P[t - tF (t, t)] t+1 = P[t+1 - t+1F (t, t)] .

(118)

Lemma 7. We have for any   ,

2F (t, t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

-

t - t

2 2

+

3t2L2

t-1 - t

2 2

+ 3t2

F (t-1, t-1) - F (t-1)

2 2

+

F (t) - F (t, t)

2 2

.

(119)

Proof. Applying Lemma 2 for (, u, +,  ) = (t, -tF (t, t), t+1, ) and (, u, +,  ) = (t, -tF (t-1, t-1), t, t+1), we get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t+1 - ) -

t+1 - t

2 2

(120)

and

t - t+1

2 2



t - t+1

2 2

-

2tF

(t-1,

t-1)

(t - t+1) -

t - t

2 2

.

(121)

Summing (120) and (121) we get,

t+1 - 

2 2



t - 

2 2

-

2t

F

(t

,

t

)

(t+1 - )

- 2tF (t-1, t-1)

(t - t+1) -

t - t

2 2

-

t - t+1

2 2

=

t - 

2 2

-

2t

F

(t

,

t

)

(t - ) -

t - t

2 2

-

t - t+1

2 2

- 2t(F (t-1, t-1) - F (t, t)) (t - t+1) .

(122) (123) (124) (125)

25

Under review as a conference paper at ICLR 2019

Then, we can use the inequality of arithmetic and geometric means 2a

b

a

2 2

+

b

2 2

to

get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - ) + t2

F (t-1, t-1) - F (t, t)

2 2

+

t - t+1

2 2

-

t - t

2 2

-

t - t+1

2 2

(126)

=

t - 

2 2

-

2tF

(t,

t)

(t - )

(127)

+ t2

F (t-1, t-1) - F (t, t)

2 2

-

t - t

2 2

.

(128)

Using the inequality

a+b+c

2 2



3(

a

2 2

+

b

2 2

+

c 22) we get,

F (t-1, t-1) - F (t, t)

2 2



3(

F (t-1, t-1) - F (t-1)

2 2

+

F (t-1) - F (t)

2 2

+ F (t) - F (t, t) 22)

(129)

 3(

F (t-1, t-1) - F (t-1)

2 2

+

L2

t-1 - t

2 2

+ F (t) - F (t, t) 22) ,

(130)

where we used the L-Lipschitzness of F for the last inequality.

Combining (128) with (130) we get,

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - ) -

t - t

2 2

+

3t2L2

t-1 - t

2 2

+ 3t2

F (t-1, t-1) - F (t-1)

2 2

+

F (t) - F (t, t)

2 2

.

(131)

Lemma 8. For all t  0, if we set -2 = -1 = 0 we have

t-1 - t

2 2



4

t - t

2 2

+

12t2-1

F (t-1, t-1) - F (t-1)

2 2

+

L2

t-1 - t-2

2 2

+

F (t-2) - F (t-2, t-2) 22)

-

t-1 - t

2 2

.

(132)

Proof. We start with

a+b

2 2



2

a

2+2

b

2.

t-1 - t

2 2



2

t - t

2 2

+

2

t - t-1

2 2

.

(133)

Moreover, since the projection is contractive we have that

t - t-1

2 2



t-1 - t-1F (t-1, t-1) - t-1 - t-1F (t-2, t-2)

2 2

= t2-1

F (t-1, t-1) - F (t-2, t-2)

2 2

 3t2-1

F (t-1, t-1) - F (t-1)

2 2

+

L2

t-1 - t-2

2 2

+ F (t-2) - F (t-2, t-2) 22) .

(134) (135)
(136)

where in the last line we used the same inequality as in (130). Combining (132) and (136) we get,

t-1 - t

2 2

=

2

t-1 - t

2 2

-

t-1 - t

2 2

(137)

4

t - t

2 2

+

4

t - t-1

2 2

-

t-1 - t

2 2

(138)

4

t - t

2 2

+

12t2-1

F (t-1, t-1) - F (t-1)

2 2

+

L2

t-1 - t-2

2 2

+

F (t-2) - F (t-2, t-2) 22)

-

t-1 - t

2 2

.

(139)

Proof of Theorem 4. Combining Lemma 8 and Lemma 7 we get,

2tF (t, t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

+ 36t2t2-1L2

F (t-1, t-1) - F (t-1)

2 2

+

L2

t-1 - t-2

2 2

+

F (t-2) - F (t-2, t-2)

2 2

- 3t2L2

t-1 - t

2 2

+

(12t2L2

-

1)

t - t

2 2

+ 3t2

F (t-1, t-1) - F (t-1)

2 2

+

F (t) - F (t, t) 22] .

(140)

26

Under review as a conference paper at ICLR 2019

Then

for

t



1 2 3L

we

have

36t2t2-1L4



3t2-1L2,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

+ 3L2(t2-1

t-1 - t-2

2 2

-

t2

t-1 - t

2 2

)

+ 2t(F (t) - F (t, t)) (t - )

+ 3t2

|F (t-2, t-2) - F (t-2)

2 2

+

2

F (t-1, t-1) - F (t-1)

2 2

+ F (t) - F (t, t) 22] .

(141)

We can then use Lemma 6 where

Nt =

t - 

2 2

+

3L3t-1

t-1 - t-2

22,

M1(t, t) = 0

M2(t, t) = 3

F (t) - F (t, t)

2 2

+

6

F (t-1) - F (t-1, t-1)

2 2

+3

F (t-2) - F (t-2, t-2)

2 2

t = F (t) - F (t, t)

zt = t .

By Assumption 1, M2 = 122 and by the fact that
E[F (t) - F (t, t) |t, 0, . . . , t-1] = E[E[F (t) - F (t, t) |t]|0, . . . , t-1] = 0 the hypothesis of Lemma 6 hold and we get,

E[ErrR(¯T )]



R2 ST

+

132 2ST

T -1
t2
t=0

(142)

F.4 PROOF OF THEOREM 5

Theorem 5 has been introduced in §D. This theorem is about Algorithm 5 which consists in another way to implement extrapolation to SGD. Let us first restate this theorem,

Theorem' 5. Assume that t - 0  R, t  0 where (t)t0 are the iterates of Alg. 5. Under Assumption 1 and 4, for any T  1, Alg. 5 with constant step-size   1 has the following
2L
convergence properties:

E[ErrR(¯T )]



R2 T

+

2 

+ 4L2(4R2 2

+ 2)

Particularly, t

=

 T

gives E[ErrR(¯T )] 

O(1) .
T

where

¯ T

d=ef

1 T

T -1
t .

t=0

Proof of Thm.5. Let any    such that 0 -  2  R. Then, the update rules become

t+1 = the proof

P(t - tF (t, t)) of Thm. 3 by applying

and t Lemma

= P(t - F (t, t)). 2 for (, u,  , ) = (t,

We start the -F (t, t),

same way as , t+1) and

(, u,  , +) = (t, -tF (t, t), t+1, t),

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t+1 - ) -

t+1 - t

2 2

t - t+1

2 2



t - t+1

2 2

-

2t

F

(t

,

t

)

(t - t+1) -

t - t

2 2

Then, summing them we get

t+1 - 

2 2



leading to

t - 

2 2

-

2tF

(t,

t)

(t+1 - )

- 2tF (t, t) (t - t+1) -

t - t

2 2

-

t+1 - t

2 2

(143)

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - )

+ 2t(F (t, t) - F (t, t))

(t - t+1) -

t - t

2 2

-

t+1 - t

2 2

27

Under review as a conference paper at ICLR 2019

Then with 2a

b

a

2 2

+

b

2 2

we

get

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t

)

(t - )

+t2

F (t, t) - F (t, t)

2 2

-

t - t

2 2

Using the Lipschitzness assumption we get

t+1 - 

2 2



t - 

2 2

-

2tF

(t,

t)

(t - ) + (t2L2 - 1)

t - t

2 2

Then we add 2tF (t) (t - ) in both sides to get,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

- 2t(F (t, t) - F (t))

(t - ) + (t2L2 - 1)

t - t

2 2

(144)

Here, unfortunately we cannot use Lemma 6 because F (t, t) is biased. We will then deal with the quantity A = (F (t, t) - F ( )) (t - ) . We have that,

A = (F (t, t) - F (t, t)) ( - t) + (F (t) - F (t)) ( - t) + (F (t, t) - F (t)) (t - t) + (F (t, t) - F (t)) ( - t)
 2L t - t 2 t -  2 + F (t, t) - F (t) t - t 2 + (F (t, t) - F (t)) ( - t) (Using Cauchy-Schwarz and the L-Lip of F )

Then using 2 a

b



a

2 2

+

1 

b 22, for  = 4,

-2t(F (t, t) - F (t))

(t

-

)



1 2

t - t

2 + 8t2L2

t - 

2 2

+ 4t2

F (t, t) - F (t)

2 2

1 +
4

t - t

2 2

+

2t(F

(t,

t)

-

F

(t))

( - t)

leading to,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

+

2t(F

(t,

t)

-

F

(t))

( - t)

+

(t2L2

-

1 4

)

t - t

2 2

+ 4t2(2L2

t - 

2 2

+

F (t, t) - F (t) 22)

If one assumes finally that

t - 0

2  R (assumption of the theorem) and that t 

1 2L

we get,

2tF (t)

(t - ) 

t - 

2 2

-

t+1 - 

2 2

+

2t(F

(t,

t)

-

F

(t))

( - t)

+ 4t2(4L2R2 + F (t, t) - F (t) 22)

where we used that t -  2  t - 0 2 + 0 -  2  2R. Once again this equation is a particular case of Lemma 6 where Nt = t -  22, M1(t, t) = 4(4L2R2 + F (t, t) - F (t) 22), M2(t, t) = 0, zt = t and t = F (t, t) - F (t). By Assumption 1 E[M1(t, t)]  16L2R2 + 42 and E[t|t, 0, . . . , t-1] = E[E[t|t]|0, . . . , t-1] = 0 so we can use Lemma 6 and get,

E[ErrR(¯T )]



R2 ST

+

2

+ 16L2R2 2ST

+ 42

T -1
t2 .
t=0

(145)

28

Under review as a conference paper at ICLR 2019

 Distance to the optimum

Gradient Vector Field and Trajectory

3

2

1

0

-1

-2 Start

-3 -2 -1

0

1

2



3

30 25 20 15 10 5 0
0

Training Curves
Simultaneous  = 0.1 Alternated  = 0.1 Averaging  = 0.1 Extrapolation from the Past  = 0.7 Extrapolation  = 0.7

200 400 600 800
Number of Iterations

1000

Figure 5: Comparison of five algorithms (described in Section 3) on the non-convex gan objective (146), using the optimal step-size for each method. Left: The gradient vector field and the dynamics of the different methods. Right:The distance to the optimum as a function of the number of iterations for each methods.

G ADDITIONAL EXPERIMENTAL RESULTS

G.1 TOY NON-CONVEX GAN (2D AND DETERMINISTIC)

We now consider a task similar to (Mescheder et al., 2018) where the discriminator is linear

D() = T , the generator is a Dirac distribution at , q =  and the distribution we try to match is also a Dirac at , p =  . The minimax formulation from Goodfellow et al. (2014)

gives:

min max - log 1 + e-T  - log 1 + eT 

(146)



Note that as observed by Nagarajan and Kolter (2017), this objective is concave-concave, making it hard to optimize. We compare the methods on this objective where we take  = -2, thus the position of the equilibrium is shifted towards the position (, ) = (-2, 0). The convergence and the gradient vector field are shown in Figure 5. We observe that depending on the initialization some methods can fail to converge but extrapolation (18) seem to perform better than the rest of the methods.

29

Under review as a conference paper at ICLR 2019

66

55

Inception Score Inception Score

44

3

AltAdam5  = 1 · 10-3

2 SimAdam  = 1 · 10-3 PastExtraAdam  = 1 · 10-3

ExtraAdam  = 1 · 10-3

1

0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00

Number of generator updates

×105

(a) learning rate of 10-3

3

AltAdam5  = 1 · 10-4

2 SimAdam  = 1 · 10-4 PastExtraAdam  = 1 · 10-4

ExtraAdam  = 1 · 10-4

1

0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00

Number of generator updates

×105

(b) learning rate of 10-4

Figure 6: Inception score on CIFAR10 for WGAN-GP over number of generator updates for different learning rates. We can see that AvgExtraSGD is less sensitive to the choice of learning rate.

G.2 COMPARISON OF THE METHODS WITH THE SAME LEARNING RATE
In this section we compare how the methods presented in §7 perform with the same step-size. We follow the same protocol as in the experimental section §7. In Figure 6 we plot the inception score provided by each training method as a function of the number of generator updates. Note that these plots advantage AltAdam5 a bit because each iteration of this algorithm is a bit more costly (since it perform 5 discriminator updates for each generator update). Nevertheless, the goal of this experiment is not to show that AltAdam5 is faster but to show that that ExtraAdam is less sensitive to the choice of learning rate and can be used with higher learning rates with less degradation.
The same way in Figure 7 we compare the sample quality on the WGAN-GP experiment of AltAdam5 and AvgExtraAdam for different step-sizes. We notice that for AvgExtraAdam the sample quality do not significantly change whereas the sample quality of AltAdam5 seems to be really sensitive to step-size tunning.
We think that robustness to step-size tuning is a key property for an optimization algorithm in order to save as much time as possible to tune other hyperparameters of the learning procedure such as regularization.

30

Under review as a conference paper at ICLR 2019

(a) AvgExtraAdam with  = 10-3

(b) AvgExtraAdam with  = 10-4

(c) AltAdam with  = 10-3

(d) AltAdam with  = 10-4

Figure 7: Comparison of the samples quality on the WGAN-GP experiment for different methods and learning rate .

31

Under review as a conference paper at ICLR 2019

Inception Score

6.0

5.5

5.0

4.5

4.0

3.5

3.0 2.5 2.0
0.00

AltAdam5  = 1 · 10-4 SimAdam  = 1 · 10-4 PastExtraAdam  = 1 · 10-4 ExtraAdam  = 1 · 10-4

0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00

Number of generator updates

×105

(a) with averaging

Inception Score

6.0

5.5

5.0

4.5

4.0

3.5

3.0 2.5 2.0
0.00

AltAdam5  = 1 · 10-4 SimAdam  = 1 · 10-4 PastExtraAdam  = 1 · 10-4 ExtraAdam  = 1 · 10-4

0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00

Number of generator updates

×105

(b) without averaging

Figure 8: Inception Score on CIFAR10 for WGAN over number of generator updates with and without averaging. We can see that averaging improve the inception score.

Inception Score

6.5

6.0

5.5

5.0

4.5

4.0

3.5 3.0 2.5 2.0
0

AltAdam5  = 1 · 10-4 SimAdam  = 1 · 10-4 PastExtraAdam  = 1 · 10-4 ExtraAdam  = 5 · 10-4

1234
Number of generator updates

5
×105

(a) with averaging

Inception Score

6.5

6.0

5.5

5.0

4.5

4.0

3.5 3.0 2.5 2.0
0

AltAdam5  = 1 · 10-4 SimAdam  = 1 · 10-4 PastExtraAdam  = 1 · 10-4 ExtraAdam  = 5 · 10-4

1234
Number of generator updates

5
×105

(b) without averaging

Figure 9: Inception score on CIFAR10 for WGAN-GP over number of generator updates

G.3 COMPARISON OF THE METHODS WITH AND WITHOUT AVERAGING
In this section we compare how uniform averaging improve the performance of the methods presented in §7. We follow the same protocol as in the experimental section §7. In Figure 8 and 9, we plot the inception score provided by each training method as a function of the number of generator updates with and without averaging.
We notice that uniform averaging seems to improve the inception score, nevertheless it looks like the sample are a bit more blurry (see Figure 10) this is confirmed by our result (Figure 11) on the Fréchet Inception Distance (FID) which is more sensitive to blurriness.

32

Under review as a conference paper at ICLR 2019

(a) AvgPastExtraSGD without averaging

(b) AvgPastExtraSGD with averaging

(c) AltSGD without averaging

(d) AltSGD with averaging

Figure 10: Comparison of the samples of a WGAN trained with the different methods with and without averaging. Although averaging improves the inception score, the samples seem more blurry

FID

Convergence on CIFAR10 of WGAN 120
ReExtraAdam

110 AvgReExtraAdam ExtraAdam

100 AvgExtraAdam SimAdam

90

AvgSimAdam AltAdam5

80 AvgAltAdam5

70

60

50

40 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00

Number of Generator iterations

×104

Figure 11: The Fréchet Inception Distance (FID) from Heusel et al. (2017) computed using 50,000 samples, on the WGAN experiments. ReExtraAdam refers to Alg. 5 introduced in §D. We can see that averaging performs worse than when comparing with the Inception Score. We observed that the samples generated by using averaging are a little more blurry and that the FID is more sensitive to blurriness, thus providing an explanation for this observation.

33

