Under review as a conference paper at ICLR 2019
DIMINISHING BATCH NORMALIZATION
Anonymous authors Paper under double-blind review
ABSTRACT
In this paper, we propose a generalization of the BN algorithm, diminishing batch normalization (DBN), where we update the BN parameters in a diminishing moving average way. Batch normalization (BN) is very effective in accelerating the convergence of a neural network training phase that it has become a common practice. Our proposed DBN algorithm remains the overall structure of the original BN algorithm while introduces a weighted averaging update to some trainable parameters. We provide an analysis of the convergence of the DBN algorithm that converges to a stationary point with respect to trainable parameters. Our analysis can be easily generalized for original BN algorithm by setting some parameters to constant. To the best knowledge of authors, this analysis is the first of its kind for convergence with Batch Normalization introduced. We analyze a two-layer model with arbitrary activation function. The primary challenge of the analysis is the fact that some parameters are updated by gradient while others are not. The convergence analysis applies to any activation function that satisfies our common assumptions. For the analysis, we also show the sufficient and necessary conditions for the stepsizes and diminishing weights to ensure the convergence. In the numerical experiments, we use more complex models with more layers and ReLU activation. We observe that DBN outperforms the original BN algorithm on Imagenet, MNIST, NI and CIFAR-10 datasets with reasonable complex FNN and CNN models.
1 INTRODUCTION
Deep neural networks (DNN) have shown unprecedented success in various applications such as object detection. However, it still takes a long time to train a DNN until it converges. Ioffe & Szegedy identified a critical problem involved in training deep networks, internal covariate shift, and then proposed batch normalization (BN) to decrease this phenomenon. BN addresses this problem by normalizing the distribution of every hidden layer's input. In order to do so, it calculates the preactivation mean and standard deviation using mini-batch statistics at each iteration of training and uses these estimates to normalize the input to the next layer. The output of a layer is normalized by using the batch statistics, and two new trainable parameters per neuron are introduced that capture the inverse operation. It is now a standard practice Bottou et al. (2016); He et al. (2016). While this approach leads to a significant performance jump, to the best of our knowledge, there is no known theoretical guarantee for the convergence of an algorithm with BN. The difficulty of analyzing the convergence of the BN algorithm comes from the fact that not all of the BN parameters are updated by gradients. Thus, it invalidates most of the classical studies of convergence for gradient methods.
In this paper, we propose a generalization of the BN algorithm, diminishing batch normalization (DBN), where we update the BN parameters in a diminishing moving average way. It essentially means that the BN layer adjusts its output according to all past mini-batches instead of only the current one. It helps to reduce the problem of the original BN that the output of a BN layer on a particular training pattern depends on the other patterns in the current mini-batch, which is pointed out by Bottou et al.. By setting the layer parameter we introduce into DBN to a specific value, we recover the original BN algorithm.
We give a convergence analysis of the algorithm with a two-layer batch-normalized neural network and diminishing stepsizes. We assume two layers (the generalization to multiple layers can be made by using the same approach but substantially complicating the notation) and an arbitrary loss function. The convergence analysis applies to any activation function that follows our common
1

Under review as a conference paper at ICLR 2019
assumption. The main result shows that under diminishing stepsizes on gradient updates and updates on mini-batch statistics, and standard Lipschitz conditions on loss functions DBN converges to a stationary point. As already pointed out the primary challenge is the fact that some trainable parameters are updated by gradient while others are updated by a minor recalculation.
Contributions. The main contribution of this paper is in providing a general convergence guarantee for DBN. Specifically, we make the following contributions.
· In section 4, we show the sufficient and necessary conditions for the stepsizes and diminishing weights to ensure the convergence of BN parameters.
· We show that the algorithm converges to a stationary point under a general nonconvex objective function.
This paper is organized as follows. In Section 2, we review the related works and the development of the BN algorithm. We formally state our model and algorithm in Section 3. We present our main results in Sections 4. In Section 5, we numerically show that the DBN algorithm outperforms the original BN algorithm. Proofs for main steps are collected in the Appendix.
2 LITERATURE REVIEW
Before the introduction of BN, it has long been known in the deep learning community that input whitening and decorrelation help to speed up the training process. In fact, Orr & Mu¨ller show that preprocessing the data by subtracting the mean, normalizing the variance, and decorrelating the input has various beneficial effects for back-propagation. Krizhevsky et al. propose a method called local response normalization which is inspired by computational neuroscience and acts as a form of lateral inhibition, i.e., the capacity of an excited neuron to reduce the activity of its neighbors. Gu¨lc¸ehre & Bengio propose a standardization layer that bears significant resemblance to batch normalization, except that the two methods are motivated by very different goals and perform different tasks.
Inspired by BN, several new works are taking BN as a basis for further improvements. Layer normalization Ba et al. (2016) is much like the BN except that it uses all of the summed inputs to compute the mean and variance instead of the mini-batch statistics. Besides, unlike BN, layer normalization performs precisely the same computation at training and test times. Normalization propagation that Arpit et al. uses data-independent estimations for the mean and standard deviation in every layer to reduce the internal covariate shift and make the estimation more accurate for the validation phase. Weight normalization also removes the dependencies between the examples in a minibatch so that it can be applied to recurrent models, reinforcement learning or generative models Salimans & Kingma (2016). Cooijmans et al. propose a new way to apply batch normalization to RNN and LSTM models.
Given all these flavors, the original BN method is the most popular technique and for this reason our choice of the analysis. To the best of our knowledge, we are not aware of any prior analysis of BN.
BN has the gradient and non-gradient updates. Thus, nonconvex convergence results do not immediately transfer. Our analysis explicitly considers the workings of BN. However, nonconvex convergence proofs are relevant since some small portions of our analysis rely on known proofs and approaches.
Neural nets are not convex, even if the loss function is convex. For classical convergence results with a nonconvex objective function and diminishing learning rate, we refer to survey papers Bertsekas (2011); Bertsekas & Tsitsiklis (2000); Bottou et al. (2016). Bertsekas & Tsitsiklis provide a convergence result with the deterministic gradient with errors. Bottou et al. provide a convergence result with the stochastic gradient. The classic analyses showing the norm of gradients of the objective function going to zero date back to Grippo (1994); Polyak & Tsypkin (1973); Polyak (1987). For strongly convex objective functions with a diminishing learning rate, we learn the classic convergence results from Bottou et al..
2

Under review as a conference paper at ICLR 2019

3 MODEL AND ALGORITHM

The optimization problem for a network is an objective function consisting of a large number of component functions, that reads:

N
min f¯(, ) = fi(Xi : , ),
i=1
subject to   P,   Q,

(1)

where fi : Rn1 × Rn2  R, i = 1, ..., N , are real-valued functions for any data record Xi. Index i associates with data record Xi and target response yi (hidden behind the dependency of f on i) in the training set. Parameters  include the common parameters updated by gradients directly associated
with the loss function, i.e., behind the part that we have a parametric model, while BN parameters  are introduced by the BN algorithm and not updated by gradient methods but by the mini-batch statistics. We define that the derivative of fi is always taken with respect to :

fi(Xi : , ) := fi(Xi : , ).

(2)

The deep network we analyze has 2 fully-connected layers with D1 neurons each. The techniques presented can be extended to more layers with additional notation. Each hidden layer computes y = a(W u) with activation function a(·) and u is the input vector of the layer. We do not need to
include an intercept term since the BN algorithm automatically adjusts for it. BN is applied to the
output of the first hidden layer.

Figure 1: The structure of our batch-normalized network model in the analysis.

We next describe the computation in each layer to show how we obtain the output of the network. The notations introduced here is used in the analysis. Figure 1 shows the full structure of the network. The input data is vector X, which is one of {Xi}Ni=1. Vector  = (µj)jD=1, (j)Dj=1 is the set of all BN parameters and vector  = W1, W2, (j(1))Dj=1, (j(1))jD=1 is the set of all trainable
parameters which are updated by gradients.
Matrices W1, W2 are the actual model parameters and ,  are introduced by BN. The value of jth neuron of the first hidden layer is

zj(1)(X : ) = a(W1,j,·X),

(3)

where W1,j,· denotes the weights of the linear transformations for the jth neuron. The jth entry of batch-normalized output of the first layer is

yj(1)(X : , ) = j(1)

zj(1)(X : ) - µj j + B

+ j(1),

3

Under review as a conference paper at ICLR 2019

where j(1) and j(1) are trainable parameters updated by gradient and µj and j are batch normalization parameters for zj(1). Trainable parameter µj is the mini-batch mean of zj(1) and trainable parameter j is the mini-batch sample deviation of zj(1). Constant B keeps the denominator from zero. The output of jth entry of the output layer is:

zj(2)(X : ) = a W2,j,· j(1)

zj(1)(X : ) - µj j + B

+ j(1)

(4)

The objective function for the ith sample is

fi(Xi : , ) = li zj(2)(Xi : , ) j ,

(5)

where li(·) is the loss function associated with the target response yi. For sample i, we have the following complete expression for the objective function:



D
fi(Xi : , ) = li a( W2,k,j
j=1

j(1)

a(W1,j,·Xi - j + B

µj )

+

j(1)

)k .

(6)

Function fi(Xi : , ) is nonconvex with respect to  and .

3.1 ALGORITHM
Algorithm 1 shows the algorithm studied herein. There are two deviations from the standard BN algorithm, one of them actually being a generalization. We use the full gradient instead of the more popular stochastic gradient (SG) method. It essentially means that each batch contains the entire training set instead of a randomly chosen subset of the training set. An analysis of SG is potential future research. Although the primary motivation for full gradient update is to reduce the burdensome in showing the convergence, the full gradient method is similar to SG in the sense that both of them go through the entire training set, while full gradient goes through it deterministically and the SG goes through it in expectation. Therefore, it is reasonable to speculate that the SG method has similar convergence property as the full algorithm studied herein.

Algorithm 1 DBN: Diminishing Batch-Normalized Network Update Algorithm

1: Initialize   Rn1 and   Rn2

2: for iteration m=1,2,... do

3:

(m+1) := (m) - (m)

N i=1

fi(Xi

:

(m), (m))

4: for j=1,...,D1 do

5:

µ(jm+1)

:=

1 N

N i=1

zj(1)(Xi

:

(m+1))

6:

j(m+1) :=

1 N

N i=1

zj(1)(Xi : (m+1)) - µ(jm+1) 2

7: (m+1) := (m+1) (µ(jm+1))jD=11, (j(m+1))jD=11 + (1 - (m+1))(m)

The second difference is that we update the BN parameters (, ) by their moving averages with respect to diminishing (m). The original BN algorithm can be recovered by setting (m) = 1 for every m. After introducing diminishing (m), (m) and hence the output of the BN layer is determined by the history of all past data records, instead of those solely in the last batch. Thus, the output of the BN layer becomes more general that better reflects the distribution of the entire dataset. We use two strategies to decide the values of (m). One is to use a constant smaller than 1 for all m, and the other one is to decay the (m) gradually, such as (m) = 1/m.
In our numerical experiment, we show that Algorithm 1 outperforms the original BN algorithm, where both are based on SG and non-linear activation functions with many layers FNN and CNN models.
4

Under review as a conference paper at ICLR 2019

4 GENERAL CASE
The main purpose of our work is to show that Algorithm 1 converges. In the general case, we focus on the nonconvex objective function.

4.1 ASSUMPTIONS Here are the assumptions we used for the convergence analysis.

Assumption 1 (Lipschitz continuity on  and ). For every i we have
fi(X : ~, ) - fi(X : ^, ) 2  L¯ ~ - ^ 2, ~, ^, , X.
W1,j,· fi(X : ~, ) - W1,j,· fi(X : ^, ) 2  L¯ W~ 1,j,· - W^ 1,j,· 2, , ~, ^, X, j  {1, ..., D1}.
fi(X : , ~) - fi(X : , ^) 2  L¯ ~ - ^ 2, , ~, ^, X, j  {1, ..., D1}.

(7) (8) (9)

Noted that the Lipschitz constants associated with each of the above inequalities are not necessarily the same. Here L¯ is an upper bound for these Lipschitz constants for simplicity.

Assumption 2 (bounded parameters). Sets P and Q are compact set, where   P and   Q. Thus, there exists a constant M that weights W and parameters  are bounded element-wise by this constant M .
W1 M and W2 M and  M.

This also implies that the updated ,  in Algorithm 1 remain in P and Q, respectively.

Assumption 3 (diminishing update on ). The stepsizes of  update satisfy


(m) =  and ((m))2 < .

m=1

m=1

(10)

This is a common assumption for diminishing stepsizes in optimization problems.

Assumption 4 (Lipschitz continuity of li(·)). Assume the loss functions li(·) for every i is continuously differentiable. It implies that there exists M^ such that
li(x) - li(y)  M^ x - y , x, y.
Assumption 5 (existence of a stationary point). There exists a stationary point (, ) such that f¯(, ) = 0.

We note that all these are standard assumptions in convergence proofs. We also stress that Assumption 4 does not directly imply 1. Since we assume that P and Q are compact, then Assumptions 1, 4 and 5 hold for many standard loss function such as softmax and MSE.

Assumption 6 (Lipschitz at activation function). The activation function a(·) is Lipschitz with con-

stant k:

|a(x)|  k x

(11)

Since for all activation function there is a(0) = 0, the condition is equivalent to |a(x) - a(0)|  k x - 0 . We note that this assumption works for many popular choices of activation functions,
such as ReLU and LeakyReLu.

5

Under review as a conference paper at ICLR 2019

4.2 CONVERGENCE ANALYSIS
We first have the following lemma specifying sufficient conditions for  to converge. Proofs for main steps are given in the Appendix.

Theorem 7 Under Assumptions 1, 2, 3 and 6, if {(m)} satisfies

 m

(m) <  and

(m)(n) < ,

m=1

m=1 n=1

then sequence {(m)} converges to ¯.

We give a discussion of the above conditions for (m) and (m) at the end of this section. With the help of Theorem 7, we can show the following convergence result.

Lemma 8 Under Assumptions 4, 5 and the assumptions of Theorem 7, when

 i
(i)(n) <  and


(n) < ,

m=1 i=m n=1

m=1 n=m

we have

M

lim sup

(m)

f¯((m), ¯)

2 2

<

.

M  m=1

(12) (13)

This result is similar to the classical convergence rate analysis for the non-convex objective function with diminishing stepsizes, which can be found in Bottou et al. (2016).

Lemma 9 Under the assumptions of Lemma 8, we have

lim inf
m

f¯((m), ¯)

2 2

=

0.

(14)

This theorem states that for the full gradient method with diminishing stepsizes the gradient norms cannot stay bounded away from zero. The following result characterizes more precisely the convergence property of Algorithm 1.

Lemma 10 Under the assumptions stated in Lemma 8, we have

lim
m

f¯((m), ¯)

2 2

=

0.

(15)

Our main result is listed next.

Theorem 11 Under the assumptions stated in Lemma 8, we have

lim
m

f¯((m), (m))

2 2

= 0.

(16)

We cannot show that {(m)}'s converges (standard convergence proofs are also unable to show such a stronger statement). For this reason, Theorem 11 does not immediately follow from Lemma 10 together with Theorem 7. The statement of Theorem 11 would easily follow from Lemma 10 if the convergence of {(m)} is established and the gradient being continuous.

Considering

the

cases

(m)

=

O(

1 mk

)

and

(m)

=

O(

1 mh

).

We

show

in

the

Appendix

that

the

set

of sufficient and necessary conditions to satisfy the assumptions of Theorem 7 are h > 1 and k  1.

The set of sufficient and necessary conditions to satisfy the assumptions of Lemma 8 are h > 2

and

k



1.

For

example,

we

can

pick

(m)

=

O(

1 m

)

and

(m)

=

O

(

1 m2.001

)

to

achieve

the

above

convergence result in Theorem 11.

6

Under review as a conference paper at ICLR 2019
5 COMPUTATIONAL EXPERIMENTS
We conduct the computational experiments with Theano and Lasagne on a Linux server with a Nvidia Titan-X GPU. We use MNIST LeCun et al. (1998), CIFAR-10 Krizhevsky & Hinton (2009) and Network Intrusion (NI) kdd (1999) datasets to compare the performance between DBN and the original BN algorithm. For the MNIST dataset, we use a four-layer fully connected FNN (784 × 300 × 300 × 10) with the ReLU activation function and for the NI dataset, we use a four-layer fully connected FNN (784 × 50 × 50 × 10) with the ReLU activation function. For the CIFAR-10 dataset, we use a reasonably complex CNN network that has a structure of (Conv-Conv-MaxPool-DropoutConv-Conv-MaxPool-Dropout-FC-Dropout-FC), where all four convolution layers and the first fully connected layers are batch normalized. We use the softmax loss function and l2 regularization with for all three models. All the trainable parameters are randomly initialized before training. For all 3 datasets, we use the standard epoch/minibatch setting with the minibatch size of 100, i.e., we do not compute the full gradient and the statistics are over the minibatch. We use AdaGrad Duchi, John and Hazan, Elad and Singer (2011) to update the learning rates (m) for trainable parameters, starting from 0.01. We use two different strategies to decide the values of (m) in DBN: constant values of (m) and diminishing (m) where (m) = 1/m and (m) = 1/m2. We test the choices of constant (m)  {1, 0.75, 0.5, 0.25, 0.1, 0.01, 0.001, 0}.

(a) (b)

(c)

Figure 2: Comparison of predicted accuracy on test datasets for different choices of (m). From left to right are FNN on MNIST, FNN on NI and CNN on CIFAR-10.

(a) (b) (c) Figure 3: Comparison of predicted accuracy on test datasets for the most efficient choices of (m). From left to right are FNN on MNIST, FNN on NI and CNN on CIFAR-10.
7

Under review as a conference paper at ICLR 2019

(a) (b) (c)
Figure 4: Comparison of the convergence of the loss function value on the validation set for different choices of (m). From left to right are FNN on MNIST, FNN on NI and CNN on CIFAR-10.

We test all the choices of (m) with the performances presented in Figure 2. Figure 2 shows that all the non-zero choices of (m) converge properly. The algorithms converge without much difference even when (m) in DBN is very small, e.g., 1/m2. However, if we select (m) = 0, the algorithm is erratic. Besides, we observe that all the non-zero choices of (m) converge at a similar rate. The fact that DBN keeps the batch normalization layer stable with a very small (m) suggests that the BN parameters do not have to be depended on the latest minibatch, i.e., the original BN.
We compare a selected set of the most efficient choices of (m) in Figures 3 and 4. They show that DBN with (m) < 1 is more stable than the original BN algorithm. The variances with respect to epochs of the DBN algorithm are smaller than those of the original BN algorithms in each figure.

Table 1: Best results for different choices of (m) on each dataset, showing the top three with a heat map.

Model
(m) = 1 (m) = 0.75 (m) = 0.5 (m) = 0.25 (m) = 0.1 (m) = 0.01 (m) = 0.001 (m) = 1/m (m) = 1/m2 (m) = 0

MNIST
2.70% 1.91% 1.84% 1.91% 1.90% 1.94% 1.95% 2.10% 2.00% 24.27%

Test Error NI CIFAR-10

7.69% 7.37% 7.46% 7.24% 7.36% 7.47% 7.43% 7.45% 7.59% 26.09%

17.31% 17.03% 17.11% 17.00% 17.10% 16.82% 16.28% 17.26% 17.23% 79.34%

Table 1 shows the best result obtained from each choice of (m). Most importantly, it suggests that the choices of (m) = 1/m and 1/m2 perform better than the original BN algorithm. Besides, all the constant less-than-one choices of (m) perform better than the original BN, showing the importance of considering the mini-batch history for the update of the BN parameters. The BN algorithm in each figure converges to similar error rates on test datasets with different choices of (m) except for the (m) = 0 case. Among all the models we tested, (m) = 0.25 is the only one that performs top 3 for all three datasets, thus the most robust choice.
To summarize, our numerical experiments show that the DBN algorithm outperforms the original BN algorithm on the MNIST, NI and CIFAT-10 datasets with typical deep FNN and CNN models.
Future Directions. On the analytical side, we believe an extension to more than 2 layers is doable with significant augmentations of the notation. A stochastic gradient version is likely to be much more challenging to analyze. A second open question concerns more general activation functions. It would be interesting to analyze other activation functions, such as Sigmoid, that do not apply to our current assumptions.
8

Under review as a conference paper at ICLR 2019

REFERENCES

KDD Cup 1999 Data, 1999. kdd-cup-1999/Data.

URL http://www.kdd.org/kdd-cup/view/

Devansh Arpit, Yingbo Zhou, Bhargava U. Kota, and Venu Govindaraju. Normalization Propagation: A Parametric Technique for Removing Internal Covariate Shift in Deep Networks. In International Conference on Machine Learning, volume 48, pp. 11, 2016.

Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E. Hinton. Layer Normalization. arXiv preprint arXiv:1607.06450, 2016.

Dimitri P. Bertsekas. Incremental gradient, subgradient, and proximal methods for convex optimization: A Survey. Optimization for Machine Learning, 2010(3):1­38, 2011.

Dimitri P. Bertsekas and John N. Tsitsiklis. Gradient Convergence in Gradient Methods with Errors. SIAM Journal on Optimization, 10:627­642, 2000.

Le´on Bottou, Frank E. Curtis, and Jorge Nocedal. Optimization Methods for Large-Scale Machine Learning. arXiv preprint arXiv:1606.04838, 2016.

Tim Cooijmans, Nicolas Ballas, Ce´sar Laurent, and Aaron Courville. Recurrent Batch Normalization. arXiv preprint arXiv:1603.09025, 2016.

Yoram Duchi, John and Hazan, Elad and Singer. Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12(Jul):2121­2159, 2011.

L. Grippo. A Class of Unconstrained Minimization Methods for Neural Network Training. Optimization Methods and Software, 4(2):135­150, 1994.

C¸ aglar Gu¨lc¸ehre and Yoshua Bengio. Knowledge Matters: Importance of Prior Information for Optimization. Journal of Machine Learning Research, 17(8):1­32, 2016.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep Residual Learning for Image Recognition. In Computer Vision and Pattern Recognition, pp. 770­778, dec 2016.

Sergey Ioffe and Christian Szegedy. Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift. In International Conference on Machine Learning, pp. 448­456, 2015.

Alex Krizhevsky and Geoffrey E. Hinton. Learning Multiple Layers of Features from Tiny Images. PhD thesis, 2009.

Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. Imagenet Classification with Deep Convolutional Neural Networks. In Advances in neural information processing systems, pp. 1097­1105, 2012.

Yann LeCun, Le´on Bottou, and Yoshua Bengio. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278­2324, 1998.

Genevieve B. Orr and Klaus-Robert Mu¨ller. Neural Networks: Tricks of the Trade. Springer, New York, 2003.

B. T. Polyak. Introduction to optimization. Translations series in mathematics and engineering. Optimization Software, 1987.

B. T. Polyak and Y. Z. Tsypkin. Pseudogradient Adaption and Training Algorithms. Automation and Remote Control, 34:45­67, 1973.

Tim Salimans and Diederik P. Kingma. Weight Normalization: A Simple Reparameterization to Accelerate Training of Deep Neural Networks. In Advances in Neural Information Processing Systems, pp. 901­901, 2016.

9

Under review as a conference paper at ICLR 2019

6 APPENDIX: PROOFS

6.1 PRELIMINARY RESULTS

The following proofs are shortened to corporate with AAAI submission page limit.

Proposition 12 There exists a constant M such that, for any  and fixed , we have

f¯(, )

2 2



M.

Proof. By Assumption 5, we know there exists (, ) such that f¯(, ) 2 = 0. Then we have f¯(, ) 2
= f¯(, ) 2 - f¯(, ) 2 + f¯(, ) 2 - f¯(, ) 2  f¯(, ) - f¯(, ) 2 + f¯(, ) - f¯(, ) 2

N
 fi(Xi : , ) - fi(Xi : , ) 2
i=1

N
+ fi(Xi : , ) - fi(Xi : , ) 2

i=1
N L¯(  -  2 +  -  2),

where the last inequality is by Assumption 1. We then have

f¯(, )

2 2

 N 2L¯2(

 - 

2+

 -  2)2  M,

because sets P and Q are compact by Assumption 2.

(17) (18) (19)

Proposition 13 We have

fi(X

: ~, )  fi(X

: ^, ) + fi(X

: ^, )T (~ - ^) +

1 L¯ 2

~ - ^

22, ~, ^, X.

(20)

Proof. This is a known result of the Lipschitz-continuous condition that can be found in Bottou et al. (2016). We have this result together with Assumption 1.

6.2 PROOF OF THEOREM 7

Lemma 14 When

 m=1

(m)

<



and

 m=1

m n=1

(m)  (n)

<

,

µ~(jm)

:=

µ(jm) (1 - (1))(1 - (2))...(1 - (m))

is a

Cauchy series.

Proof. By Algorithm 1, we have

µj(m)

=

(m) 1 N

N
a(W1(,mj,)·Xi) + (1 - (m))µj(m-1).

i=1

(21)

We define ~(m)

:=

(m) (1 - (1))(1 - (2))...(1 - (m))

and W1(,mj,)·

:=

W1(,mj,)· - W1(,mj,-· 1).

After dividing

equation 21 by (1 - (1))(1 - (2))...(1 - (m)), we obtain

µ~(jm)

=

~(m)

1 N

N
a(W1(,mj,)·Xi) + µ~(jm-1).

i=1

(22)

Then we have

|µ~(jm)

-

µ~j(m-1) |



~(m)|k|

1 N

Nm
| W1(,nj),·Xi|

i=1 n=1

= ~(m)|k| 1 N m N
i=1 n=1

N

(n)

W1,j,· fl(Xl : (n), (n))

l=1

· Xi

= ~(m)|k| 1 N m N
i=1 n=1

(n)

N
W1,j,· fl(Xl : (n), (n))
l=1

· Xi

10

Under review as a conference paper at ICLR 2019

 ~(m)|k| 1 N m N
i=1 n=1

N

(n)

W1,j,· fl(Xl : (n), (n)) · Xi

l=1

Nm

 ~(m)|k|

(n) L¯ · ( W1(,nj),· - W1,j,· 2 + j(n,·) - j,· 2) · Xi 2

i=1 n=1

mN

 ~(m)

(n) |k|

2L¯M Xi 2

n=1

i=1

m

 ~(m)

(n)M~ L¯,M .

n=1

Equation equation 6.2 is due to W1(,mi,)j = Therefore,

m n=1

W1(,ni,)j

.

(23) (24) (25) (26)

qm

|µ~(jp) - µ~j(q)|  M~ L¯,M ·

~(m)(n).

m=p n=1

(27)

It remains to show that


(m) < ,
m=1
m
(m)(n) < ,
m=1 n=1

(28) (29)

implies the convergence of {µ~(m)}. By (28), we have m=1(1 - (m)) > 0, since ln(m=1(1 - (m))) >

 m=1

-(m)

>

-.

It is also easy to show that there exists C and Mc such that for all m  Mc, we have

(1 - (1))(1 - (2)) . . . (1 - (m))  C.

(30)

Therefore, lim (1 - (1))(1 - (2)) . . . (1 - (m))  C. m

Thus the following holds: and

~(m)  1 (m) C

q

m ~(m)(n)  1 q

m
(m)  (n) .

C

m=p n=1

m=p n=1

(31) (32)

From equation 29 and equation 32 it follows that the sequence {µ~j(m)} is a Cauchy series.

Lemma 15 Since {µ~(jm)} is a Cauchy series, {µj(m)} is a Cauchy series.

Proof.

We

know

that

µ(jm)

=

µ~(jm) (1 - (1) )...(1 - (m) ).

Since

lim
m

µ~(jm)



µ~j

and

lim (1-(1))...(1-
m

(m))



C~,

we

have

lim
m

µj(m)



µ~j

·

C~.

Thus

µ(jm)

is

a

Cauchy

series.

Lemma 16 If

 m=1

(m)

<



and

 m=1

m n=1

(m)  (n)

<

,

{j(m)}

is

a

Cauchy

series.

Proof. We define j(m) := ~j(m)(1 - (1))...(1 - (m)). Then we have

|~j(m+1) - ~j(m)| = ~(m)

1N N

a(W1(,mj,)·Xi) - µj(m) 2

i=1

11

Under review as a conference paper at ICLR 2019

= ~(m) |k| N

N

a(W1(,mj,)·Xi) - µ(jm)

2
.

kk

i=1

(33)

Since {µj(m)} is convergent, there exists c1, c2 and N1 such that for any m > N1, - < c1 < µ(jm) < c2 < . For any C¯  c1 , c2 , we have
kk

|~j(m+1) - ~j(m)|

 ~(m) |k| N

·

N a(W1(,mj,)·Xi) - C¯ 2 k
i=1

(34)

 ~(m) |k| · N

N | a(W1(,mj,)·Xi) | + |C¯| 2 k
i=1

(35)

 ~(m) |k| · N

Nm

2

(n) 2N L¯M Xi 2 + |C¯|

i=1 n=1

(36)

 ~(m) |k| · N

m2

N · M~ L¯,M

(n) + |C¯|

n=1

(37)

m

= ~(m)|k| · M~ L¯,M

(n) + |C¯| .

n=1

Inequality equation 35 is by the following fact:
n
(ai - c)2 
i=1

n
(|ai| + |c|)2,
i=1

(38) (39)

where b and ai for every i are arbitrary real scalars. Besides, equation 39 is due to -2aic  max{-2|ai|c, 2|ai|c}.

Inequality equation 36 follow from the square function being increasing for nonnegative numbers. Besides these facts, equation 36 is also by the same techniques we used in equation 23-equation 25 where we bound the derivatives with the Lipschitz continuity in the following inequality:

N
W1,j,· fl(Xl : (n), (n))  2N L¯M.
l=1

(40)

Inequality equation 37 is by collecting the bounded terms into a single bound M~ L¯,M . Therefore,

q-1

m

|~j(q) - ~j(p)| 

~(m)|k| · M~ L¯,M

(n) + |C¯| .

m=p

n=1

(41)

Using the similar methods in deriving equation 28 and equation 29, it can be seen that a set of sufficient

conditions ensuring the convergence for {~j(m)} is:

 m=1

(m)

<



and

 m=1

m n=1

(m)  (n)

<

.

Therefore, the convergence conditions for {j(m)} are the same as for {µ(jm)}.

It is clear that these lemmas establish the proof of Theorem 7.

6.3 CONSEQUENCES OF THEOREM 7

Proposition 17 Under the assumptions of Theorem 7, we have |(m) - ¯|  am, where

i



am = M1

(i)(j) + M2

(i).

i=m j=1

i=m

M1 and M2 are constants.

(42)

12

Under review as a conference paper at ICLR 2019

Proof. For the upper bound of j(m), by equation 38, we have

q-1

|~j(q) - ~j(p)| 

~(m)|k|

m=p

We

define ~j

:=

(1

-

(1)

¯j )...(1

-

(u)

)...

.

Therefore,

m

M~ L¯,M

(n) + |C¯|

n=1

.

i

|~j - ~j(m)| 

~(i)|k| M~ L¯,M

(j) + |C¯|

i=m

j=1

 |k|  (i) C
i=m

i

M~ L¯,M

(j) + |C¯|

j=1

.

(43)

The first inequality comes by substituting p by m and by taking lim as q   in equation 41. The second inequality comes from equation 30. We then obtain,

j(m) - ¯j



~j(m) - ~j()

+

(1

-

¯j (1))...(1

-

(m))

-

~j()

= ~j(m) - ~j()

+

¯j -

¯j

(1 - (1))...(1 - (m)) (1 - (1))...(1 - (u))...

= ~j(m) - ~j()

+ ¯j

(1 - (m+1))...(1 - (u))... - 1 (1 - (1))...(1 - (u))...



~j(m) - ~j()

+ ¯j |1 - (1 - (m+1))...(1 - (u))...| C



~j(m) - ~j()

+ ¯j C


(n).

n=m+1

(44)

The second inequality is by (1 - (1))...(1 - (m)) < 1, the third inequality is by equation 30 and the last inequality can be easily seen by induction. By equation 44, we obtain

|¯j

-

j(m) |

=

Mlim|j(M )

-

j(m) |



|~j

-

~j(m)|

+

¯j C


(n).

n=m+1

(45)

Therefore, we have

|¯j

-

j(m) |



|~j

-

~j(m)|

+

¯j C


(n)

n=m+1


 ~(i)|k| ·
i=m

i

M~ L¯,M

(j) + |C¯|

j=1

+ ¯j


(i)

C

i=m+1




1 (i)|k| ·

C

i=m

i

M~ L¯,M

(j) + |C¯|

j=1

+ ¯j


(i)

C

i=m+1

(46)

 M~ L¯,M |k| 

i
(i)(j) +

C

i=m j=1

¯j + |k||C¯| CC


(i).
i=m

The first inequality is by equation 45, the second inequality is by equation 41, the third inequality is by equation 31 and the fourth inequality is by adding the nonnegative term ¯j (m) to the right-hand side.
C

For the upper bound of µ(jm), we have

µj(m) - µ¯j

 µ~(m) - µ~() +

µ¯j - µ~() .

(1 - (1))...(1 - (m))

(47)

Let us define Am :=

µ~(m) - µ~()

and Bm :=

(1

-

µ¯j (1))...(1 -

(m))

-

µ~()

.

Recall

from

Theorem

7

that {µj(m)} is a Cauchy series, by equation 27, |µ~j(p) - µ~j(q)|  M¯ L¯,M ·

q m=p

m n=1

(m)  (n) .

Therefore,

the first term in equation 47 is bounded by

i

|µ~j(m) - µ~j|  M~ L¯,M ·

(i)(n) < .

i=m n=1

(48)

13

Under review as a conference paper at ICLR 2019

For the second term in equation 47, recall that C := (1 - (1))...(1 - (u)).... Then we have

C·

(1

-

µ¯j (1))...(1

-

(m))

-

µ~()

 µ¯j



(i),

i=m+1

where the inequality can be easily seen by in-

duction. Therefore, the second term in equation 47 is bounded by

µ¯j

- µ~()  µ¯j


(i).

(1 - (1))...(1 - (m))

C

i=m+1

(49)

From these we obtain

µj(m) - µ¯j


 M~ L¯,M

i (i)(n) + µ¯j C


(i).

i=m n=1

i=m+1

(50)

The first inequality is by equation 47 and the second inequality is by equation 48 and equation 49. Combining equation 46 and equation 50, we have that

i



|(m) - ¯|  M1

(i)(j) + M2

(i),

i=m j=1

i=m

where M1 and M2 are constants defined as M1

=

max(

M~ L¯,M C

|k|

,

M¯ L¯,M

)

and

M2

=

max( ¯j + |k||C¯| , µ¯j ).

CC

Proposition 18 Under the assumptions of Theorem 7,

-f¯((m), ¯)T

· f¯((m), (m))  -

f¯((m), ¯)

2

+

L¯M

 n2am,

where am is defined in Proposition 17.

Proof. For simplicity of the proof, let us define x(m) := f¯((m), ¯), y(m) := f¯((m), (m)). We have

 |x(m) - y(m)|  L¯n2 (m) - ¯   L¯n2am,

(51)

where n2 Proposition

is the dimension of . 17. Inequality equation

The second inequality is by Assumption 1 and the fourth inequality 51 implies that for all m and i, we have |x(im) - yi(m)|  L¯n2am.

is

by

It remains to show

-

yi(m)x(im)  -

xi(m) 2

+

L¯M

 n2am,

i,

m.

ii

(52)

This is established by the following four cases.

1)

If

xi(m)



0, x(im) - yi(m)



0,

then

xi(m)



L¯n2am + yi(m).

Thus

-xi(m) yi(m)



-xi(m)

2

+

L¯M

 n2

am

by Proposition 12.

2) If xi(m)  0, x(im) - yi(m)  0, then xi(m)  yi(m), x(im)2  xi(m) · yi(m) and -x(im)yi(m)  -x(im)2.

3) If x(im) < 0, x(im) - yi(m)  0, then xi(m)  yi(m), xi(m)2  x(im) · yi(m) and -xi(m)yi(m)  -x(im)2.

4) If xi(m) < 0, xi(m) - -yi(m)x(im)  -xi(m)2

-yi(mL¯)n20a,mthxei(nmy)i(m)--xx(imi(m)2)

+L¯L¯Mn2na2ma,my.i(Tmh)xe i(lmas)t

- x(im)2  L¯n2amxi(m) inequality is by Proposition

and 12.

All these four cases yield equation 52.

Proposition 19 Under the assumptions of Theorem 7, we have

f¯((m+1), ¯) f¯((m), ¯) - (m)

f¯((m), ¯)

2 2

+

 (m) L¯ M

 n2

am

+

1 ((m))2 2

·

N L¯M,

where M is a constant and am is defined in Proposition 17.

Proof. By Proposition 13,

fi(Xi : ~, )  fi(Xi

: ^, ) + fi(Xi : ^, )T (~ - ^) +

1 L¯ 2

~ - ^

2 2

.

Therefore, we can sum it over the entire training set from i = 1 to N to obtain

f¯(~, )  f¯(^, ) + f¯(^, )T (~ - ^) +

N L¯ 2

~ - ^

2 2

.

(53) (54)

14

Under review as a conference paper at ICLR 2019

In Algorithm 1, we define the update of  in the following full gradient way:

which implies

N
(m+1) := (m) - (m) · ·fi(Xi : (m), (m)),
i=1
(m+1) - (m) = -(m) · f¯((m), (m)).

(55) (56)

By equation 56 we have ~ - ^ = (m+1) - (m) = -(m)f¯((m), (m)). We now substitute ~ := (m+1), ^ := (m) and  := ¯ into equation 54 to obtain

f¯((m+1), ¯)

f¯((m), ¯) - (m)f¯((m), ¯)T f¯((m), (m)) + ((m))2 · N L¯M

2

f¯((m), ¯) - (m)

f¯((m), ¯)

2 2

+

 (m) L¯ M

 n2am

+ 1 ((m))2 · N L¯M. 2

(57)

The first inequality is by plugging equation 56 into equation 54, the second inequality comes from Proposition 12 and the third inequality comes from Proposition 18.

6.4 PROOF OF THEOREM 11 Here we show Theorem 11 as the consequence of Theorem 7 and Lemmas 8, 9 and 10.

6.4.1 PROOF OF LEMMA 8

Here we show Lemma 8 as the consequence of Lemmas 20, 21 and 22.

Lemma 20 to ensure

 m=1

 i=m

i n=1

(i)  (n)

<



and

 m=1

 n=m

(n)

<



is

a

set

of

sufficient

condition


|¯j - j(m)| < , j.
m=1

(58)

Proof. By plugging equation 45 and equation 43 into equation 58, we have the following for all j:



¯j - j(m) 

m=1

m=1

|~j

-

~j(m)|

+

¯j C


(n)

n=m+1

 |k| · M~ L¯,M




(i)

i

(j) + ¯j + |k||C¯|




(n).

CC

m=1 i=m

j=1

m=1 n=m+1

(59)

It is easy to see that the the following conditions are sufficient for right-hand side of equation 59 to be finite:

 m=1

 i=m

i n=1

(i)  (n)

<



and

 m=1

 n=m

(n)

<

.

Therefore, we obtain


|¯j - j(m)| < , j.
m=1

Lemma 21 Under Assumption 4,

 i
(i)(n) <  and


(n) < 

m=1 i=m n=1
is a set of sufficient conditions to ensure

m=1 n=m

M

lim sup

f¯((m), (m)) - f¯((m), ¯) < .

M  m=1

Proof. By Assumption 4, we have
D
li(x) - li(y)  M^ x - y  M^ |xi - yi|.
i=1

(60)

15

Under review as a conference paper at ICLR 2019

By the definition of fi(·), we then have

f¯((m), (m)) - f¯((m), ¯)

m=1

N
 li(Xi : (m), (m)) - li(Xi : (m), ¯)

m=1 i=1

 DN
M2
m=1 j=1 i=1

a(W1(,mj,)·Xi) - µj(m) - a(W1(,mj,)·Xi) - µ¯j

j(m) + B

¯j + B

D
M3
m=1 j=1

N
|k||W1(,mj,)· Xi |
i=1

¯j - j(m)
2 B

+N

µ¯j - µ(jm) ¯j + B j(m) + B

.

(61) (62) (63) (64)

The first inequality is by the Cauchy-Schwarz inequality, and the second one is by equation 60. To show the finiteness of equation 64, we only need to show the following two statements:



N

|k||W1(,mj,)· Xi |

¯j - j(m)
2

< , j

m=1 i=1

B

and



µ¯j - µj(m)

< , j.

m=1 ¯j + B j(m) + B

Proof of equation 65: For all j we have

(65) (66)



N

|k||W1(,mj,)· Xi |

¯j - j(m)
2

m=1 i=1

B


 |k|N DM max Xi i m=1

1
2

¯j - j(m)

B

=|k|N DM max Xi i

1
2



¯j - j(m) .

B m=1

(67)

The inequality comes from |W1(,mj,)·Xi|  DM Xi 2, where D is the dimension of Xi and M is the elementwise upper bound for W1(,mj,)· in Assumption 2.

Finally, we invoke Lemma 14 to assert that

 m=1

¯j - j(m)

is finite.

Proof of equation 66: For all j we have

 µ¯j - µ(jm) m=1 ¯j + B j(m) + B




µ¯j - µ(jm)

m=1 ¯j + B ¯j + B


+
m=1

µ(jm) -

µj(m)

¯j + B j(m) +

B

.

(68)

The first term in equation 68 is finite since {µ(jm)} is a Cauchy series. For the second term, we know that there
exists a constant M such that for all m  M , µ(jm)  µ¯ + 1. This is also by the fact that {µ(jm)} is a Cauchy series and it converges to µ¯. Therefore, the second term in equation 68 becomes

M -1
m=1 M -1

m=1

µj(m) -

µ(jm)

¯j + B j(m) + B

µ(jm) -

µ(jm)

¯j + B j(m) + B


+

µ(jm) -

µ(jm)

m=M ¯j + B j(m) + B


+ (µ¯ + 1)

1-

1

m=M

¯j + B j(m) + B

.

(69)

11

Noted that function f () =

is Lipschitz continuous since its gradient is bounded by

+ B

2 . Therefore
B

1

we can choose 2 as the Lipschitz constant for f (). We then have the following inequality:

B

16

Under review as a conference paper at ICLR 2019

1-

1

¯j + B j(m) + B



1
2

|¯j

- j(m)|.

B

(70)

Plugging equation 70 into equation 69, we obtain

M -1

µj(m) -

µ(jm)

m=1 ¯j + B j(m) + B

M -1


µ(jm) -

µj(m)

m=1 ¯j + B j(m) + B


+ (µ¯ + 1)
m=M

1 ¯j +

-1 B j(m) +

B

+



(µ¯

+
2

1) |¯j

-

j(m)|,

m=M

B

(71)

where the first term is finite by the fact that M is a finite constant. We have shown the condition for the second term to be finite in Lemma 20. Therefore,



µ¯j - µ(jm)

< , j.

m=1 ¯j + B j(m) + B

By equation 65 and equation 66, we have that the right-hand side of equation 64 is finite. It means that the left-hand side of equation 64 is finite. Thus,

f¯((m), (m)) - f¯((m), ¯) < .
m=1

Lemma 22 If then

 i
(i)(n) < 
m=1 i=m n=1

and


(n) < ,
m=1 n=m

M

lim sup

(m)

f¯((m), ¯)

2 2

<

.

M  m=1

Proof. For simplicity of the proof, we define

M

T (M) :=

(m)

f¯((m), ¯)

2 2

,

m=1

O(m) := f¯((m+1), (m+1)) - f¯((m), (m)),

(1m+1) := f¯((m+1), (m+1)) - f¯((m+1), ¯), 2(m) := f¯((m+1), ¯) - f¯((m), ¯),

where ¯ is the converged value of  in Theorem 7. Therefore,

O(m) = 1(m+1) + (1m) + 2(m)  |1(m+1)| + |(1m)| + (2m).

(72)

By Proposition 19,

(2m)  -(m)

f¯((m), ¯)

2 2

+

(m)

L¯M

 n2

am

+

1 ((m))2 2

·

N L¯M.

(73)

We sum the inequality equation 72 from 1 to K with respect to m and plug equation 73 into it to obtain

KK

KK

O(m) 

|1(m+1)| +

|(1m)| -

{(m) f¯((m), ¯) 22}

m=1

m=1

m=1

m=1

+

K

 (m) L¯ M

 n2am

+

K

{ 1 ((m))2N L¯M } 2

m=1

m=1

KK
= |(1m+1)| + |(1m)| - T (K)

m=1

m=1

+ L¯2n2 ·

K

(m)am +

K { 1 ((m))2N L¯M }. 2

m=1

m=1

(74)

17

Under review as a conference paper at ICLR 2019

From this, we have:

lim sup T (K)  lim sup -1 (f¯((K), (K)) - f¯((1), (1)))

K

K c1

+

lim sup
K

1 c1

K
(|(1m+1)|
m=1

+

|1(m)|)

+

lim

sup

L¯ 2

 n2

K

 (m) am

K

m=1

N L¯K + lim sup

K

(m)

2
.

K 2c1 m=1

(75)

Next we show that each of the four terms in the right-hand side of equation 75 is finite, respectively. For the

first term,

lim sup -1 (f¯((K), (K)) - f¯((1), (1))) <  K c1

(76)

is by the fact that the parameters {, } are in compact sets, which implies that the image of fi(·) is in a bounded set.

For the second term, we showed its finiteness in Lemma 21.

For the third term, by equation 42, we have

K
lim sup (m)am
K m=1

K
= lim sup (m)
K m=1

i



K1

(i)(j) + K2

(i)

i=m j=1

i=m

K
=K1 lim sup (m)
K m=1

i
(i)  (j )
i=m j=1

K

+ K2 lim sup

(m)

(i).

K m=1

i=m

(77)

The right-hand side of equation 77 is finite because


(m)
m=1

i
(i)  (j )
i=m j=1


<
m=1

i
(i)  (j )
i=m j=1

<

(78)

and





(m)

(i) <

(i) < .

(79)

m=1

i=m

m=1 i=m

The second inequalities in equation 78 and equation 79 come from the stated assumptions of this lemma.

For the fourth term,

N L¯M lim sup

K
(m)2 < 

K

2c m=1

holds, because we have

 m=1

(

(m) )2

<

 in Assumption

 m=1

(m)

f¯((m), ¯)

2 2

<



holds.

3.

(80) Therefore, T () =

In Lemmas 20, 21 and 22, we show that {(m)} and {µ(m)} are Cauchy series, hence Lemma 8 holds.

6.4.2 PROOF OF LEMMA 9

This proof is similar to the the proof by Bertsekas & Tsitsiklis (2000).

Proof. By Theorem 8, we have

If there exists a

M

lim sup

(m)

f¯((m), ¯)

2 2

<

.

M  m=1

> 0 and an integer m¯ such that

f¯((m), ¯) 2 

(81)

18

Under review as a conference paper at ICLR 2019

for all m  m¯ , we would have

MM

lim inf
M 

(m)

f¯((m), ¯)

2 2



lim inf
M 

2

(m) = 

m=m¯

m=m¯

which contradicts equation 81. Therefore, lim inf f¯((m), ¯) 2 = 0. m

(82)

6.4.3 PROOF OF LEMMA 10

Lemma 23 Let Yt, W, t and Zt be three sequences such that Wt is nonnegative for all t. Assume that

Yt+1  Yt - Wt + Zt, t = 0, 1, ...,

(83)

and and

that the series

 t=0

Wt

<

.

T t=0

Zt

converges

as

T



.

Then

either

Yt





or

else

Yt

converges

to

a

finite

value

This lemma has been proven by Bertsekas & Tsitsiklis (2000).

Lemma 24 When

 i
(i)(n) <  and


(n) < ,

m=1 i=m n=1

m=1 n=m

it follows that f¯((m), ¯) converge to a finite value.

(84)

Proof. By Proposition 19, we have

f¯((m+1), ¯) f¯((m), ¯) - (m)

f¯((m), ¯)

2 2

+

 (m) L¯ M

 n2

am

+

1 ((m))2 2

·

N L¯M.

(85)

Let Y (m) := f¯((m), ¯), W (m) := (m)

f¯((m), ¯)

2 2

and

Z (m)

:=

 (m) L¯ M

 n2

am

+

1 ((m))2·N L¯M . 2

By equation 10 and equation 77- equation 79, it is easy to see that

M m=0

Z (m)

converges

as

M



.

Therefore, by Lemma 23, Y (m) converges to a finite value. The infinite case can not occur in our setting due

to Assumptions 1 and 2.

Lemma 25 If

 m=1

 i=m

i n=1

(i)  (n)

<



then lim f¯((m), ¯) 2 = 0. m

and

 m=1

 n=m

(n)

<

,

Proof. To show that lim f¯((m), ¯) 2 = 0, assume the contrary; that is, m
lim sup f¯((m), ¯) 2 > 0.
m

Then there exists an > 0 such that f¯((m), ¯) < /2 for infinitely many m and also f¯((m), ¯) > for infinitely many m. Therefore, there is an infinite subset of integers M, such that for each m  M, there exists an integer q(m) > m such that

f¯((m), ¯) < /2,

f¯((i(m)), ¯) > , /2  f¯((i), ¯)  ,

(86)

if m < i < q(m).

From f¯((m+1), ¯) - f¯((m), ¯)  L¯(m) f¯((m), (m)) , it follows that for all m  M that are sufficiently large so that L¯(m) < /4, we have

/4  f¯((m), (m)) .

(87)

Otherwise the condition /2  f¯((m+1), ¯) would be violated. Without loss of generality, we assume that the above relations as well as equation 57 hold for all m  M. With the above observations, we have for all m  M,

19

Under review as a conference paper at ICLR 2019

 f¯(q(m), ¯) - f¯((m), ¯)  L¯ q(m) - (m) 2

q(m)-1

 L¯

(i)( f¯((i), ¯) + f¯((i), (i)) - f¯((i), ¯) )

i=m

= L¯

q(m)-1

(i)

+

L¯ 2

 n2

M1

q(m)-1

(i)



j
(j )  (k)

i=m

i=m

j=m k=1

+

L¯ 2

 n2

M2

q(m)-1

(i)



(j)

i=m

j=m

(88)

The first inequality is by equation 86 and the third one is by the Lipschitz condition assumption. The seventh one is by equation 51. By equation 12, we have for all m  M,

q(m)-1

j

 j

(i) (j)(k) <

(j)(k) < 

(89)

i=m

j=m k=1

i=1 j=i k=1

and

q(m)-1





(i) (j) <

(j) < .

(90)

i=m

j=m

i=1 j=i

It is easy to see that for any sequence {i} with

 i=1

i

<

,

if

follows

that

lim inf
M 

 i=M

i

=

0.

There-

fore, lim inf m

q(m)-1 i=m

(i)

 j=m

j k=1

(j )  (k)

=

0

and

lim inf
m

q(m)-1 i=m

(i)

 j=m

(j)

=

0.

From

this

it follows that

q(m)-1

lim inf
m

(i)



1 2L¯

.

i=m

(91)

By equation

51 and equation 87,

if we pick m



M such that

 L n2am



, 8

we have

Using equation 57, we observe that

f¯(q(m), ¯)

f¯((m), ¯)

. 8

q(m)-1

q(m)-1

 f¯((m), ¯) - c1

2
8

(i) + 1 · N L¯M 2

((i))2, m  M,

i=m

i=m

(92)

where the second inequality is by equation 87. By Lemma 24, f¯(q(m), ¯) and f¯((m), ¯) converge to the

same finite value. Using this convergence result and the assumption m=0((m))2 < , this relation implies that

lim sup

q(m)-1 i=m

(i)

=

0

and

contradicts

equation

91.

m,mM

By Lemmas 23, 24 and 25, we show that Theorem 11 holds.

6.5 DISCUSSIONS OF CONDITIONS FOR STEPSIZES

Here we discuss the actual conditions for (m) and (m) to satisfy the assumptions of Theorem 7 and Lemma

8.

We only consider the cases (m)

=

1 mk

and (m)

=

1 mh

,

but

the

same

analysis

applies

to

the

cases

(m)

=

O(

1 mk

)

and

(m)

=

O(

1 mh

).

6.6 ASSUMPTIONS OF THEOREM 7

For the assumptions of Theorem 7, the first condition

 m=1

(m)

<



requires

h

>

1.

Besides,

the

second

condition



m

(m)(n)  1 h-1



(n)

1 nh-1

=

1 h-1



1 nk+h-1

<

(93)

m=1 n=1

n=1

n=1

requires k + h > 2. The approximation comes from the fact that for every p > 1, we have


k-p 
k=n


k-pdx =
k=n

1

1 -

p

x1-p


=
n

11 p - 1 np-1 .

(94)

20

Under review as a conference paper at ICLR 2019

Since k  1 due to Assumption 3, we conclude that k + h > 2. Therefore, the conditions for (m) and (m) to satisfy the assumptions of Theorem 7 are h > 1 and k  1.

6.7 ASSUMPTIONS OF LEMMA 8

For the assumptions of Theorem 7, the first condition





(n) 



1 mh-1

<



m=1 n=m

m=1

requires h > 2.

Besides, the second condition is

 i



i



(i)(n) =

(i)

(n)  C

(i) < .

m=1 i=m n=1

m=1 i=m

n=1

m=1 i=m

The inequality holds because for any p > 1, we have

n
k-p 
k=1

n
k-pdk =
k=1

1

1 -

p

k1-p

n
=
1

p

1 -

1

(1

-

n1-p)



C

(95)
(96) (97)

Therefore, the conditions for (m) and (m) to satisfy the assumptions of Lemma 8 are h > 2 and k  1.

21

