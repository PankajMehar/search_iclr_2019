Under review as a conference paper at ICLR 2019
TRAINING FOR FASTER ADVERSARIAL ROBUSTNESS VERIFICATION VIA INDUCING RELU STABILITY
Anonymous authors Paper under double-blind review
ABSTRACT
We explore the concept of co-design in the context of neural network verification. Specifically, we aim to train deep neural networks that not only are robust to adversarial perturbations but also whose robustness can be verified more easily. To this end, we identify two properties of network models ­ weight sparsity and socalled ReLU stability ­ that turn out to significantly impact the complexity of the corresponding verification task. We demonstrate that improving weight sparsity alone already enables us to turn computationally intractable verification problems into tractable ones. Then, improving ReLU stability leads to an additional 4­13x speedup in verification times. An important feature of our methodology is its "universality," in the sense that it can be used with a broad range of training procedures and verification approaches.
1 INTRODUCTION
Deep neural networks (DNNs) have recently achieved widespread success in image classification (Krizhevsky et al., 2012), face and speech recognition (Taigman et al., 2014; Hinton et al., 2012), and game playing (Silver et al., 2016; 2017). This success motivates their application in a broader set of domains, including more safety-critical environments. This thrust makes understanding the reliability and robustness of the underlying models, let alone their resilience to manipulation by malicious actors, a central question. However, predictions made by machine learning models are often brittle. A prominent example is the existence of adversarial examples (Szegedy et al., 2014): imperceptibly modified inputs that cause state-of-the-art models to misclassify with high confidence.
There has been a long line of work on both generating adversarial examples, called attacks (Carlini and Wagner, 2017a;b; Athalye et al., 2018a;b; Uesato et al., 2018; Evtimov et al., 2017), and training models robust to adversarial examples, called defenses (Goodfellow et al., 2015; Papernot et al., 2016; Madry et al., 2018; Kannan et al., 2018). However, recent research has shown that most defenses are ineffective (Carlini and Wagner, 2017a; Athalye et al., 2018a; Uesato et al., 2018). Furthermore, even for defenses such as that of Madry et al. (2018) that have seen empirical success against many attacks, we are unable to conclude yet with certainty that they are robust to all attacks that we want these models to be resilient to.
This state of affairs gives rise to the need for verification of networks, i.e., the task of formally proving that no small perturbations of a given input can cause it to be misclassified by the network model. Although many exact verifiers1 have been designed to solve this problem, the verification process is often intractably slow. For example, when using the Reluplex verifier of Katz et al. (2017), even verifying a small MNIST network turns out to be computationally infeasible. Thus, addressing this intractability of exact verification is the primary goal of this work.
Our Contributions Our starting point is the observation that, typically, model training and verification are decoupled and seen as two distinct steps. Even though this separation is natural, it misses a key opportunity: the ability to align these two stages. Specifically, applying the principle of co-design during model training is possible: training models in a way to encourage them to be simultaneously robust and easy-to-exactly-verify. This insight is the cornerstone of the techniques we develop in this paper.
1Also sometimes referred to as combinatorial verifiers.
1

Under review as a conference paper at ICLR 2019

In this work, we use the principle of co-design to develop training techniques that give models that are both robust and easy-to-verify. Our techniques rely on improving two key properties of networks: weight sparsity and ReLU stability. Specifically, we first show that natural methods for improving weight sparsity during training, such as 1-regularization, give models that can already be verified much faster than current methods. This speedup happens because in general, exact verifiers benefit from having fewer variables in their formulations of the verification task. For instance, for exact verifiers that rely on linear programming (LP) solvers, sparser weight matrices means fewer variables in those constraints.
We then focus on the major speed bottleneck of current approaches to exact verification of ReLU networks: the need of exact verification methods to "branch," i.e., consider two possible cases for each ReLU (ReLU being active or inactive). Branching drastically increases the complexity of verification. Thus, well-optimized verifiers will tend to avoid branching on a ReLU if it can determine that the ReLU is stable, i.e. that the ReLU will always be active or always be inactive for any perturbation of an input. This motivates the key goal of the techniques presented in this paper: we aim to minimize branching by maximizing the number of stable ReLUs. We call this goal ReLU stability and introduce a regularization technique to induce it.
Our techniques enable us to train weight-sparse and ReLU stable networks for MNIST and CIFAR10 that can be verified significantly faster. Specifically, by combining natural methods for inducing weight sparsity with a robust adversarial training procedure (cf. Goodfellow et al. (2015)), we are able to train networks for which almost 90% of inputs can be verified in an amount of time that is small2 compared to previous verification techniques. Then, by also adding our regularization technique for inducing ReLU stability, we are able to train models that can be verified an additional 4­13x times as fast while maintaining state-of-the-art accuracy on MNIST. Our techniques show similar improvements for exact verification of CIFAR models. In particular, we achieve the following verification speed and provable robustness results for  norm-bound adversaries:

Dataset MNIST CIFAR

Epsilon
= 0.1 = 0.2 = 0.3
= 2/255 = 8/255

Provable Adversarial Accuracy
94.33% 89.79% 80.68%
45.93% 20.27%

Average Solve Time (s)
0.49 1.13 2.78
13.50 22.33

Our network for = 0.1 on MNIST achieves provable adversarial accuracies comparable with the current best results of Wong et al. (2018) and Dvijotham et al. (2018), and our results for = 0.2 and
= 0.3 achieve the best provable adversarial accuracies yet. To the best of our knowledge, we also achieve the first nontrivial provable adversarial accuracy results using exact verifiers for CIFAR-10.
Finally, we design our training techniques with universality as a goal. We focus on improving the input to the verification process, regardless of the verifier we end up using. This is particularly important because research into network verification methods is still in its early stages, and our codesign methods are compatible with the best current verifiers (LP/MILP-based methods) and should be compatible with any future improvements in verification.
2 BACKGROUND AND RELATED WORK
Exact verification of networks has been the subject of many recent works (Katz et al., 2017; Ehlers, 2017; Carlini et al., 2017; Tjeng et al., 2017; Lomuscio and Maganti, 2017; Cheng et al., 2017a). To understand the context of these works, observe that for linear networks, the task of exact verification is relatively simple and can be done by solving a LP. For more complex models, the presence of nonlinear ReLUs makes verification over all perturbations of an input much more challenging. This is so as ReLUs can be active or inactive depending on the input, which can cause exact verifiers to "branch" and consider these two cases separately. The number of such cases that verifiers have to consider might grow exponentially with the number of ReLUs, so verification speed will also grow exponentially in the worst case. Katz et al. (2017) further illustrated the difficulty of exact
2We chose our time budget for verification to be 120 seconds per input image.

2

Under review as a conference paper at ICLR 2019

verification by proving that it is NP-complete. In recent years, formal verification methods were developed to verify networks. Most of these methods use satisfiability modulo theory (SMT) solvers (Katz et al., 2017; Ehlers, 2017; Carlini et al., 2017) or LP and Mixed-Integer Linear Programming (MILP) solvers (Tjeng et al., 2017; Lomuscio and Maganti, 2017; Cheng et al., 2017a). However, all of them are limited by the same issue of scaling poorly with the number of ReLUs in a network, making them prohibitively slow in practice for even medium-sized models.
One recent approach for dealing with the inefficiency of exact verifiers is to focus on certification methods3 (Wong and Kolter, 2018; Wong et al., 2018; Dvijotham et al., 2018; Raghunathan et al., 2018; Mirman et al., 2018; Sinha et al., 2018). In contrast to exact verification, these methods do not solve the verification task directly; instead, they rely on solving a relaxation of the verification problem by overapproximating the adversarial polytope, or the space of outputs of a network for a region of possible inputs. Certification approaches train models in a specific manner to make certifying those models easier, and they can attain provable adversarial accuracy results quickly. However, certification is fundamentally different from verification in two primary ways. First, it solves a relaxation of the original verification problem. As a result, certification methods can fail to certify many inputs that are actually robust to perturbations ­ only exact verifiers, given enough time, can give conclusive answers on robustness for every single input. Second, certification approaches fall under the paradigm of co-training, where models must be trained and optimized for a specific certification method in order for that certification step to work well. When used as a black box on arbitrary models, the certification step can yield a high rate of false negatives. For example, Raghunathan et al. (2018) found that their certification method was significantly less effective when used on a model trained using Wong and Kolter (2018)'s training method, and vice versa. In contrast, we design our methods to be universal. They can be combined with any standard training procedure for networks and will improve exact verification speed for any LP/MILP-based exact verifier. Similar to most of the certification methods, our technique can be made to have very little training time overhead.

3 TRAINING VERIFIABLE NETWORK MODELS

We begin by discussing the task of verifying a network and identify two key properties of networks that lead to improved verification speed: weight sparsity and so-called ReLU stability. We then use natural regularization methods for inducing weight sparsity as well as a new regularization method for inducing ReLU stability. Finally, we demonstrate that these methods significantly speed up verification while maintaining state-of-the-art accuracy.

3.1 VERIFYING ADVERSARIAL ROBUSTNESS OF NETWORK MODELS

Deep neural network models. Our focus will be on the most common architecture for state-ofthe-art models: k-layer fully-connected feed-forward DNN classifiers with ReLU non-linearities4.
Such models can be viewed as a function f (·, W ), where W = (W1, W2, . . . , Wk-1) represents the weight matrices of each layer. For an input x, the output f (x, W ) of the DNN is defined as:

z0 = x z^i = zi-1Wi + bi zi = max(z^i, 0) f (x, W ) = z^k-1

for i = 1, 2, . . . , k - 1 for i = 1, 2, . . . , k - 2

(1) (2) (3) (4)

Here, for each layer i, we let z^ij denote the jth ReLU pre-activation and let z^ij(x) denote the value of z^ij on an input x. z^k-1 is the final, output layer with an output unit for each possible label (the logits). The network will make predictions by selecting the label with the largest logit.

Adversarial robustness. For a network to be reliable, it should make predictions that are robust ­ that is, it should predict the same output for inputs that are very similar. Specifically, we want the DNN classifier's predictions to be robust to a set Adv(x) of possible adversarial perturbations

3These works use both "verification" and "certification" to describe their methods. For clarity, we use "certification" to describe their approaches, while we use "verification" to describe exact verification approaches.
4Note that this encompasses common convolutional network architectures because convolutional layers can be represented as fully-connected layers.

3

Under review as a conference paper at ICLR 2019
of an input x. We focus on  norm-bound adversarial perturbations, where Adv(x) = {x : ||x - x||  } for some constant , since it is the most common one considered in adversarial robustness and verification literature (thus, it currently constitutes a canonical benchmark).
Verification of network models. For an input x with correct label y, a perturbed input x can cause a misclassification if it makes the logit of some incorrect label y^ larger than the logit of y on x . We can thus express the task of finding an adversarial perturbation as the optimization problem:
min f (x , W )y - f (x , W )y^
x ,y^
subject to x  Adv(x)
An adversarial perturbation exists if and only if the objective of the optimization problem is negative.
Adversarial accuracies. We define the true adversarial accuracy of a model to be the fraction of test set inputs for which the model is robust to all allowed perturbations. By definition, evaluations against specific adversarial attacks like PGD or FGSM provide an upper bound to this accuracy, while certification methods provide lower bounds. Given sufficient time for each input, an exact verifier can prove robustness to perturbations, or find a perturbation where the network makes a misclassification on the input, and thus exactly determine the true adversarial accuracy. This is in contrast to certification methods, which solve a relaxation of the verification problem and can not exactly determine the true adversarial accuracy no matter how much time they have.
However, such exact verification may take impractically long for certain inputs, so we instead compute the provable adversarial accuracy, which we define as the fraction of test set inputs for which the verifier can prove robustness to perturbations within an allocated time budget (timeout). Similarly to certifiable accuracy, this accuracy constitutes a lower bound on the true adversarial accuracy. A model can thus, e.g., have high true adversarial accuracy and low provable adversarial accuracy if verification of the model is too slow and often fails to complete before timeout.
Also, in our evaluations, we chose to use the MILP exact verifier of Tjeng et al. (2017) when performing experiments, as it is both open source and the fastest verifier we are aware of.
3.2 WEIGHT SPARSITY AND ITS IMPACT ON VERIFICATION SPEED
The first property of network models that we want to improve in order to speed up exact verification of those models is weight sparsity. Weight sparsity is important for verification speed because many exact verifiers rely on solving LP or MILP systems, which benefit from having fewer variables. We use two natural regularization methods for improving weight sparsity: 1-regularization and small weight pruning. These techniques significantly improve verification speed ­ see Table 1. Verifying even small MNIST networks is almost completely intractable without them. Specifically, the verifier can only prove robustness of an adversarially-trained model on 19% of inputs with a one hour budget per input, while the verifier can prove robustness of an adversarially-trained model with 1-regularization and small weight pruning on 89.13% of inputs with a 120 second budget per input.
Interestingly, even though adversarial training improves weight sparsity (see Appendix B) it was still necessary to use 1-regularization and small weight pruning. These techniques further promoted weight sparsity and gave rise to networks that were much easier to verify.
3.3 RELU STABILITY
Next, we target the primary speed bottleneck of exact verification: the number of ReLUs the verifier has to branch on. In our paper, this corresponds to the notion of inducing ReLU stability. Before we describe our methodology, we formally define ReLU stability.
Given an input x, a set of allowed perturbations Adv(x), and a ReLU, exact verifiers may need to branch based on the possible pre-activations of the ReLU, namely z^ij(Adv(x)) = {z^ij(x ) : x  Adv(x)} (cf. (2)). If there exist two perturbations x , x in the set Adv(x) such that sign(z^ij(x )) = sign(z^ij(x )), then the verifier has to consider that for some perturbed inputs the ReLU is active (zij = z^ij) and for other perturbed inputs inactive (zij = 0). The more such cases the verifier faces, the more branches it has to consider, causing the complexity of verification to increase exponentially. Intuitively, a model with 1000 ReLUs among which only 100 ReLUs require
4

Under review as a conference paper at ICLR 2019

Dataset Epsilon

Training Method

Test Set Provable Adversarial

Average

Accuracy

Accuracy Solve Time (s)

MNIST

1 Adversarial Training

= 0.1

2 3

+ 1-Regularization +Small Weight Pruning

4 +ReLU Pruning (control)

99.17% 99.00% 98.99% 98.94%

19.00% 82.17% 89.13% 91.58%

2970.43 21.99 11.71 6.43

Table 1: Improvement in provable adversarial accuracy and verification solve times when incrementally adding natural regularization methods for improving weight sparsity and ReLU stability into the model training procedure, before verification occurs. Each row represents the addition of another method ­ for example, Row 3 uses adversarial training, 1-regularization, and small weight pruning. Row 4 adds ReLU pruning (see Appendix A). Row 4 is the control model for MNIST and = 0.1 that we present again in comparisons in Tables 2 and 3. We use a 3600 instead of 120 second timeout for Row 1 and only verified the first 100 images (out of 10000) because verifying it took too long.

branching will likely be much easier to verify than a model with 200 ReLUs that all require branching. Thus, it is advantageous for the verifier if, on an input x with allowed perturbation set Adv(x), the number of ReLUs such that

sign(z^ij(x )) = sign(z^ij(x)) x  Adv(x)

(5)

is maximized. We call a ReLU for which (5) holds on an input x a stable ReLU on that input. If (5) does not hold, then the ReLU is an unstable ReLU.

Directly computing whether a ReLU is stable on a given input x is difficult because doing so would
involve considering all possible values of z^ij(Adv(x)). Instead, exact verifiers compute an upper bound u^ij and a lower bound ^lij of z^ij(Adv(x)). If 0  ^lij or u^ij  0, they can replace the ReLU with the identity function or the zero function, respectively. Otherwise, if ^lij < 0 < u^ij, these verifiers then determine that they need to "branch" on that ReLU. Thus, we can rephrase (5) as

sign(u^ij) = sign(^lij)

(6)

We will discuss methods for determining these upper and lower bounds u^ij, ^lij in Section 3.3.2.

3.3.1 A REGULARIZATION TECHNIQUE FOR INDUCING RELU STABILITY: RS LOSS
As we see from equation (6), a function that would indicate exactly when a ReLU is stable is F (u^ij, ^lij) = sign(u^ij) · sign(^lij). Thus, it would be natural to use this function as a regularizer. However, this function is non-differentiable and if used in training a model, would provide no useful gradients during back-propagation. Thus, we use the following smooth approximation of F  (see Fig. 1) which provides the desired gradients:
F (u^ij, ^lij) = - tanh(1 + u^ij · ^lij)

Figure 1: Plot and contour plot of the function F (x, y) = - tanh(1 + x · y)
We call the corresponding objective RS Loss, and show in Fig. 2a that using this loss function as a regularizer effectively decreases the number of unstable ReLUs. RS Loss thus encourages ReLU stability, which, in turn, speeds up exact verification - see Fig. 2b.
5

Under review as a conference paper at ICLR 2019

3.3.2 ESTIMATING RELU UPPER AND LOWER BOUNDS ON ACTIVATIONS
A key aspect of using RS Loss is determining the upper and lower bounds u^ij, ^lij for each ReLU (cf. (6)). The bounds for the inputs z0 (cf. (1)) are simple ­ for the input x, we know x -  z0  x + , so u^0 = x - , ^l0 = x + . For all subsequent zij, we estimate bounds using either the naive interval arithmetic (IA) approach described in Tjeng et al. (2017) or an improved version of it. The improved version is a tighter estimate but uses more memory and training time, and thus is most effective on smaller networks. We present the details of naive IA and improved IA in Appendix C.
Interval arithmetic approaches can be implemented relatively efficiently and work well with backpropagation because they only involve matrix multiplications. This contrasts with how exact verifiers compute these bounds, which usually involves solving LPs or MILPs. Interval arithmetic also overestimates the number of unstable ReLUs. This means that minimizing unstable ReLUs based on IA bounds will provide an upper bound on the number of unstable ReLUs determined by exact verifiers. In particular, IA will properly penalize every unstable ReLU.
Improved IA performs well in practice, overestimating the number of unstable ReLUs by less than 0.4% in the first 2 layers of MNIST models and by less than 36.8% (compared to 128.5% for naive IA) in the 3rd layer. Full experimental results are available in Table 4 of Appendix C.3.

3.3.3 IMPACT OF RELU STABILITY IMPROVEMENTS ON VERIFICATION SPEED
We provide experimental evidence that RS Loss regularization improves ReLU stability and speeds up average verification times by more than an order of magnitude in Fig. 2b. To isolate the effect of RS Loss, we compare MNIST models trained in exactly the same way other than the weight on RS Loss. When comparing a network trained with a RS Loss weight of 5e-4 to a network with a RS Loss weight of 0, the former has just 16% as many unstable ReLUs and can be verified 65x faster. The caveat here is that the former has lower test set accuracy.
We also compare verification speed with and without RS Loss on MNIST networks for different values of (0.1, 0.2, and 0.3) in Fig. 2c. We choose RS Loss weights that cause almost no test set accuracy loss in this case, and we still observe a 4­13x speedup from RS Loss. For CIFAR, RS Loss gives a smaller speedup of 1.6­3.7x (See Appendix E).

Total Unstable ReLUs Solve time (s)
bound on -norm

278 Individual layers: Layer 3 Layer 2 Layer 1
101 74 62 44 20
0 0.00012 0.0002 0.0003 0.0005 0.003 RS Loss weight
(a)

6.43
0.49 0.24 0.15 0.10 0.12 0 0.00012 0.0002 0.0003 0.0005 0.003
RS Loss weight
(b)

0.1 0.49

6.43

Control Solve Time + RS Solve Time

0.2 1.13

9.41

0.3 0

2.78 4

8

11.80
Solve time (s) 12

(c)

Figure 2: (a) Average number of unstable ReLUs by layer and (b) average verification solve times of 6 networks trained with different weights on RS Loss for MNIST and = 0.1 . Averages are taken over all 10000 MNIST test set inputs. Both metrics improve significantly with increasing RS Loss weight. An RS Loss weight of 0 corresponds to the control network, while an RS Loss weight of 0.00012 corresponds to the "+RS" network for MNIST and = 0.1 in Tables 2 and 3. (c) Improvement in the average time taken by a verifier to solve the verification problem after adding RS Loss to the training procedure, for different on MNIST. The weight on RS Loss was chosen so that the the "+RS" models have very similar test set accuracies to the control models.

3.3.4 IMPACT OF RELU STABILITY IMPROVEMENTS ON PROVABLE ADVERSARIAL ACCURACY
As the weight on the RS Loss used in training a model increases, the ReLU stability of the model will improve, speeding up verification and likely improving provable adversarial accuracy. However, like most regularization methods, placing too much weight on RS Loss can decrease the model capacity, potentially lowering both the true adversarial accuracy and the provable adversarial accuracy.

6

Under review as a conference paper at ICLR 2019

Therefore, it is important to choose the weight on RS Loss carefully to obtain both high provable adversarial accuracy and faster verification speeds.
To show the effectiveness of RS Loss in improving provable adversarial accuracy, we train two networks for each dataset and each value of . One is a "control" network that uses all of the natural improvements for inducing both weight sparsity ( 1-regularization and small weight pruning) and ReLU stability (ReLU pruning - see Appendix A). The second is a "+RS" network that uses RS Loss in addition to all of the same natural improvements. This lets us isolate the incremental effect of adding RS Loss to the training procedure.
In addition to attaining a 4­13x speedup in MNIST verification times (see Fig. 2c), we achieve higher provable adversarial accuracy in every single setting when using RS Loss. This is especially notable for the hardest verification problem we tackle ­ proving robustness to perturbations with  norm-bound 8/255 on CIFAR-10 ­ where adding RS Loss nearly triples the provable adversarial accuracy from 7.09% to 20.27%. This improvement is primarily due to verification speedup induced by RS Loss, which allows the verifier to finish proving robustness for far more inputs within the 120 second time limit. These results are shown in Table 2.
Table 2: Provable Adversarial Accuracies for the control and "+RS" networks in each setting.

Control +RS

MNIST, = 0.1
91.58 94.33

MNIST, = 0.2
86.45 89.79

MNIST, = 0.3
77.99 80.68

CIFAR, = 2/255
45.53 45.93

CIFAR, = 8/255
7.09 20.27

4 EXPERIMENTS
4.1 EXPERIMENTS ON MNIST AND CIFAR
In addition to the experimental results already presented, we compare our control and "+RS" networks with the best available results presented in the certifiable defenses of Wong et al. (2018) and Dvijotham et al. (2018). We compare their test set accuracy, PGD adversarial accuracy (an evaluation of robustness against a strong 40-step PGD adversarial attack), and provable adversarial accuracy. Additionally, to show that our method can scale to larger architectures, we also train and verify a "+RS (Large)" network for each dataset and . These results are presented in Table 3.
In terms of provable adversarial accuracies, on MNIST, our results are significantly better than those of Wong et al. (2018) for larger perturbations of = 0.3, and comparable for = 0.1. On CIFAR10, our method is slightly less effective, perhaps indicating that more unstable ReLUs are necessary to properly learn a robust CIFAR classifier. We also experienced many more instances of the verifier reaching its allotted 120 second time limit on CIFAR, especially for the less ReLU stable control networks. Full details are available in Appendix E.
4.2 EXPERIMENTAL METHODS AND DETAILS
In our experiments, we use robust adversarial training (Goodfellow et al., 2015) against a strong adversary as done in Madry et al. (2018) to train various DNN classifiers. For each setting of dataset (MNIST or CIFAR) and , we find a suitable weight on RS Loss via line search (See Table 5 in Appendix D). The same weight is used for each ReLU. During training, we used improved IA for ReLU bound estimation for "+RS" models and use naive IA for "+RS (Large)" models because of memory constraints. For ease of comparison, we trained our networks using the same convolutional DNN architecture as in Wong et al. (2018). This architecture uses two 2x2 strided convolutions with 16 and 32 filters, followed by a 100 hidden unit fully connected layer. For the larger architecture, we also use the same "large" architecture as in Wong et al. (2018). It has 4 convolutional layers with 32, 32, 64, and 64 filters, followed by 2 fully connected layers with 512 hidden units each.
For verification, we used the most up-to-date version of the exact verifier from Tjeng et al. (2017). Model solves were parallelized over 8 CPU cores. When verifying an image, the verifier of Tjeng et al. (2017) uses two steps ­ first, the model-build step, and second, the verification problem solving step. We focus on reporting solve times because that is directly related to the task of verification
7

Under review as a conference paper at ICLR 2019

Table 3: Comparison of test set accuracy, PGD adversarial accuracy, and provable adversarial accuracy of networks trained with and without RS Loss. We also provide the best available certifiable adversarial accuracy and PGD adversarial accuracy of any single models from Wong et al. (2018) and Dvijotham et al. (2018) for comparison, and highlight the best provable accuracy for each . *The provable adversarial accuracy for "+RS (Large)" is only computed for the first 1000 images because the verifier performs more slowly on larger models. **Dvijotham et al. (2018) actually uses a slightly smaller = 0.03 = 7.65/255 for CIFAR.

Dataset MNIST MNIST MNIST CIFAR CIFAR

Epsilon = 0.1 = 0.2 = 0.3 = 2/255 = 8/255

Training Method
Control +RS +RS (Large)*
Wong et al. Dvijotham et al.
Control +RS +RS (Large)*
Control +RS +RS (Large)*
Wong et al.
Control +RS +RS (Large)*
Wong et al.
Control +RS +RS (Large)*
Wong et al. Dvijotham et al.**

Test Set Accuracy
98.94% 98.68% 98.95%
98.92% 98.80%
98.40% 98.10% 98.21%
97.75% 97.33% 97.54%
85.13%
64.64% 61.12% 61.41%
68.28%
50.69% 40.45% 42.81%
28.67% 48.64%

PGD Adversarial Accuracy
95.12% 95.13% 96.58%
97.13%
93.14% 93.14% 94.19%
91.64% 92.05% 93.25%
-
51.58% 49.92% 50.61%
-
31.28% 26.78% 28.69%
32.72%

Provable/Certifiable Adversarial Accuracy
91.58% 94.33% 95.60%
96.33% 95.56%
86.45% 89.79% 89.10%
77.99% 80.68% 59.60%
56.90%
45.53% 45.93% 41.40%
53.89%
7.09% 20.27% 19.80%
21.78% 26.67%

itself. All build times for the control and "+RS" models on MNIST that we presented were between 4 and 10 seconds, and full results on build times are also presented in Appendix E.
Additional details on our experimental setup (e.g. hyperparameters) can be found in Appendix D.
5 CONCLUSION
In this paper, we use the principle of co-design to develop training methods that emphasize verification as a goal, and we show that they make verifying the trained model much faster. We first demonstrate that natural regularization methods already make the exact verification problem significantly more tractable. Subsequently, we introduce the notion of ReLU stability for networks, present a method that improves a network's ReLU stability, and show that this improvement makes verification an additional 4­13x faster. Our method is universal, as it can be added to any training procedure and should speed up any exact verification procedure, especially MILP-based methods.
Prior to our work, exact verification seemed intractable for all but the smallest models. Thus, our work shows progress toward reliable models that can be proven to be robust, and our techniques can help scale verification to even larger networks.
Many of our methods compress our networks into more compact, simpler forms. We hypothesize that the reason that regularization methods like RS Loss can still achieve very high accuracy is that most models are overparametrized in the first place. There exist clear parallels between our methods and techniques in model compression (Han et al., 2016; Cheng et al., 2017b) ­ therefore, we believe that drawing upon additional techniques from model compression can further improve the ease-ofverification of networks. We also expect that there exist objectives other than weight sparsity and ReLU stability that are important for verification speed. If so, further exploring the principle of co-design for those objectives is an interesting future direction.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Anish Athalye, Nicholas Carlini, and David A. Wagner. Obfuscated gradients give a false sense of security: Circumventing defenses to adversarial examples. In International Conference on Machine Learning (ICML), 2018a.
Anish Athalye, Logan Engstrom, Andrew Ilyas, and Kevin Kwok. Synthesizing robust adversarial examples. In International Conference on Machine Learning (ICML), 2018b.
Nicholas Carlini and David Wagner. Adversarial examples are not easily detected: Bypassing ten detection methods. In Proceedings of the 10th ACM Workshop on Artificial Intelligence and Security, AISec '17, pages 3­14, New York, NY, USA, 2017a. ACM. ISBN 978-1-4503-52024. doi: 10.1145/3128572.3140444. URL http://doi.acm.org/10.1145/3128572. 3140444.
Nicholas Carlini and David A. Wagner. Towards evaluating the robustness of neural networks. In IEEE Symposium on Security and Privacy, 2017b.
Nicholas Carlini, Guy Katz, Clark Barrett, and David L. Dill. Ground-truth adversarial examples. CoRR, abs/1709.10207, 2017. URL http://arxiv.org/abs/1709.10207.
Chih-Hong Cheng, Georg Nu¨hrenberg, and Harald Ruess. Maximum resilience of artificial neural networks. CoRR, abs/1705.01040, 2017a. URL http://arxiv.org/abs/1705.01040.
Yu Cheng, Duo Wang, Pan Zhou, and Tao Zhang. A survey of model compression and acceleration for deep neural networks. CoRR, abs/1710.09282, 2017b.
Krishnamurthy Dvijotham, Sven Gowal, Robert Stanforth, Relja Arandjelovic, Brendan O'Donoghue, Jonathan Uesato, and Pushmeet Kohli. Training verified learners with learned verifiers. arXiv preprint arXiv:1805.10265, 2018.
Ru¨diger Ehlers. Formal verification of piece-wise linear feed-forward neural networks. In Deepak D'Souza and K. Narayan Kumar, editors, Automated Technology for Verification and Analysis, pages 269­286, Cham, 2017. Springer International Publishing. ISBN 978-3-319-68167-2.
Ivan Evtimov, Kevin Eykholt, Earlence Fernandes, Tadayoshi Kohno, Bo Li, Atul Prakash, Amir Rahmati, and Dawn Song. Robust physical-world attacks on machine learning models. CoRR, abs/1707.08945, 2017. URL http://arxiv.org/abs/1707.08945.
Ian Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial examples. In International Conference on Learning Representations, 2015. URL http:// arxiv.org/abs/1412.6572.
Song Han, Huizi Mao, and William J. Dally. Deep compression: Compressing deep neural network with pruning, trained quantization and huffman coding. In International Conference on Learning Representations (ICLR), 2016.
G. Hinton, L. Deng, D. Yu, G. E. Dahl, A. r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N. Sainath, and B. Kingsbury. Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups. IEEE Signal Processing Magazine, 29(6):82­97, Nov 2012. ISSN 1053-5888. doi: 10.1109/MSP.2012.2205597.
Harini Kannan, Alexey Kurakin, and Ian J. Goodfellow. Adversarial logit pairing. CoRR, abs/1803.06373, 2018. URL http://arxiv.org/abs/1803.06373.
Guy Katz, Clark Barrett, David L. Dill, Kyle Julian, and Mykel J. Kochenderfer. Reluplex: An efficient smt solver for verifying deep neural networks. In Rupak Majumdar and Viktor Kuncak, editors, Computer Aided Verification, pages 97­117, Cham, 2017. Springer International Publishing. ISBN 978-3-319-63387-9.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International Conference on Learning Representations (ICLR), 2015.
9

Under review as a conference paper at ICLR 2019
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. Imagenet classification with deep convolutional neural networks. In Proceedings of the 25th International Conference on Neural Information Processing Systems - Volume 1, NIPS'12, pages 1097­1105, USA, 2012. Curran Associates Inc. URL http://dl.acm.org/citation.cfm?id=2999134.2999257.
Alessio Lomuscio and Lalit Maganti. An approach to reachability analysis for feed-forward relu neural networks. CoRR, abs/1706.07351, 2017. URL http://arxiv.org/abs/1706. 07351.
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu. Towards deep learning models resistant to adversarial attacks. In International Conference on Learning Representations (ICLR), 2018.
Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for provably robust neural networks. In Jennifer Dy and Andreas Krause, editors, Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pages 3575­3583, Stockholmsmssan, Stockholm Sweden, 10­15 Jul 2018. PMLR. URL http://proceedings.mlr.press/v80/mirman18b.html.
Nicolas Papernot, Patrick D. McDaniel, Xi Wu, Somesh Jha, and Ananthram Swami. Distillation as a defense to adversarial perturbations against deep neural networks. 2016 IEEE Symposium on Security and Privacy (SP), pages 582­597, 2016.
A. Raghunathan, J. Steinhardt, and P. Liang. Certified defenses against adversarial examples. In International Conference on Learning Representations (ICLR), 2018.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. nature, 529(7587):484, 2016.
David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez, Thomas Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of go without human knowledge. Nature, 550(7676):354, 2017.
Aman Sinha, Hongseok Namkoong, and John Duchi. Certifiable distributional robustness with principled adversarial training. In International Conference on Learning Representations (ICLR), 2018.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian J. Goodfellow, and Rob Fergus. Intriguing properties of neural networks. CoRR, abs/1312.6199, 2014. URL http://arxiv.org/abs/1312.6199.
Yaniv Taigman, Ming Yang, Marc'Aurelio Ranzato, and Lior Wolf. Deepface: Closing the gap to human-level performance in face verification. In Proceedings of the 2014 IEEE Conference on Computer Vision and Pattern Recognition, CVPR '14, pages 1701­1708, Washington, DC, USA, 2014. IEEE Computer Society. ISBN 978-1-4799-5118-5. doi: 10.1109/CVPR.2014.220. URL https://doi.org/10.1109/CVPR.2014.220.
Robert Tibshirani. Regression shrinkage and selection via the lasso. Journal of the Royal Statistical Society, Series B, 58:267­288, 1994.
Vincent Tjeng, Kai Xiao, and Russ Tedrake. Verifying neural networks with mixed integer programming. CoRR, abs/1711.07356, 2017. URL http://arxiv.org/abs/1711.07356.
Jonathan Uesato, Brendan O'Donoghue, Aaron van den Oord, and Pushmeet Kohli. Adversarial risk and the dangers of evaluating against weak attacks. In International Conference on Machine Learning (ICML), 2018.
Eric Wong and J. Zico Kolter. Provable defenses against adversarial examples via the convex outer adversarial polytope. In International Conference on Machine Learning (ICML), 2018.
Eric Wong, Frank Schmidt, Jan Hendrik Metzen, and J. Zico Kolter. Scaling provable adversarial defenses. NIPS, 2018.
10

Under review as a conference paper at ICLR 2019

APPENDIX
A NATURAL IMPROVEMENTS
A.1 NATURAL REGULARIZATION FOR INDUCING WEIGHT SPARSITY
All of the control and "+RS" networks in our paper contain natural improvements that improve weight sparsity, which reduce the number of variables in the LPs solved by the verifier. We observed that the two techniques we used for weight sparsity ( 1-regularization and small weight pruning) don't hurt test set accuracy but they dramatically improve provable adversarial accuracy and verification speed.
1. 1-regularization: We use a weight of 2e-5 on MNIST and a weight of 1e-5 on CIFAR. We chose these weights via line search by finding the highest weight that would not hurt test set accuracy.
2. Small weight pruning: Zeroing out weights in a network that are very close to zero. We choose to prune weights less than 1e-3.
A.2 A BASIC IMPROVEMENT FOR INDUCING RELU STABILITY: RELU PRUNING
We also use a basic idea to improve ReLU stability, which we call ReLU pruning. The main idea is to prune away ReLUs that are not necessary.
We use a heuristic to test whether a ReLU in a network is necessary. Our heuristic is to count how many training inputs cause the ReLU to be active or inactive. If a ReLU is active (the pre-activation satisfies z^ij(x) > 0) for every input image in the training set, then we can replace that ReLU with the identity function and the network would behave in exactly the same way for all of those images. Similarly, if a ReLU is inactive (z^ij(x) < 0) for every training image, that ReLU can be replaced by the zero function.
Extending this idea further, we expect that ReLUs that are rarely used can also be removed without significantly changing the behavior of the network. If only a small fraction (say, 10%) of the input images activate a ReLU, then replacing the ReLU with the zero function will only slightly change the network's behavior and will not affect the accuracy too much. We provide experimental evidence of this phenomenon on an adversarially trained ( = 0.1) MNIST model. Conservatively, we decided that pruning away ReLUs that are active on less than 10% of the training set or inactive on less than 10% of the training set was reasonable.

90%

Natural Accuracy PGD Accuracy ( = 0.1)

70%

50%

30%

10%

 Our chosen pruning threshold

0% 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 ReLU Pruning Threshold

Figure 3: Removing some ReLUs does not hurt test set accuracy or accuracy against a PGD adversary

11

Under review as a conference paper at ICLR 2019
B ADVERSARIAL TRAINING AND WEIGHT SPARSITY
It is worth noticing that adversarial training against  norm-bound adversaries alone already makes networks easier to verify by implicitly improving weight sparsity. Indeed, this can be shown clearly in the case of linear networks. Recall that a linear network can be expressed as f (x) = W x + b. Thus, an  norm-bound perturbation of the input x will produce the output
f (x ) = x W + b = xW + b + (x - x)W  f (x) + ||W ||1
where the last inequality is just Ho¨lder's inequality. In order to limit the adversary's ability to perturb the output, adversarial training needs to minimize the ||W ||1 term, which is equivalent to 1regularization and is known to promote weight sparsity (Tibshirani, 1994). Relatedly, Goodfellow et al. (2015) already pointed out that adversarial attacks against linear networks will be stronger when the 1-norm of the weight matrices is higher. Even in the case of nonlinear networks, adversarial training has experimentally been shown to improve weight sparsity. For example, models trained according to Madry et al. (2018) and Wong and Kolter (2018) often learn many weight-sparse layers, and we observed similar trends in the models we trained. However, it is important to note that while adversarial training alone does improve weight sparsity, it is not sufficient by itself for efficient exact verification. Additional regularization like 1-regularization and small weight pruning further promotes weight sparsity and gives rise to networks that are much easier to verify.
12

Under review as a conference paper at ICLR 2019

C INTERVAL ARITHMETIC

C.1 NAIVE INTERVAL ARITHMETIC

Naive IA determines upper and lower bounds for a layer based solely on the upper and lower bounds of the previous layer.

Define W + = max(W, 0), W - = min(W, 0), u = max(u^, 0), and l = max(^l, 0). Then the bounds on the pre-activations of layer i can be computed as follows:

u^i = ui-1Wi+ + li-1Wi- + bi ^li = li-1Wi+ + ui-1Wi- + bi

(7) (8)

As noted in Tjeng et al. (2017) and also Dvijotham et al. (2018), this method is efficient but can lead to relatively conservative bounds for deeper networks.

C.2 IMPROVED INTERVAL ARITHMETIC

We improve upon naive IA by exploiting ReLUs that we can determine to always be active. This allows us to cancel symbols that are equivalent that come from earlier layers of a network.

We will use a basic example of a neural network with one hidden layer to illustrate this idea. Suppose

that we have the scalar input z0 with l0 = 0, u0 = 1, and the network has the following weights and

biases:

W1 = 1

-1 ,

b1 = 2 2 ,

W2 =

1 1

,

b2 = 0

Naive IA for the first layer gives ^l1 = l1 = [2 1], u^1 = u1 = [3 2], and applying naive IA to the output z^2 gives ^l2 = 3, u^2 = 5. However, because ^l1 > 0, we know that the two ReLUs in the
hidden layer are always active and thus equivalent to the identity function. Then, the output is

z^2 = z11 + z12 = z^11 + z^12 = (z0 + 2) + (-z0 + 2) = 4

Thus, we can obtain the tighter bounds ^l2 = u^2 = 4, as we are able to cancel out the z0 terms.

We can write this improved version of IA as follows. First, letting Wk denote row k of matrix W , we can define the "active" part of W as the matrix WA, where

(WA)k =

Wk 0

if ^li-1 > 0 if ^li-1  0

Define the "non-active" part of W as

WN = W - WA
Then, using the same definitions for the notation W +, W -, u, l as before, we can write down the following improved version of IA which uses information from the previous 2 layers.

u^i

=

ui-1Wi

+ N

+

li-1WiN-

+

bi

+ ui-2(Wi-1WiA)+ + li-2(Wi-1WiA)- + bi-1WiA

^li = li-1Wi+N + ui-1Wi-N + bi + li-2(Wi-1WiA)+ + ui-2(Wi-1WiA)- + bi-1WiA

We are forced to to use li-1,j and ui-1,j if we can not determine whether or not the ReLU corresponding to the activation zi-1,j is active, but we use li-2 and ui-2 whenever possible.

We now define some additional notation to help us extend this method to any number of layers. We now seek to define fn, which is a function which takes in four sequences of length n ­ upper bounds, lower bounds, weights, and biases ­ and outputs the current layer's upper and lower bounds.

What we have derived so far from (7) and (8) is the following f1(ui-1, li-1, Wi, bi) = (ui-1Wi+ + li-1Wi- + bi, li-1Wi+ + ui-1Wi- + bi)

13

Under review as a conference paper at ICLR 2019

Let u denote a sequence of upper bounds. Let uz denote element z of the sequence, and let u[z:] denote the sequence without the first z elements. Define notation for l, W, and b similarly.

Then, using the fact that WN Z = (W Z)N and WAZ = (W Z)A, we can show that the following recurrence holds:

fn+1(u, l, W, b) = f1(u1, l1, W1N , b1) + fn(u[1:], l[1:], (W2W1A, W[2:]), (b2W1A, b[2:]))

(9)

Let u(x,y) denote the sequence (ux, ux-1, · · · , uy), and define l(x,y), W(x,y), and b(x,y) similarly. Then, if we want to compute the bounds on layer k using all information from the previous k layers, we simply have to compute fk(u(k-1,0), l(k-1,0), W(k,1), b(k,1)).
From the recurrence 9, we see that using information from all previous layers to compute bounds for layer k takes O(k) matrix-matrix multiplications. Thus, using information from all previous layers to compute bounds for all layers of a d layer neural network only involves O(d2) additional matrix multiplications, which is still reasonable for most DNNs. This method is still relatively efficient because it only involves matrix multiplications ­ however, needing to perform matrix-matrix multiplications as opposed to just matrix-vector multiplications results in a slowdown and higher memory usage when compared to naive IA. We believe the improvement in the estimate of ReLU upper and lower bounds is worth the time trade-off for most networks.

C.3 EXPERIMENTAL RESULTS ON IMPROVED IA AND NAIVE IA
In Table 4, we show empirical evidence that the number of unstable ReLUs in each layer of a MNIST network, as estimated by improved IA, tracks the number of unstable ReLUs determined by the exact verifier quite well. We also present estimates determined via naive IA for comparison.

Dataset Epsilon Training Estimation Method Method

Unstable ReLUs Unstable ReLUs Unstable ReLUs

in 1st Layer

in 2nd Layer

in 3rd Layer

MNIST

Control = 0.1
+RS

Exact

61.14

Improved IA 61.14

Naive IA

61.14

Exact

21.64

Improved IA 21.64

Naive IA

21.64

185.30

31.73

185.96 (+0.4%) 43.40 (+36.8%)

188.44 (+1.7%) 69.96 (+120.5%)

64.73 64.80 (+0.1%) 65.34 (+0.9%)

14.67 18.97 (+29.4%) 33.51 (+128.5%)

MNIST

Control = 0.2
+RS

Exact Improved IA Naive IA
Exact Improved IA Naive IA

17.47 17.47 17.47
29.91 29.91 29.91

142.95 142.95 142.95
54.47 54.47 54.47

37.92 48.88 (+28.9%) 69.75 (+84.0%)
24.05 28.40 (+18.1%) 40.47 (+68.3%)

MNIST

Control = 0.3
+RS

Exact

36.76

Improved IA 36.76

Naive IA

36.76

Exact

24.43

Improved IA 24.43

Naive IA

24.43

83.42

40.74

83.44 (+0.02%) 46.00 (+12.9%)

83.52 (+0.1%) 48.27 (+18.5%)

48.47 48.47 48.47

28.64 31.19 (+8.9%) 32.13 (+12.2%)

Table 4: Comparison between the average number of unstable ReLUs as found by the exact verifier of Tjeng et al. (2017) and the estimated average number of unstable ReLUs found by improved IA and naive IA. We compare these estimation methods on the control and "+RS" networks for MNIST that we described in Section 3.3.4

14

Under review as a conference paper at ICLR 2019

D FULL EXPERIMENTAL SETUP
D.1 NETWORK TRAINING DETAILS
In our experiments, we use robust adversarial training (Goodfellow et al., 2015) against a strong adversary as done in Madry et al. (2018) to train various DNN classifiers. Following the prior examples of Wong and Kolter (2018) and Dvijotham et al. (2018), we introduced a small tweak where we increased the adversary strength linearly from 0.01 to over first half of training and kept it at for the second half. We used this training schedule to improve convergence of the training process.
For MNIST, we trained for 70 epochs using the Adam optimizer (Kingma and Ba, 2015) with a learning rate of 1e-4 and a batch size of 32. For CIFAR, we trained for 250 epochs using the Adam optimizer with a learning rate of 1e-4. When using naive IA, we used a batch size of 128, and when using improved IA, we used a batch size of 16. We used a smaller batch size in the latter case because improved IA incurs high RAM usage during training. To speed up training on CIFAR, we only added in RS Loss regularization in the last 20% of the training process. Using this same sped-up training method on MNIST did not significantly affect the results.

Dataset
MNIST MNIST MNIST CIFAR CIFAR

Epsilon
0.1 0.2 0.3 2/255 8/255

1 weight
2e-5 2e-5 2e-5 1e-5 1e-5

RS Loss weight
12e-5 1e-4 12e-5 1e-3 2e-3

Table 5: Weights chosen using line search for 1 regularization and RS Loss in each setting

For each setting, we find a suitable weight on RS Loss via line search. The same weight is used for each ReLU. The five weights we chose are displayed above in Table 5, along with weights chosen for 1-regularization.
We also train "+RS" models using naive IA to show that our technique for inducing ReLU stability can work while having small training time overhead ­ full details on "+RS (Naive IA)" networks are in Appendix E.
D.2 VERIFIER DETAILS
We used the most up-to-date version of the exact verifier from Tjeng et al. (2017) using the default settings of the code. We allotted 120 seconds for verification of each input datapoint using the default model build settings. We ran our experiments using the commercial Gurobi Solver (version 7.5.2), and model solves were parallelized over 8 CPU cores with Intel Xeon CPUs @ 2.20GHz processors. We used computers with 8­32GB of RAM, depending on the size of the model being verified. All computers used are part of an OpenStack network.

15

Under review as a conference paper at ICLR 2019

E FULL EXPERIMENTAL VERIFICATION RESULTS

Dataset
MNIST MNIST MNIST CIFAR CIFAR

Epsilon
= 0.1 = 0.2 = 0.3 = 2/255 = 8/255

Training Method
Adversarial Training* + 1-regularization +Small Weight Pruning +ReLU Pruning (Control) +RS +RS (Naive IA) +RS (Large)**
Control +RS +RS (Naive IA) +RS (Large)**
Control +RS +RS (Naive IA) +RS (Large)**
Control +RS +RS (Naive IA) +RS (Large)**
Control +RS +RS (Naive IA) +RS (Large)**

Test Set Accuracy
99.17% 99.00% 98.99% 98.94% 98.68% 98.53% 98.95%
98.40% 98.10% 98.08% 98.21%
97.75% 97.33% 97.06% 97.54%
64.64% 61.12% 57.83% 61.41%
50.69% 40.45% 46.19% 42.81%

PGD Adversarial
Accuracy
95.04% 95.25% 95.38% 95.12% 95.13% 94.86% 96.58%
93.14% 93.14% 91.68% 94.19%
91.64% 92.05% 89.19% 93.25%
51.58% 49.92% 47.03% 50.61%
31.28% 26.78% 29.66% 28.69%

Verifier Upper Bound
96.00% 95.98% 94.93% 94.45% 94.38% 94.54% 95.60%
90.71% 89.98% 88.87% 90.40%
83.83% 81.70% 79.12% 83.70%
50.23% 47.79% 45.33% 51.00%
33.46% 22.74% 26.07% 25.20%

Provable Adversarial
Accuracy
19.00% 82.17% 89.13% 91.58% 94.33% 94.32% 95.60%
86.45% 89.79% 85.54% 89.10%
77.99% 80.68% 76.70% 59.60%
45.53% 45.93% 44.44% 41.40%
7.09% 20.27% 18.90% 19.80%

Total Unstable
ReLUs
1517.9 505.3 502.7 278.2 101.0 158.3 119.5
198.3 108.4 217.2 133.0
160.9 101.5 179.0 251.2
360.0 234.3 170.1 196.7
665.9 54.2
277.8 246.5

Avg Solve Time (s)
2970.43 21.99 11.71 6.43 0.49 0.96 0.27
9.41 1.13 8.50 2.93
11.80 2.78 6.43
37.45
21.75 13.50 6.30 29.88
82.91 22.33 33.63 20.14

Avg Build Time (s)
650.93 79.13 19.30 9.61 4.98 4.82
156.74
7.15 4.43 4.67 171.10
5.14 4.34 4.00 166.39
66.42 52.58 47.11 335.97
73.28 38.84 23.66 401.72

Table 6: Full results on natural improvements from Table 1, control networks (which include all of the natural improvements and ReLU pruning), and "+RS" networks. While we are unable to determine the true adversarial accuracy, we provide two upper bounds and a lower bound. Evaluations of robustness against a strong 40-step PGD adversary (PGD adversarial accuracy) gives one upper bound, and the verifier itself gives another upper bound because it can also prove that the network is not robust to perturbations on certain inputs. The verifier simultaneously finds the provable adversarial accuracy, which is a lower bound on the true adversarial accuracy. The gap between the verifier upper bound and the provable adversarial accuracy (verifier lower bound) corresponds to inputs that the verifier can not prove to be robust or not robust in 120 seconds. Build times and solve times are reported in seconds. *The "Adversarial Training" network uses a 3600 instead of 120 second timeout and is only verified for the first 100 images because verifying it took too long. **The "+RS (Large)" networks are only verified for the first 1000 images because of long build times.

16

