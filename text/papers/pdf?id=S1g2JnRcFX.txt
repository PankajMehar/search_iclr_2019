Under review as a conference paper at ICLR 2019

LOCAL SGD CONVERGES FAST AND COMMUNICATES LITTLE
Anonymous authors Paper under double-blind review

ABSTRACT
Mini-batch stochastic gradient descent (SGD) is state of the art in large scale distributed training. The scheme can reach a linear speedup with respect to the number of workers, but this is rarely seen in practice as the scheme often suffers from large network delays and bandwidth limits. To overcome this communication bottleneck recent works propose to reduce the communication frequency. An algorithm of this type is local SGD that runs SGD independently in parallel on different workers and averages the sequences only once in a while. This scheme shows promising results in practice, but eluded thorough theoretical analysis.
We prove concise convergence rates for local SGD on convex problems and show that it converges at the same rate as mini-batch SGD in terms of number of evaluated gradients, that is, the scheme achieves linear speedup in the number of workers and mini-batch size. The number of communication rounds can be reduced up to a factor of T 1/2--where T denotes the number of total steps--compared to mini-batch SGD. This also holds for asynchronous implementations.
Local SGD can also be used for large scale training of deep learning models. The results shown here aim serving as a guideline to further explore the theoretical and practical aspects of local SGD in these applications.

1 INTRODUCTION

Stochastic Gradient Descent (SGD) (Robbins & Monro, 1951) consists of iterations of the form

xt+1 := xt - tgt ,

(1)

for iterates (or weights) xt, xt+1  Rd, stepsize (or learning rate) t > 0, and stochastic gradient gt with the property E gt = f (xt), for a loss function f : Rd  R. This scheme can easily be parallelized by replacing gt in (1) by an average of stochastic gradients that are independently computed in parallel on separate workers (parallel SGD). This simple scheme has a major drawback: in each iteration the results of the computations on the workers have to be shared with the other workers to compute the next iterate xt+1. Communication has been reported to be a major bottleneck for many large scale deep learning applications, see e.g. (Seide et al., 2014; Alistarh et al., 2017; Zhang et al., 2017; Lin et al., 2018b). Mini-batch parallel SGD addresses this issue by increasing the compute to communication ratio. Each worker computes a mini-batch of size b before communication. This scheme is implemented in state-of-the-art distributed deep learning frameworks (Abadi et al., 2016; Paszke et al., 2017; Seide & Agarwal, 2016). Recent work in (You et al., 2017; Goyal et al., 2017) explores various limitations of this approach, as in general it is reported that performance degrades for too large mini-batch sizes (Keskar et al., 2016; Ma et al., 2018).

In this work we follow an orthogonal approach, still with the goal to increase the compute to communication ratio: Instead of increasing the mini-batch size, we reduce the communication frequency. Rather than keeping the sequences on different machines in sync, we allow them to evolve locally on each machine, independent from each other, and only average the sequences once in a while (local SGD). Such strategies have been explored widely in the literature, under various names.

An extreme instance of this concept is one shot SGD (Mcdonald et al., 2009; Zinkevich et al., 2010) where the local sequences are only exchanged once, after the local runs have converged. Zhang et al. (2013) show statistical convergence (see also (Godichon-Baggioni & Saadane, 2017)), but the

1

Under review as a conference paper at ICLR 2019

256 b=1, H=1
64 perfect speedup
16
4
1

256 b=1, H=1
64 b=2, H=1 b=1, H=2
16 b=2, H=2
4
1

communication overhead 1 4 16

64 256

communication overhead

gain

1 4 16 64

256

Figure 1: Illustration of the speedup (3) for time-to-accuracy when either increasing mini-batch size b (1  2) or communication inverval H (1  2), for compute to communication ratio  = 25.

analysis restricts the algorithm to at most one pass over the data, which is in general not enough for the training error to converge. More practical are schemes that perform more frequent averaging of the parallel sequences, as e.g. (Bijral et al., 2016; Zhang et al., 2016) for the training of deep neural networks (model averaging) or in federated learning (McMahan et al., 2017).
The question of how often communication rounds need to be initiated has eluded a concise theoretical answer so far. Whilst there is practical evidence, the theory does not even resolve the question whether averaging helps when optimizing convex functions. Concretely, whether running local SGD on K workers is K times faster than running just a single instance of SGD on one worker.1
We fill this gap in the literature and provide a concise convergence analysis of local SGD. We show that averaging helps. Frequent synchronization of K local sequences increases the convergence rate by a factor of K, i.e. a linear speedup can be attained. Thus, local SGD is as efficient as parallel mini-batch SGD in terms of computation, but the communication cost can be drastically reduced.

1.1 CONTRIBUTIONS

We consider finite-sum convex optimization problems f : Rd  R of the form

1n

f (x) = n

fi(x) ,

i=1

x := arg minxRd f (x) ,

f := f (x ) ,

(2)

where f is L-smooth2 and µ-strongly convex3. We consider K parallel mini-batch SGD sequences with mini-batch size b that are synchronized after at most every H iterations. For appropriate chosen stepsizes and an averaged iterate x^T after T steps (for T sufficiently large, see Section 3 below) and
synchronization delay H = O( T /(Kb)) we show convergence

G2 E f (x^T ) - f = O µKT ,

(3)

with second moment bound G2  E fi(x) 2. Thus, we see that compared to parallel mini-
batch SGD the communication rounds can be reduced by a factor H = O( T /(Kb)) without hampering the asymptotic convergence. Equation (3) shows perfect linear speedup in terms of computation, but with much less communication that mini-batch SGD. The resulting speedup when taking communication cost into account is illustrated in Figure 1 (see also Section D below). To improve the compute to communication ratio (denoted by ) one has thus now two strategies: (i) either to increase the mini-batch size b or (ii) to increase the communication interval H. Both strategies give the same improvement when b and H are small (linear speedup). Similar to mini-batch SGD that faces some limitations for b 1 (as discussed in e.g. (Ma et al., 2018)), the parameter H cannot be chosen too large in local SGD. We give some pratical guidelines in Section 4.
Our proof is simple and straightforward, and we imagine that--with slight modifications of the proof--the technique can also be used to analyze other variants of SGD that evolve sequences on different worker that are not perfectly synchronized. Although we do not yet provide convergence guarantees for the non-convex setting we feel that the positive results presented here will spark further investigation of local SGD for this important application (see e.g. (Yu et al., 2018)).

1On convex functions, the average of the K local solutions can of course only decrease the objective value,

but convexity does not imply that the averaged point is K times better.

2f (y)  f (x) + 3f (y)  f (x) +

f (x), y - x f (x), y - x

+

L 2

+

µ 2

y - x 2, x, y  Rd.

y-x

2,

x,

y



d
R

.

2

Under review as a conference paper at ICLR 2019

1.2 RELATED WORK
A parallel line of work reduces the communication cost by compressing the stochastic gradients before communication. For instance by limiting the number of bits in the floating point representation (Gupta et al., 2015; Na et al., 2017; Sa et al., 2015), or random quantization (Alistarh et al., 2017; Wen et al., 2017). The ZipML framework applies this technique also to the data (Zhang et al., 2017). Sparsification methods reduce the number of non-zero entries in the stochastic gradient (Alistarh et al., 2017; Wangni et al., 2017). A very aggressive--and promising--sparsification method is to keep only very few coordinates of the stochastic gradient by considering only the coordinates with the largest magnitudes (Seide et al., 2014; Strom, 2015; Dryden et al., 2016; Aji & Heafield, 2017; Sun et al., 2017; Lin et al., 2018b; Stich et al., 2018).
Allowing asynchronous updates provides an alternative solution to disguise the communication overhead to a certain amount (Niu et al., 2011; Sa et al., 2015; Lian et al., 2015), though alternative strategies might be better when high accuracy is desired (Chen et al., 2016). The analysis of Agarwal & Duchi (2011) shows that asynchronous SGD on convex functions can tolerated delays up to O( T /K), which is identical to the maximal length of the local sequences in local SGD. Asynchronous SGD converges also for larger delays (see also (Zhou et al., 2018)) but without linear speedup, a similar statement holds for local SGD (see discussion in Section 3). The current frameworks for the analysis of asynchronous SGD do not cover local SGD. A fundamental difference is that asynchronous SGD maintains a (almost) synchronized sequence and gradients are computed with respect this unique sequence (but just applied with delays), whereas each worker in local SGD evolves a different sequence and computes gradient with respect those iterates.
For the training of deep neural networks, Bijral et al. (2016) discuss a stochastic averaging schedule whereas Zhang et al. (2016) study local SGD with more frequent communication at the beginning of the optimization process. The elastic averaging technique (Zhang et al., 2015) is different to local SGD, as it uses the average of the iterates only to guide the local sequences, but does not perform a hard reset after averaging. Three recent preprints discuss local SGD for non-convex settings: Lin et al. (2018a) give an empirical analysis whereas Yu et al. (2018) and Wang & Joshi (2018) give theoretically analyses. Yu et al. (2018) show linear speedup of local SGD on non-convex functions for H = O(T 1/4K-3/4), which is more restrictive than the constraint on H in the convex setting.
1.3 OUTLINE
We formally introduce local SGD in Section 2 and sketch the convergence proof in Section 3. In Section 4 show numerical results to illustrate the result. We analyze asynchronous local SGD in Section 5. The proof of the technical results, further discussion about the experimental setup and implementation guidelines are deferred to the appendix.

2 LOCAL SGD

The algorithm local SGD (depicted in Algorithm 1) generates in parallel K sequences {xkt }Tt=0 of iterates, k  [K]. Here K denotes the level of parallelization, i.e. the number of distinct parallel sequences and T the number of steps (i.e. the total number of stochastic gradient evaluations is T K). Let IT  [T ] with T  IT denote a set of synchronization indices. Then local SGD evolves the sequences {xtk}tT=0 in the following way:

xkt+1 :=

xtk - tfikt (xtk) ,

1 K

K k=1

xkt - tfikt (xtk)

if t + 1 / IT if t + 1  IT

(4)

where indices itk u.a.r. [n] and {t}t0 denotes a sequence of stepsizes. If IT = [T ] then the synchronization of the sequences is performed every iteration. In this case, (4) amounts to parallel or mini-batch SGD with mini-batch size K.4 On the other extreme, if IT = {T }, the synchronization
only happens at the end, which is known as one-shot averaging.

4For the ease of presentation, we assume here that each worker in local SGD only processes a mini-batch of size b = 1. This can be done without loss of generality, as we discuss later in Remark 2.4.

3

Under review as a conference paper at ICLR 2019

Algorithm 1 LOCAL SGD

1: Initialize variables xk0 = x0 for k  [K] 2: for t in 0 . . . T - 1 do

3: parallel for k  [K] do

4: Sample itk uniformly in [n] 5: xkt+1  xkt - tfit (xkt ) 6: end parallel for

7: if t + 1  IT then

8:

xkt+1



1 K

K k=1

xkt

9: end if

10: end for

local update global synchronization

In order to measure the longest interval between subsequent synchronization steps, we introduce the gap of a set of integers.
Definition 2.1 (gap). The gap of a set P := {p0, . . . , pt} of t + 1 integers, pi  pi+1 for i = 0, . . . , t - 1, is defined as gap(P) := maxi=1,...,t(pi - pi-1).

2.1 VARIANCE REDUCTION IN LOCAL SGD Before jumping to the convergence result, we first discuss an important observation.

Parallel (mini-batch) SGD.

For carefully chosen stepsizes t, SGD converges at rate O

2 T

on

strongly convex and smooth functions f , where 2  E fitk (xkt ) - f (xtk) 2 for t > 0, k  [K]

is an upper bound on the variance, see for instance (Zhao & Zhang, 2015). By averaging K stochastic

gradients--such as in parallel SGD--the variance decreases by a factor of K, and we conclude that

parallel SGD converges at a rate O

2 TK

, i.e. achieves a linear speedup.

Towards local SGD. For local SGD such a simple argument is elusive. For instance, just capitaliz-

ing the convexity of the objective function f is not enough: this will show that the averaged iterate of

K independent SGD sequences converges at rate O

2 T

, i.e. no speedup can be shown in this way.

This indicates that one has to show that local SGD decreases the variance 2 instead, similar as in parallel SGD. Suppose the different sequences xtk evolve close to each other. Then it is reasonable to assume that averaging the stochastic gradients fikt (xtk) for all k  [K] can still yield a reduction in the variance by a factor of K--similar as in parallel SGD. Indeed, we will make this statement
precise in the proof below.

2.2 CONVERGENCE RESULT AND DISCUSSION

Theorem 2.2. Let f be L-smooth and µ-strongly convex, Ei fi(xtk) - f (xtk) 2  2,

Ei fi(xkt ) 2  G2, for t = 0, . . . , T - 1, where {xkt }tT=0 for k  [K] are generated according

to

(4)

with

gap(IT )



H

and

for

stepsizes

t

=

4 µ(a+t)

with

shift

parameter

a

>

max{16, H},

for



=

L µ

.

Then

E f (x^T ) - f

µa3 
2ST

x0 - x

2

+

4T (T + 2a) 2 µK ST

+

256T µ2ST

G2 H 2 L

,

(5)

where x^T

=

1 K ST

K k=1

T -1 t=0

wtxtk

,

for

wt

=

(a

+ t)2

and

ST

=

T -1 t=0

wt



1 3

T

3

.

We were not especially careful to optimize the constants (and the lower order terms) in (5), so we now state the asymptotic result.
Corollary 2.3. Let x^T be as defined as in Theorem 2.2, for parameter a = max{16, H}. Then

E f (x^T ) - f = O

1 +H µKT + µKT 2

2 + O

H2 3 + H3 µT 2 + µT 3

G2 .

(6)

4

Under review as a conference paper at ICLR 2019

For the last estimate we used E µ x0 - x  2G for µ-strongly convex f , as derived in (Rakhlin et al., 2012, Lemma 2).

Remark 2.4 (Mini-batch local SGD). So far we assumed that each worker only computes a single

stochastic gradient. In mini-batch local SGD, each worker computes a mini-batch of size b in each

iteration. This reduces the variance by a factor of b, and thus Theorem (2.2) gives the convergence

rate

of

mini-batch

local

SGD

when

2

is

replaced

by

2 b

.

We now state some consequences of equation (6). For the ease of the exposition we omit the dependency on L, µ, 2 and G2 below, but depict the dependency on the local mini-batch size b.

Convergence rate. For T large enough, the very first term is dominating in (6) and local SGD converges at rate O(1/(KT b)). That is, local SGD achieves a linear speedup in both, the number of workers K and the mini-batch size b.
Global synchronization steps. It needs to hold H = O( T /(Kb)) to get the linear speedup. This
yields a reduction of the number of communication rounds by a factor O( T /(Kb)) compared to parallel mini-batch SGD without hurting the convergence rate.
Extreme Cases. We have not optimized the result for extreme settings of H, K, L or . For instance, we do not recover convergence for the one shot averaging, i.e. the setting H = T (though convergence for H = o(T ), but at a lower rate).
Unknown Time Horizon/Adaptive Communication Frequency Zhang et al. (2016) empirically observe that more frequent communication at the beginning of the optimization can help to get faster time-to-accuracy. Indeed, when the number of total iterations T is not known beforehand (as it e.g. depends on the target accuracy, cf. (6) and also Section 4 below), then increasing the communication frequency seems to be a good strategy to keep the communication low, why still respecting the constraint H = O( T /(Kb)) for all T .

3 PROOF OUTLINE

We now give the outline of the proof. The proofs of the lemmas are given in Appendix A.

Perturbed iterate analysis. Inspired by the perturbed iterate framework of (Mania et al., 2017) we first define a virtual sequence {x¯t}t0 in the following way:

x¯0 = x0 ,

1 x¯t = K

K

xtk ,

k=1

(7)

where the sequences {xtk}t0 for k  [K] are the same as in (4). Notice that this sequence never has to be computed explicitly, it is just a tool that we use in the analysis. Further notice that x¯t = xtk for k  [K] whenever t  IT . Especially, when IT = [T ], then x¯t  xkt for every k  [K], t  [T ]. It will be useful to define

1 gt := K

K

fitk (xkt ) ,

k=1

1 g¯t := K

K

f (xkt ) .

k=1

(8)

Observe x¯t+1 = x¯t - tgt and E gt = g¯t.

Now the proof proceeds as follows: we show (i) that the virtual sequence {x¯t}t0 almost behaves like mini-batch SGD with batch size K (Lemma 3.1 and 3.2), and (ii) the true iterates {xtk}t0,k[K] do not deviate much from the virtual sequence (Lemma 3.3). These are the main ingredients in the
proof. To obtain the rate we exploit a technical lemma from (Stich et al., 2018).

Lemma 3.1. Let {xt}t0 and {x¯t}t0 for k  [K] be defined as in (4) and (7) and let f be L-smooth

and

µ-strongly

convex

and

t



1 4L

.

Then

E x¯t+1 - x 2  (1 - µt) E x¯t - x 2 + t2 E gt - g¯t 2

-

1 2 t

E(f (x¯t)

-

f

L ) + 2t K

K

E

x¯t - xtk

2.

k=1

(9)

5

Under review as a conference paper at ICLR 2019

Bounding the variance. From equation (9) it becomes clear that we should derive an upper bound on E gt - g¯t 2. We will relate this to the variance 2.

Lemma 3.2.

Let 2  Ei

fi(xtk) - f (xkt )

2 for k  [K], t  [T ]. Then E

gt - g¯t

2



2 K

.

Bounding the deviation.

Further,

we

need

to

bound

1 K

K
k=1 E

x¯t - xkt

2. For this we impose

a condition on IT and an additional condition on the stepsize t.

Lemma 3.3. If gap(IT )  H and sequence of decreasing positive stepsizes {t}t0 satisfying t  2t+H for all t  0, then

1 K

K

E

x¯t - xkt

2  4t2G2H2 ,

k=1

(10)

where G2 is a constant such that Ei fi(xtk) 2  G2 for k  [K], t  [T ].

Optimal Averaging. Similar as in (Lacoste-Julien et al., 2012; Shamir & Zhang, 2013; Rakhlin et al., 2012) we define a suitable averaging scheme for the iterates {x¯t}t0 to get the optimal convergence rate. In contrast to (Lacoste-Julien et al., 2012) that use linearly increasing weights, we use quadratically increasing weights, as for instance (Shamir & Zhang, 2013; Stich et al., 2018).
Lemma 3.4 ((Stich et al., 2018)). Let {at}t0, at  0, {et}t0, et  0 be sequences satisfying

at+1  (1 - µt) at - tetA + t2B + t3C ,

(11)

for

t

=

4 µ(a+t)

and

constants

A

>

0,

B, C



0,

µ

>

0,

a

>

1.

Then

A T -1

µa3 2T (T + 2a) 16T

ST t=0 wtet  4ST a0 + µST B + µ2ST C ,

(12)

for wt = (a + t)2 and ST :=

T -1 t=0

wt

=

T 6

2T 2 + 6aT - 3T + 6a2 - 6a + 1



1 3

T

3

.

Proof. This is a reformulation of Lemma 3.3 in (Stich et al., 2018).

Proof of Theorem 2.2.

By convexity of f we have E f (x^T ) - f



1 ST

T -1 t=0

wt

E

f (x¯t) - f

.

The proof of the theorem thus follows immediately from the four lemmas that we have presented, i.e.

by Lemma 3.4 with et := E(f (x¯t) - f

) and constants A =

1 2

,

(Lemma

3.1),

B

=

2 K

,

(Lemma

3.2)

and

C

=

8G2 H 2 L,

(Lemma

3.3).

Observe

that

the

stepsizes

t

=

4 µ(a+t)

satisfy

both

the

conditions

of Lemma

3.1

(0

=

4 µa



1 4L

,

as

a



16)

and

of

Lemma

3.3

t t+H

=

a+t+H a+t

 2, as a  H

.

4 NUMERICAL ILLUSTRATION

In this section we show some numerical experiments to illustrate the results of Theorem 2.2.

Speedup. When Algorithm 1 is implemented in a distributed setting, there are two components

that determine the wall-clock time: (i) the total number of gradient computations, T K, and (ii) the total time spend for communication. In each communication round 2(K - 1) vectors need to be exchanged, and there will be T /H communication rounds. Typically, the communication is more expensive than a single gradient computation. We will denote this ratio by a factor   1 (in practice,  can be 10­100, or even larger on slow networks). The parameter T depends on the desired accuracy

>

0,

and

according to

(6)

we

roughly have

T(

, H, K)



1 K

1 2

+

1 2

1 + (1 + H + H2K) .

Thus, the theoretical speedup S(K) of local SGD on K machines compared to SGD on one machine (H = 1, K = 1) is

K

S(K) =

1 2

+

1 2

1 + (1 + H + H2K)

.

1

+

2

(K -1) H

(13)

6

Under review as a conference paper at ICLR 2019

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1 2 4 8 16 32 64 128 256 512 1024

1 2 4 8 16 32 64 128 256 512 1024

(a) Theoretical speedup S(K) ( > 0, T small).

(b) Theoretical speedup S(K) ( = 0, T  ).

Figure 2: Theoretical speedup of local SGD for different numbers of workers K and H.

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1 4 16 64 256 1024

1 4 16 64 256 1024

(a) Measured speedup, = 0.005.

(b) Measured speedup, = 0.0001.

Figure 3: Measured speedup of local SGD with mini-batch b = 4 for different numbers of workers K and parameters H.

Theoretical. When examining equation (13) we see that (i) increasing H can reduce negative scaling effects due to parallelization (second bracket in the denominator of (13)), and (ii) local SGD only shows linear scaling for 1 (i.e. T large enough, in agreement with the theory). In Figure 2 we depict S(K), once for = 0 in Figure 2b, and for positive > 0 in Figure 2a under the assumption  = 25. We see that for = 0 the largest values of H give the best speedup, however, when only a few epochs need to be performed, then the optimal values of H change with the number of workers K. We also see that for a small number of workers H = 1 is never optimal. If T is unknown, then these observation seem to indicate that the technique from (Zhang et al., 2016), i.e. adaptively increasing H over time seems to be a good strategy to get the best choice of H when the time horizon is unknown.

Experimental. We examine the practical speedup on a logistic regression problem, f (x) =

1 n

n i=1

log(1

+

exp(-biai

x))

+

 2

x

2, where ai

 Rd and bi

 {-1, +1} are the data sam-

ples. The regularization parameter is set to  = 1/n. We consider the w8a dataset (Platt, 1999)

(d = 300, n = 49749). We initialize all runs with x0 = 0d and measure the number of iterations

to reach the target accuracy . We consider the target accuracy reached, when either the last iterate,

the uniform average, the average with linear weights, or the average with quadratic weights (such

as in Theorem 2.2) reaches the target accuracy. By extensive grid search we determine for each

configuration

(H,

K,

B)

the

best

stepsize

from

the

set

{min(32,

cn t+1

),

32c},

where

c

can

take

the

values c = 2i for i  Z. For more details on the experimental setup refer Section D in the appendix.

We depict the results in Figure 3, again under the assumption  = 25.

Conclusion. The restriction on H imposed by theory is not severe for T  . Thus, for training that either requires many passes over the data or that is performed only on a small cluster, large values of H are advisable. However, for smaller T (few passes over the data), the O(1/ K) dependency shows significantly in the experiment. This has to be taken into account when deploying the algorithm on a massively parallel system, for instance through the technique mentioned in (Zhang et al., 2016).

5 ASYNCHRONOUS LOCAL SGD
In this section we present asynchronous local SGD that does not require that the local sequences are synchronized at the same time step. This does not only reduce communication bottlenecks, but by using load-balancing techniques the algorithm can optimally be tuned to heterogeneous settings (slower workers do less computation between synchronization, and faster workers do more). We will discuss this in more detail in Section C.
Asynchronous local SGD generates in parallel K sequences {xtk}tT=0 of iterates, k  [K]. Similar as in Section 2 we introduce sets of synchronization indices, Itk  [T ] with T  ITk for k  [K]. Note that the sets do not have to be equal for different workers. Each worker k evolves locally a sequence

7

Under review as a conference paper at ICLR 2019

Algorithm 2 ASYNCHRONOUS LOCAL SGD (SCHEMATIC)

1: Initialize variables xk0 = x0, rk = 0 for k  [K], aggregate x¯ = x0. 2: parallel for k  [K] do

3: for t in 0 . . . T - 1 do

4: Sample itk uniformly in [n]

5: xtk+1  xtk - tfikt (xtk)

6: if t + 1  ITk then

7:

x¯



add(x¯,

1 K

(xkt

-

xkrk ))

8: xtk+1  read(x¯); update time of last read rk  t + 1

9: end if

10: end for

11: end parallel for

local update atomic write of updates

xtk in the following way:

xkt+1 =

xkt - tfitk (xkt ) x¯tk+1

if t + 1 / ITk if t + 1  ITk

(14)

where x¯kt+1 denotes the state of the aggregated variable at the time when worker k reads the aggregated variable. To be precise, we use the notation

x¯tk

=

x0

-

1 K

K

t-1
1jWtk,h (j fikj (xjk)) ,

h=1 j=0

(15)

where Wtk,h  [T ] denotes all updates that have been written at the time the read takes place. The sets Wtk,h are indexed by iteration t, worker k that initiates the read and h  [K]. Thus Wtk,h denotes all updates of the local sequence {xht }t0, that have been reported back to the server at the time worker k reads (in iteration t). This notation is necessary, as we don't necessarily have

Wtk,h = Wtk ,h for k = k . We have Wtk,h  Wtk,h for t  t, as updates are not overwritten. When we cast synchronized local SGD in this notation, then it holds Wtk,h = Wtk ,h for all k, h, k , h , as all the writes and reads are synchronized.

Theorem 5.1. Let f , , G and according to (14) with gap(ITk

 )

be as H

in Theorem 5.1 for k  K and

faonrdstseepqsuieznescest{=xktµ}(tTa=4+0t)fowr ikthsh[Kift]pgaernaemraetteedr

a > max{16, H +  }. If there exists  > 0, s.t. Wtk,h  [t -  ] for all k, h  [K], t  [T ], then

E f (x^T ) - f

 µa3 2ST

x0 - x

2

+

4T (T + 2a) µK ST

2

+

768T µ2ST

G2(H

+

)2L

,

(16)

where x^T

=

1 K ST

K k=1

T -1 t=0

wtxkt

,

for

wt

=

(a

+ t)2

and

ST

=

T -1 t=0

wt



1 3

T

3

.

Hence, for T large enough and (H +  ) = O( T /K), asynchronous local SGD converges with rate

O

G2 KT

, the same rate as synchronous local SGD.

6 CONCLUSION

We prove convergence of synchronous and asynchronous local SGD and are the first to show that local SGD attains theoretically linear speedup on strongly convex functions when parallelized among K workers. We show that local SGD saves up to a factor of O(T 1/2) in global communication rounds compared to mini-batch SGD, while still converging at the same rate in terms of total stochastic gradient computations. There are no apparent reasons that would limit the extension of the theory to non-convex objective functions; Lemma 3.3 does neither use the smoothness nor the strong convexity assumption, so this can be applied in the non-convex setting as well. We feel that the positive results shown here can motivate and spark further research on non-convex problems. Indeed, very recent work (Yu et al., 2018) analyzes local SGD for non-convex optimization problems and shows convergence of SGD to a stationary point, though the restrictions on H are stronger than here.

8

Under review as a conference paper at ICLR 2019
REFERENCES
Martín Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, et al. Tensorflow: Large-scale machine learning on heterogeneous distributed systems. arXiv preprint arXiv:1603.04467, 2016.
Alekh Agarwal and John C Duchi. Distributed delayed stochastic optimization. In J. Shawe-Taylor, R. S. Zemel, P. L. Bartlett, F. Pereira, and K. Q. Weinberger (eds.), Advances in Neural Information Processing Systems 24, pp. 873­881. Curran Associates, Inc., 2011. URL http://papers.nips.cc/paper/ 4247-distributed-delayed-stochastic-optimization.pdf.
Alham Fikri Aji and Kenneth Heafield. Sparse communication for distributed gradient descent. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pp. 440­445. Association for Computational Linguistics, 2017. URL http://aclweb.org/anthology/D17-1045.
Dan Alistarh, Demjan Grubic, Jerry Li, Ryota Tomioka, and Milan Vojnovic. QSGD: Communication-efficient SGD via gradient quantization and encoding. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems 30, pp. 1709­1720. Curran Associates, Inc., 2017. URL http://papers.nips.cc/paper/6768-qsgdcommunication-efficient-sgd-via-gradient-quantization-and-encoding.pdf.
Avleen S Bijral, Anand D Sarwate, and Nathan Srebro. On Data Dependence in Distributed Stochastic Optimization. arXiv.org, 2016.
Jianmin Chen, Rajat Monga, Samy Bengio, and Rafal Józefowicz. Revisiting distributed synchronous SGD. CoRR, abs/1604.00981, 2016. URL http://arxiv.org/abs/1604.00981.
N. Dryden, T. Moon, S. A. Jacobs, and B. V. Essen. Communication quantization for data-parallel training of deep neural networks. In 2016 2nd Workshop on Machine Learning in HPC Environments (MLHPC), pp. 1­8, Nov 2016. doi: 10.1109/MLHPC.2016.004.
Antoine Godichon-Baggioni and Sofiane Saadane. On the rates of convergence of parallelized averaged stochastic gradient algorithms. arXiv preprint arXiv:1710.07926, 2017.
Priya Goyal, Piotr Dollár, Ross B. Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch SGD: training ImageNet in 1 hour. CoRR, abs/1706.02677, 2017. URL http://arxiv.org/abs/1706.02677.
Suyog Gupta, Ankur Agrawal, Kailash Gopalakrishnan, and Pritish Narayanan. Deep learning with limited numerical precision. In Proceedings of the 32Nd International Conference on International Conference on Machine Learning - Volume 37, ICML'15, pp. 1737­1746. JMLR.org, 2015. URL http://dl.acm.org/ citation.cfm?id=3045118.3045303.
Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang. On large-batch training for deep learning: Generalization gap and sharp minima. arXiv preprint arXiv:1609.04836, 2016.
Simon Lacoste-Julien, Mark W. Schmidt, and Francis R. Bach. A simpler approach to obtaining an O(1/t) convergence rate for the projected stochastic subgradient method. CoRR, abs/1212.2002, 2012.
Xiangru Lian, Yijun Huang, Yuncheng Li, and Ji Liu. Asynchronous parallel stochastic gradient for nonconvex optimization. In Proceedings of the 28th International Conference on Neural Information Processing Systems - Volume 2, NIPS'15, pp. 2737­2745, Cambridge, MA, USA, 2015. MIT Press. URL http: //dl.acm.org/citation.cfm?id=2969442.2969545.
Tao Lin, Sebastian U. Stich, and Martin Jaggi. Don't use large mini-batches, use local SGD. CoRR, abs/1808.07217, 2018a. URL https://arxiv.org/abs/1808.07217.
Yujun Lin, Song Han, Huizi Mao, Yu Wang, and Bill Dally. Deep gradient compression: Reducing the communication bandwidth for distributed training. In ICLR 2018 - International Conference on Learning Representations, 2018b. URL https://openreview.net/forum?id=SkhQHMW0W.
Siyuan Ma, Raef Bassily, and Mikhail Belkin. The power of interpolation: Understanding the effectiveness of SGD in modern over-parametrized learning. In ICML, 2018.
Horia Mania, Xinghao Pan, Dimitris Papailiopoulos, Benjamin Recht, Kannan Ramchandran, and Michael I. Jordan. Perturbed iterate analysis for asynchronous stochastic optimization. SIAM Journal on Optimization, 27(4):2202­2229, 2017. doi: 10.1137/16M1057000.
9

Under review as a conference paper at ICLR 2019
Ryan Mcdonald, Mehryar Mohri, Nathan Silberman, Dan Walker, and Gideon S. Mann. Efficient large-scale distributed training of conditional maximum entropy models. In Y. Bengio, D. Schuurmans, J. D. Lafferty, C. K. I. Williams, and A. Culotta (eds.), Advances in Neural Information Processing Systems 22, pp. 1231­1239. Curran Associates, Inc., 2009. URL http://papers.nips.cc/paper/3881-efficient-largescale-distributed-training-of-conditional-maximum-entropy-models.pdf.
Brendan McMahan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Aguera y Arcas. Communicationefficient learning of deep networks from decentralized data. In Aarti Singh and Jerry Zhu (eds.), Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, volume 54 of Proceedings of Machine Learning Research, pp. 1273­1282, Fort Lauderdale, FL, USA, 20­22 Apr 2017. PMLR. URL http://proceedings.mlr.press/v54/mcmahan17a.html.
T. Na, J. H. Ko, J. Kung, and S. Mukhopadhyay. On-chip training of recurrent neural networks with limited numerical precision. In 2017 International Joint Conference on Neural Networks (IJCNN), pp. 3716­3723, May 2017. doi: 10.1109/IJCNN.2017.7966324.
Feng Niu, Benjamin Recht, Christopher Re, and Stephen J. Wright. Hogwild!: A lock-free approach to parallelizing stochastic gradient descent. In Proceedings of the 24th International Conference on Neural Information Processing Systems, NIPS'11, pp. 693­701, USA, 2011. Curran Associates Inc. ISBN 978-161839-599-3. URL http://dl.acm.org/citation.cfm?id=2986459.2986537.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in pytorch. 2017.
John C. Platt. Advances in kernel methods. chapter Fast Training of Support Vector Machines Using Sequential Minimal Optimization, pp. 185­208. MIT Press, Cambridge, MA, USA, 1999. ISBN 0-262-19416-3. URL http://dl.acm.org/citation.cfm?id=299094.299105.
Alexander Rakhlin, Ohad Shamir, and Karthik Sridharan. Making gradient descent optimal for strongly convex stochastic optimization. In Proceedings of the 29th International Coference on International Conference on Machine Learning, ICML'12, pp. 1571­1578, USA, 2012. Omnipress. ISBN 978-1-4503-1285-1. URL http://dl.acm.org/citation.cfm?id=3042573.3042774.
Herbert Robbins and Sutton Monro. A Stochastic Approximation Method. The Annals of Mathematical Statistics, 22(3):400­407, September 1951.
Christopher De Sa, Ce Zhang, Kunle Olukotun, and Christopher Ré. Taming the wild: A unified analysis of HOG WILD!-style algorithms. In Proceedings of the 28th International Conference on Neural Information Processing Systems - Volume 2, NIPS'15, pp. 2674­2682, Cambridge, MA, USA, 2015. MIT Press. URL http://dl.acm.org/citation.cfm?id=2969442.2969538.
Frank Seide and Amit Agarwal. CNTK: Microsoft's open-source deep-learning toolkit. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp. 2135­2135. ACM, 2016.
Frank Seide, Hao Fu, Jasha Droppo, Gang Li, and Dong Yu. 1-bit stochastic gradient descent and its application to data-parallel distributed training of speech DNNs. In Haizhou Li, Helen M. Meng, Bin Ma, Engsiong Chng, and Lei Xie (eds.), INTERSPEECH, pp. 1058­1062. ISCA, 2014. URL http://dblp.uni-trier.de/ db/conf/interspeech/interspeech2014.html#SeideFDLY14.
Ohad Shamir and Tong Zhang. Stochastic gradient descent for non-smooth optimization: Convergence results and optimal averaging schemes. In Sanjoy Dasgupta and David McAllester (eds.), Proceedings of the 30th International Conference on Machine Learning, volume 28 of Proceedings of Machine Learning Research, pp. 71­79, Atlanta, Georgia, USA, 17­19 Jun 2013. PMLR. URL http://proceedings.mlr.press/ v28/shamir13.html.
Sebastian U. Stich, Jean-Baptiste Cordonnier, and Martin Jaggi. Sparsified SGD with Memory. In NIPS 2018 - Advances in Neural Information Processing Systems, 2018. URL https://arxiv.org/abs/ 1809.07599.
Nikko Strom. Scalable distributed DNN training using commodity GPU cloud computing. In INTERSPEECH, pp. 1488­1492. ISCA, 2015. URL http://dblp.uni-trier.de/db/conf/interspeech/ interspeech2015.html#Strom15.
Xu Sun, Xuancheng Ren, Shuming Ma, and Houfeng Wang. meProp: Sparsified back propagation for accelerated deep learning with reduced overfitting. In Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of Machine Learning Research, pp. 3299­3308, International Convention Centre, Sydney, Australia, 06­11 Aug 2017. PMLR. URL http://proceedings.mlr.press/v70/sun17c.html.
10

Under review as a conference paper at ICLR 2019
Jianyu Wang and Gauri Joshi. Cooperative SGD: A unified framework for the design and analysis of communication-efficient SGD algorithms. CoRR, abs/1808.07576, 2018.
Jianqiao Wangni, Jialei Wang, Ji Liu, and Tong Zhang. Gradient sparsification for communication-efficient distributed optimization. CoRR, abs/1710.09854, 2017. URL http://arxiv.org/abs/1710.09854.
Wei Wen, Cong Xu, Feng Yan, Chunpeng Wu, Yandan Wang, Yiran Chen, and Hai Li. Terngrad: Ternary gradients to reduce communication in distributed deep learning. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems 30, pp. 1509­1519. Curran Associates, Inc., 2017. URL http://papers.nips.cc/paper/6749-terngrad-ternary-gradients-toreduce-communication-in-distributed-deep-learning.pdf.
Yang You, Igor Gitman, and Boris Ginsburg. Scaling SGD batch size to 32k for ImageNet training. CoRR, abs/1708.03888, 2017.
Hao Yu, Sen Yang, and Shenghuo Zhu. Parallel restarted sgd for non-convex optimization with faster convergence and less communication. CoRR, abs/1807.06629, 2018.
Hantian Zhang, Jerry Li, Kaan Kara, Dan Alistarh, Ji Liu, and Ce Zhang. ZipML: Training linear models with end-to-end low precision, and a little bit of deep learning. In Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of Machine Learning Research, pp. 4035­4043, International Convention Centre, Sydney, Australia, 06­11 Aug 2017. PMLR. URL http://proceedings.mlr.press/v70/zhang17e.html.
Jian Zhang, Christopher De Sa, Ioannis Mitliagkas, and Christopher Ré. Parallel SGD: When does averaging help? arXiv, 2016.
Sixin Zhang, Anna Choromanska, and Yann LeCun. Deep learning with elastic averaging sgd. In NIPS, 2015. Yuchen Zhang, John C. Duchi, and Martin J. Wainwright. Communication-efficient algorithms for statistical
optimization. Journal of Machine Learning Research, 14:3321­3363, 2013. URL http://jmlr.org/ papers/v14/zhang13b.html. Peilin Zhao and Tong Zhang. Stochastic optimization with importance sampling for regularized loss minimization. In Francis Bach and David Blei (eds.), Proceedings of the 32nd International Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pp. 1­9, Lille, France, 07­09 Jul 2015. PMLR. URL http://proceedings.mlr.press/v37/zhaoa15.html. Zhengyuan Zhou, Panayotis Mertikopoulos, Nicholas Bambos, Peter Glynn, Yinyu Ye, Li-Jia Li, and Li Fei-Fei. Distributed asynchronous optimization with unbounded delays: How slow can you go? In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp. 5970­5979, Stockholmsmässan, Stockholm Sweden, 10­15 Jul 2018. PMLR. URL http://proceedings.mlr.press/v80/zhou18b.html. Martin Zinkevich, Markus Weimer, Lihong Li, and Alex J. Smola. Parallelized stochastic gradient descent. In J. D. Lafferty, C. K. I. Williams, J. Shawe-Taylor, R. S. Zemel, and A. Culotta (eds.), Advances in Neural Information Processing Systems 23, pp. 2595­2603. Curran Associates, Inc., 2010. URL http: //papers.nips.cc/paper/4006-parallelized-stochastic-gradient-descent.pdf.
11

Under review as a conference paper at ICLR 2019

A MISSING PROOFS FOR SYNCHRONIZED LOCAL SGD

In this section we provide the proofs for the three lemmas that were introduced in Section 3.

Proof of Lemma 3.1. Using the update equation (7) we have

x¯t+1 - x 2 = x¯t - tgt - x 2 = x¯t - tgt - x - tg¯t + tg¯t 2 = x¯t - x - tg¯t 2 + t2 gt - g¯t 2 + 2t x¯t - x - tg¯t, g¯t - gt .

(17) (18)

Observe that

x¯t - x

- tg¯t 2 = = 
=

x¯t - x 2 + t2 g¯t 2 - 2t x¯t - x , g¯t

x¯t - x

2 + t2

g¯t

2

-

2t

1 K

K

x¯t - x , f (xkt )

k=1

x¯t - x

2

+

t2

1 K

K

f (xkt ) 2

k=1

-

2t

1 K

K

x¯t - xtk + xtk - x , f (xtk)

k=1

x¯t - x

2

+

t2

1 K

K

f (xkt ) - f (x ) 2

k=1

-

2t

1 K

K

xkt - x , f (xkt )

-

2t

1 K

K

x¯t - xtk, f (xtk)

k=1

k=1

(19) (20) (21)
, (22)

where we used the inequality

K i=1

ai

2K

K i=1

ai 2 in (21). By L-smoothness,

f (xkt ) - f (x ) 2  2L(f (xtk) - f ) ,

(23)

and by µ-strong convexity

-

xkt - x , f (xtk)

 -(f (xtk) - f

)- µ 2

xkt - x

2.

(24)

To estimate the last term in (22) we use 2 a, b   a 2 + -1 b 2, for  > 0. This gives

-2 x¯t - xtk, f (xkt )

 2L

x¯t - xkt

2+ 1 2L

f (xtk) 2

= 2L

x¯t - xkt

2+ 1 2L

f (xkt ) - f (x ) 2

 2L x¯t - xtk 2 + (f (xkt ) - f ) ,

(25) (26) (27)

where we have again used (23) in the last inequality. By applying these three estimates to (22) we get

x¯t - x - tg¯t 2  x¯t - x

2

+

2t

L K

K

x¯t - xkt 2

k=1

1K + 2t K
k=1

tL

-

1 2

(f (xtk) - f

)- µ 2

xkt - x

2

.

(28)

For

t



1 4L

it

holds

tL

-

1 2



-

1 4

.

By

convexity

of

a

(f (x)

-

f

)+b

x-x

2 for a, b  0:

-1 K K

a(f (xkt ) - f ) + b xtk - x

2  - a(f (x¯t) - f ) + b x¯t - x 2

,

k=1

(29)

12

Under review as a conference paper at ICLR 2019

hence we can continue in (28) and obtain

x¯t - x - tg¯t 2  (1 - µt) x¯t - x

2

-

1 2 t(f (x¯t)

-

f

L ) + 2t K

K

x¯t - xkt 2 . (30)

k=1

Finally, we can plug (30) back into (18). By taking expectation we get

E x¯t+1 - x

2  (1 - µt) E x¯t - x 2 + t2 E gt - g¯t 2

-

1 2 t

E(f (x¯t)

-

f

L ) + 2t K

K

E

x¯t - xkt

2.

k=1

Proof of Lemma 3.2. By definition of gt and g¯t we have

E gt - g¯t 2 = E

1K K

fitk (xtk) - f (xkt )

k=1

2 1K = K2 E
k=1

fitk (xtk) - f (xtk)

2


2 ,
K

(31)

where we used Var(

K k=1

Xk )

=

K k=1

Var(Xk)

for

independent

random

variables.

Proof of Lemma 3.3. As the gap(IT )  H, there is an index t0, t - t0  H such that x¯t0 = xkt0 for

k  [K]. Observe, using E X - E X 2 = E X 2 - E X 2 and

H i=1

ai

2H

H i=1

ai 2,

1K KE
k=1

x¯t - xtk

2= 1 K

K

E

xtk - xt0 - (x¯t - xt0 ) 2

k=1

1 K

K

E

xtk - xt0

2

k=1

1 K

K

t-1

H t20

E

2
fikh (xkh)

k=1

h=t0

1 K

K

H 2t20 G2 ,

k=1

(32) (33) (34) (35)

where we used t  t0 for t  t0 and the assumption E

follows by the assumption on the stepsizes,

t0 t

 2.

fikh (xhk )

2



G2.

Finally, the claim

B MISSING PROOF FOR ASYNCHRONOUS LOCAL SGD

In this Section we prove Theorem 5.1. The proof follows closely the proof presented in Section 3. We again introduce the virtual sequence

x¯t

=

x0

-

1 K

K

t-1
j fikj (xkj ) ,

h=1 j=0

(36)

as before. By the property T  ITk for k  K we know that all workers will written their updates then the algorithm terminates. This assumption is not very critical and could be relaxed, but it facilitates the (already quite heavy) notation in the proof.
Observe, that Lemmas 3.1 and 3.2 hold for the virtual sequence {x¯t}Tt=0. Hence, all we need is a refined version of Lemma 3.3 that bounds how far the local sequences can deviate from the virtual average.

13

Under review as a conference paper at ICLR 2019

Lemma B.1. If gap(ITk )  H and  > 0, s.t. Wtk,h  [t -  ] for all k, h  [K], t  [T ], and sequence of decreasing positive stepsizes {t}t0 satisfying t  2t+H+ for all t  0, then

1 K

K

E

x¯t - xtk

2  12t2G2(H +  )2 ,

k=1

where G2 is a constant such that Ei fi(xtk) 2  G2 for k  [K], t  [T ].

(37)

Here we use the notation [s] = {} for s < 0, such that [t -  ] is also defined for t <  .

Proof. As gap(ITk )  H there exists for every k  K a tk, t - tk  H, such that xtkk = x¯ktk . Let t0 := min{t1, . . . , tK } and observe t0  t - H. Let t0 = max{t0 - , 0}. As Wtk,h  [t -  ] for all k, h  [K], t  [T ], it holds

x¯tkk

=

x¯t0

-

1 K

K

tk -1
1jWtkk,h (j j fikj (xkj )) ,

h=1 j=t0

(38)

for each k  [K]. In other words, all updates up to iteration t0 have been written to the aggregated sequence.

We decompose the error term as

x¯t - xkt 2  3 xtk - xktk 2 + xktk - x¯t0 2 + x¯t0 - x¯t 2 .

(39)

Now, using t  t+1, and t - tk  H, we conclude (as in (35))

xtk - xtkk 2  t2k H 2G2  t20 H 2G2 .

As tk - t0   ,

xtkk - x¯t0 2  t20  2G2 ,

and similarly, as t - t0  H +  ,

x~t0 - x~t 2  t20 (H +  )2G2 .

Finally, as

t0 t

 2, we can conclude

x¯t - xtk 2  12t2(H +  )2G2 .

and the lemma follows.

(40) (41) (42) (43)

Now the proof of Theorem 5.1 follows immediately.

Proof of Theorem 5.1. As in the proof of Theorem 2.2 we rely on Lemma 3.4 to derive the conver-

gence

rate.

Again

we

have

A

=

1 2

,

B

that the stepsizes satisfy the condition

= of

2 K

,

and

Lemma

C = LG2(H B.1, as clearly

+
t0 t

)2 

(Lemma
t0
t0 +H +

B.1). It is easy to see

=

a+t+H + a+t

 2, as

a  H + .

C COMMENTS ON IMPLEMENTATION ISSUES
C.1 SYNCHRONOUS LOCAL SGD
In Theorem 5 we do not prove convergence of the sequences {xtk}t0 of the iterates, but only convergence of a weighted average of all iterates. In practice, the last iterate might often be sufficient, but we like to remark that the weighted average of the iterates can easily be tracked on the fly with an auxiliary sequence {yt}t>0, y0 = x0, without storing all intermediate iterates, see Table 1 for some examples.

14

Under review as a conference paper at ICLR 2019

criteria last iterate uniform average linear weights
quadratic weights

weights wt = 1 wt = (t + 1) wt = (t + 1)2

formula

yt = xt

yt

=

1 t+1

t i=0

xi

yt

=

2 (1+t)(2+t)

t i=0

(i

+

1)xi

yt

=

6 (t+1)(t+2)(2t+3)

ti=0(i + 1)2xi

recursive update

yt = xt

yt

=

1 t+1

xt

+

t t+1

yt-1

yt

=

2 2+t

xt

+

t t+2

yt-1

yt

=

6(t+1) (t+2)(2t+3)

xt

+

t(1+2t) 6+7t+2t2

yt-1

Table 1: Formulas to recursively track weighted averages.

C.2 ASYNCHRONOUS LOCAL SGD
As for synchronous local SGD, the weighted averages of the iterates (if needed), can be tracked on each worker locally by a recursive formula as explained above.
A more important aspect that we do not have discussed yet, is that Algorithm 2 allows for an easy procedure to balance the load in heterogeneous settings. In our notation, we have always associated the local sequences {xtk} with a specific worker k. However, the computation of the sequences do not need to be tied to a specific worker. Thus, a fast worker k, that has advanced his local sequence too much already, can start computing updates for another sequence k = k, if worker k is lagged behind. This was not possible in the synchronous model, as there all communications had to happen in sync. We demonstrate this principle in Table 2 below for two workers. Note that also the running averages can still be maintained.

wall clock time worker 1 x1H  U(x¯) worker 2

 x21H  U(x¯) xH2  U(x¯)

 x13H  U(x¯)

 x22H  U(x¯)

 x24H  U(x¯) x32H  U(x¯)

 x41H  U(x¯)

 ··· ···

Table 2: Simple load balancing. The faster worker can advance both sequences, even when the slower
worker has not yet finished the computation. In the example each worker does H steps of local SGD (denoted by the operator U : Rd  Rd) before writing back the updates to the aggregate x¯. Due to the load balancing,   3H.

D DETAILS ON EXPERIMENTS

We here state the precise procedure that was used to generate the figures in this report. As briefly

stated in Section 4 we examine empirically the speedup on a logistic regression problem, f (x) =

1 n

n i=1

log(1

+

exp(-biai

x)) +

 2

x

2, where ai  Rd and bi  {-1, +1} are the data samples.

The regularization parameter is set to  = 1/n. We consider the small scale w8a dataset (Platt, 1999)

(d = 300, n = 49749).

For each run, we initialize x0 = 0d and measure the number of iterations (and number of stochastic gradient evaluations) to reach the target accuracy  {0.005, 0.0001}. As we prove convergence

only for a special weighted sum of the iterates in Theorem 2.2 and not for standard criteria (last

iterate or uniform average), we evaluate the function value for different weighted averages yt =

1

t i=0

wi

t i=0

wixt,

and

consider

the

accuracy

reached

when

one

of

the

averages

satisfies

f

(yt)

-

f  , with f := 0.126433176216545 (numerically determined). The precise formulas for the

averages that we used are given in Table 1.

For each configuration (K, H, b, ), we report the best result found with any of the following two

stepsizes:

t

:=

min(32,

cn t+1

)

and

t

=

32c.

Here

c

is

a

parameter

that

can

take

the

values

c

=

2i

for

i  Z. For each stepsize we determine the best parameter c by a grid search, and consider parameter

c optimal, if parameters {2-2c, 2-1c, 2c, 22c} yield worse results (i.e. more iterations to reach the

target accuracy).

In Figures 4 and 5 we give additional results5 for mini-batch sizes b  {1, 16}.

5Unfinished runs in all figures will be included in the final version.

15

Under review as a conference paper at ICLR 2019

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1 4 16 64 256 1024

1 4 16 64 256 1024

(a) Measured speedup, = 0.005.

(b) Measured speedup, = 0.0001.

Figure 4: Measured speedup of local SGD with mini-batch b = 1 for different numbers of workers K and parameters H.

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1024 256 64 16 4 1

H=1 H=4 H=16 H=64 H=256

1 4 16 64 256 1024

1 4 16 64 256 1024

(a) Measured speedup, = 0.005.

(b) Measured speedup, = 0.0001.

Figure 5: Measured speedup of local SGD with mini-batch b = 16 for different numbers of workers K and parameters H.

16

