Under review as a conference paper at ICLR 2019
RIEMANNIAN ADAPTIVE OPTIMIZATION METHODS
Anonymous authors Paper under double-blind review
ABSTRACT
Several first order stochastic optimization methods commonly used in the Euclidean domain such as stochastic gradient descent (SGD), accelerated gradient descent or variance reduced methods have already been adapted to certain Riemannian settings. However, some of the most popular of these optimization tools - namely ADAM, ADAGRAD and the more recent AMSGRAD - remain to be generalized to Riemannian manifolds. We discuss the difficulty of generalizing such adaptive schemes to the most agnostic Riemannian setting, and then provide algorithms and convergence proofs for geodesically convex objectives in the particular case of a product of Riemannian manifolds, in which adaptivity is implemented across manifolds in the cartesian product. Our generalization is tight in the sense that choosing the Euclidean space as Riemannian manifold yields the same algorithms and regret bounds as those that were already known for the standard algorithms. Experimentally, we show faster convergence and to a lower train loss value for Riemannian adaptive methods over their corresponding baselines on the realistic task of embedding the WordNet taxonomy in the Poincare´ ball.
1 INTRODUCTION
Developing powerful stochastic gradient-based optimization algorithms is of major importance for a variety of application domains. It particular, for computational efficiency, it is common to opt for a first order method, when the number of parameters to be optimized is great enough. Such cases have recently become ubiquitous in engineering and computational sciences, from the optimization of deep neural networks to learning embeddings over large vocabularies.
This new need resulted in the development of empirically very successful first order methods such as ADAGRAD (Duchi et al., 2011), ADADELTA (Zeiler, 2012), ADAM (Kingma & Ba, 2015) or its recent update AMSGRAD (Reddi et al., 2018). Note that these algorithms are designed to optimize parameters living in a Euclidean space Rn, which has often been considered as the default geometry to be used for continuous variables. However, a recent line of work has been concerned with the optimization of parameters lying on a Riemannian manifold, a more general setting allowing non-Euclidean geometries. This family of algorithms has already found numerous applications, including for instance solving Lyapunov equations (Vandereycken & Vandewalle, 2010), matrix factorization (Tan et al., 2014), geometric programming (Sra & Hosseini, 2015), dictionary learning (Cherian & Sra, 2017) or hyperbolic taxonomy embedding (Nickel & Kiela, 2017; Ganea et al., 2018a; De Sa et al., 2018; Nickel & Kiela, 2018).
A few first order stochastic methods have already been generalized to this setting (see section 6), the seminal one being Riemannian stochastic gradient descent (RSGD) (Bonnabel, 2013), along with new methods for their convergence analysis in the geodesically convex case (Zhang & Sra, 2016). However, the above mentioned empirically successful adaptive methods, together with their convergence analysis, remain to find their respective Riemannian counterparts.
Indeed, the adaptivity of these algorithms can be thought of as assigning one learning rate per coordinate of the parameter vector. However, on a Riemannian manifold, one is generally not given an intrinsic coordinate system, rendering meaningless the notions sparsity or coordinate-wise update.
Our contributions. In this work we (i) explain why generalizing these adaptive schemes to the most agnostic Riemannian setting in an intrinsic manner is compromised, and (ii) propose generalizations of the algorithms together with their convergence analysis in the particular case of a product of
1

Under review as a conference paper at ICLR 2019

manifolds where each manifold represents one "coordinate" of the adaptive scheme. Finally, we (iii) empirically support our claims on the realistic task of hyperbolic taxonomy embedding.
Our initial motivation. The particular application that motivated us in developing Riemannian versions of ADAGRAD and ADAM was the learning of symbolic embeddings in non-Euclidean spaces. As an example, the GloVe algorithm (Pennington et al., 2014) - an unsupervised method for learning Euclidean word embeddings capturing semantic/syntactic relationships - benefits significantly from optimizing with ADAGRAD compared to using SGD, presumably because different words are sampled at different frequencies. Hence the absence of Riemannian adaptive algorithms could constitute a significant obstacle to the development of competitive optimization-based Riemannian embedding methods. In particular, we believe that the recent rise of embedding methods in hyperbolic spaces could benefit from such developments (Nickel & Kiela, 2017; 2018; Ganea et al., 2018a;b; De Sa et al., 2018; Vinh et al., 2018).

2 PRELIMINARIES AND NOTATIONS

2.1 DIFFERENTIAL GEOMETRY
We recall here some elementary notions of differential geometry. For more in-depth expositions, we refer the interested reader to Spivak (1979) and Robbin & Salamon (2011).

Manifold, tangent space, Riemannian metric. A manifold M of dimension n is a space that can locally be approximated by a Euclidean space Rn, and which can be understood as a generalization to higher dimensions of the notion of surface. For instance, the sphere S := {x  Rn | x 2 = 1} embedded in Rn is an (n - 1)-dimensional manifold. In particular, Rn is a very simple n-dimensional manifold, with zero curvature. At each point x  M, one can define the tangent space TxM, which is an n-dimensional vector space and can be seen as a first order local approximation of M around x.
A Riemannian metric  is a collection  := (x)xM of inner-products x(·, ·) : TxM × TxM  R on TxM, varying smoothly with x. It defines the geometry locally on M. For x  M and u  TxM,
we also write u x := x(u, u). A Riemannian manifold is a pair (M, ).

Induced distance function, geodesics. Notice how a choice of a Riemannian metric  induces a

natural global distance function on M. Indeed, for x, y  M, we can set d(x, y) to be equal to the

infimum of the lengths of smooth paths between x and y in M, where the length (c) of a path c is

given by integrating the size of its speed vector c(t)  Tc(t)M, in the corresponding tangent space:

(c) :=

1 t=0

c(t) c(t)dt. A geodesic  in (M, ) is a smooth curve  : (a, b)  M which locally

has minimal length. In particular, a shortest path between two points in M is a geodesic.

Exponential and logarithmic maps. Under some assumptions, one can define at point x  M the exponential map expx : TxM  M. Intuitively, this map folds the tangent space on the manifold. Locally, if v  TxM, then for small t, expx(tv) tells us how to move in M as to take a shortest path from x with initial direction v. In Rn, expx(v) = x + v. In some cases, one can also define the logarithmic map logx : M  TxM as the inverse of expx.

Parallel transport. In the Euclidean space, if one wants to transport a vector v from x to y, one simply translates v along the straight-line from x to y. In a Riemannian manifold, the resulting transported vector will depend on which path was taken from x to y. The parallel transport Px(v; w) of a vector v from a point x in the direction w and in a unit time, gives a canonical way to transport v with zero acceleration along a geodesic starting from x, with initial velocity w.

2.2 RIEMANNIAN OPTIMIZATION Consider performing an SGD update of the form
xt+1  xt - gt,

(1)

2

Under review as a conference paper at ICLR 2019

where gt denotes the gradient of objective ft1 and  > 0 is the step-size. In a Riemannian manifold (M, ), for smooth f : M  R, Bonnabel (2013) defines Riemannian SGD by the following update:

xt+1  expxt (-gt),

(2)

where gt  Txt M denotes the Riemannian gradient of ft at xt. Note that when (M, ) is the Euclidean space (Rn, In), these two match, since we then have expx(v) = x + v.

Intuitively, applying the exponential map enables to perform an update along the shortest path in the relevant direction in unit time, while remaining in the manifold.

In practice, when expx(v) is not known in closed-form, it is common to replace it by a retraction map Rx(v), most often chosen as Rx(v) = x + v, which is a first-order approximation of expx(v).

2.3 AMSGRAD, ADAM, ADAGRAD Let's recall here the main algorithms that we are taking interest in.

ADAGRAD. Introduced by Duchi et al. (2011), the standard form of its update step is defined as2

xti+1  xti - gti/

t
(gki )2.
k=1

(3)

Such updates rescaled coordinate-wise depending on the size of past gradients can yield huge improvements when gradients are sparse, or in deep networks where the size of a good update may depend on the layer. However, the accumulation of all past gradients can also slow down learning.

ADAM. Proposed by Kingma & Ba (2015), the ADAM update rule is given by

xit+1  xti - mit/ vti,

(4)

where mt = 1mt-1 + (1 - 1)gt can be seen as a momentum term and vti = 2vti-1 + (1 - 2)(gti)2 is an adaptivity term. When 1 = 0, one essentially recovers the unpublished method RMSPROP (Tieleman & Hinton, 2012), the only difference to ADAGRAD being that the sum is replaced by
an exponential moving average, hence past gradients are forgotten over time in the adaptivity term
vt. This circumvents the issue of ADAGRAD that learning could stop too early when the sum of accumulated squared gradients is too significant. Let us also mention that the momentum term
introduced by ADAM for 1 = 0 has been observed to often yield huge empirical improvements.

AMSGRAD. More recently, Reddi et al. (2018) identified a mistake in the convergence proof of ADAM. To fix it, they proposed to either modify the ADAM algorithm with

xti+1  xti - mit/ v^ti, where v^ti = max{v^ti-1, vti},

(5)

which they coin AMSGRAD, or to choose an increasing schedule for 2, making it time dependent, which they call ADAMNC (for non-constant).

3 ADAPTIVE SCHEMES IN RIEMANNIAN MANIFOLDS
3.1 THE DIFFICULTY OF DESIGNING ADAPTIVE SCHEMES IN THE GENERAL SETTING
Intrinsic updates. It is easily understandable that writing any coordinate-wise update requires the choice of a coordinate system. However, on a Riemannian manifold (M, ), one is generally not provided with a canonical coordinate system. The formalism only allows to work with certain local coordinate systems, also called charts, and several different charts can be defined around each point x  M. One usually says that a quantity defined using a chart is intrinsic to M if its definition does
1to be interpreted as the objective with the same parameters, evaluated at the minibatch taken at time t. 2a small  = 10-8 is often added in the square-root for numerical stability, omitted here for simplicity.

3

Under review as a conference paper at ICLR 2019

not depend on which chart was used. For instance, it is known that the Riemannian gradient gradf of a smooth function f : M  R can be defined intrinsically to (M, ), but its Hessian is only intrinsically defined at critical points. It is easily seen that the RSGD update of Eq. (2) is intrinsic, since it only involves exp and grad, which are objects intrinsic to (M, ). However, it is unclear
whether it is possible at all to express either of Eqs. (3,4,5) in a coordinate-free or intrinsic manner.

A tempting solution. Note that since an update is defined in a tangent space, one could be tempted
to fix a canonical coordinate system e := (e(1), ..., e(n)) in the tangent space Tx0 M Rd at the initialization x0  M, and parallel-transport e along the optimization trajectory, adapting Eq. (3) to:

xt+1  expxt (t), et+1  Pxt (et; t), with t := -gt

t
(gk )2 ,
k=1

(6)

where and (·)2 denote coordinate-wise division and square respectively, these operations being taken relatively to coordinate system et. In the Euclidean space, parallel transport between two points x and y does not depend on the path it is taken along because the space has no curvature. However, in a general Riemannian manifold, not only does it depend on the chosen path but curvature will also give to parallel transport a rotational component3, which will almost surely break the sparsity of the gradients and hence the benefit of adaptivity. Besides, the interpretation of adaptivity as optimizing different features (i.e. gradient coordinates) at different speeds is also completely lost here, since the coordinate system used to represent gradients depends on the optimization path. Finally, note that the techniques we used to prove our theorems would not apply to updates defined in the vein of Eq. (6).

3.2 ADAPTIVITY IS POSSIBLE ACROSS MANIFOLDS IN A PRODUCT

From now on, we assume additional structure on (M, ), namely that it is the cartesian product of n Riemannian manifolds (Mi, i), where  is the induced product metric:

1 

M := M1 × · · · × Mn,

 :=  

...

. 

n

(7)

Product notations. The induced distance function d on M is known to be given by d(x, y)2 =

n i=1

di(xi,

yi)2,

where

di

is

the

distance

in

Mi.

The

tangent

space

at

x

=

(x1,

...,

xn)

is

given

by

TxM = Tx1 M1  · · ·  Txn Mn, and the Riemannian gradient g of a smooth function f : M  R

at point x  M is simply the concatenation g = ((g1)T · · · (gn)T )T of the Riemannian gradients

gi  Txi Mi of each partial map f i : y  Mi  f (x1, ..., xi-1, y, xi+1, ..., xn). Similarly, the

exponential, log map and the parallel transport in M are the concatenations of those in each Mi.

Riemannian ADAGRAD. We just saw in the above discussion that designing meaningful adaptive schemes - intuitively corresponding to one learning rate per coordinate - in a general Riemannian
manifold was difficult, because of the absence of intrinsic coordinates. Here, we propose to see each component xi  Mi of x as a "coordinate", yielding a simple adaptation of Eq. (3) as

 xit+1  expixti -gti/


t

gki

2 xik



.

k=1

(8)

On the adaptivity term.

Note that we take (squared) Riemannian norms

gti

2 xit

=

ixti (gti, gti)

in

the adaptivity term rescaling the gradient. In the Euclidean setting, this quantity is simply a scalar

(gti)2, which is related to the size of an SGD update of the ith coordinate, rescaled by the learning rate (see Eq. (1)): |gti| = |xit+1 - xit|/. By analogy, note that the size of an RSGD update in

Mi (see Eq. (2)) is given by di(xti+1, xit) = di(expxi ti (-gti), xit) = - gti xti , hence we also

recover

gti xit = di(xti+1, xti)/, which indeed suggests replacing the scalar (gti)2 by

gti

2 xti

when

transforming a coordinate-wise adaptive scheme into a manifold-wise adaptive one.

3The rotational component of parallel transport inherited from curvature is called the holonomy.

4

Under review as a conference paper at ICLR 2019

4 RAMSGRAD, RADAMNC: CONVERGENCE GUARANTEES

In section 2, we briefly presented ADAGRAD, ADAM and AMSGRAD. Intuitively, ADAM can be
described as a combination of ADAGRAD with a momentum (of parameter 1), with the slight modification that the sum of the past squared-gradients is replaced with an exponential moving
average, for an exponent 2. Let's also recall that AMSGRAD implements a slight modification of ADAM, allowing to correct its convergence proof. Finally, ADAMNC is simply ADAM, but with a
particular non-constant schedule for 1 and 2. On the other hand, what is interesting to note is that the schedule initially proposed by Reddi et al. (2018) for 2 in ADAMNC, namely 2t := 1 - 1/t, lets vt recover the sum of squared-gradients of ADAGRAD. Hence, ADAMNC without momentum (i.e. 1t = 0) yields ADAGRAD.

Assumptions and notations. For 1  i  n, we assume (Mi, i) is a geodesically complete

Riemannian manifold with sectional curvature lower bounded by i  0. As written in Eq. (7), let

(M, ) be the product manifold of the (Mi, i)'s. For each i, let Xi  Mi be a compact, geodesically

convex set and define X := X1 × · · · × Xn, the set of feasible parameters. Define Xi : Mi  Xi to be the projection operator, i.e. Xi (x) is the unique y  Xi minimizing di(y, x). Denote by P i, expi

and logi the parallel transport, exponential and log maps in (Mi, i), respectively. For f : M  R,

if g = gradf (x) for x  M, denote by xi  Mi and by gi  Txi Mi the corresponding components

of x and g. In the sequel, let (ft) be a family of differentiable, geodesically convex functions from M

to R. Assume that each Xi  Mi has a diameter bounded by D and that for all 1  i  n, t  [T ]

and x  X , (gradft(x))i xi  G. Finally, our convergence guarantees will bound the regret,

defined at the end of T rounds as RT =

T t=1

ft(xt)

-

minxX

T j=1

fj

(x),

so

that

RT

=

o(T ).

Following the discussion in section 3.2 and especially Eq. (8), we present Riemannian AMSGRAD4 in Figure 1a. For comparison, we show next to it the standard AMSGRAD algorithm in Figure 1b.

Require: x1  X , {t}Tt=1, {1t}Tt=1, 2 Set m0 = 0, 0 = 0, v0 = 0 and v^0 = 0

for t = 1 to T do

gt = gradft(xt)

mti = 1tti-1 + (1 - 1t)gti

vti = 2vti-1 + (1 - 2)

gti

2 xti

v^ti = max{v^ti-1, vti}

xit+1 = Xi (expxi ti (-tmti/
ti = Pxiti (mti; -tmit/ v^ti) end for

v^ti))

(a) RAMSGRAD in M1 × · · · × Mn.

Require: x1  X , {t}Tt=1, {1t}Tt=1, 2 Set m0 = 0, v0 = 0 and v^0 = 0 for t = 1 to T do gt = gradft(xt) mit = 1tmti-1 + (1 - 1t)gti vti = 2vti-1 + (1 - 2)(gti)2 v^ti = max{v^ti-1, vti} xit+1 = Xi (xti - tmti/ v^ti) end for
(b) AMSGRAD in Rn.

Figure 1: Comparison of the Riemannian and Euclidean versions of AMSGRAD.

As can be seen, if (Mi, i) = R for all i, RAMSGRAD and AMSGRAD coincide: we then have i = 0,

di(xi, yi) = |xi - yi|, P i = Id, expxi i (vi) = xi + vi, M1 × · · · × Mn = Rn,

gti

2 xit

=

(gti)2



R.

From these algorithms, RADAM and ADAM are obtained simply by removing the max operations,

i.e. replacing v^ti = max{v^ti-1, vti} with v^ti = vti. The convergence guarantee that we obtain for

RAMSGRAD is presented in Theorem 1, where the quantity  is defined by Zhang & Sra (2016) as

(, c)

:=

c || tanh(c ||)

=

1+

c || 3

+ O0(2).

(9)

For comparison, we also show the convergence guarantee of the original AMSGRAD in appendix C. Note that when (Mi, i) = R for all i, convergence guarantees between RAMSGRAD and AMSGRAD coincide as well. Indeed, the curvature dependent quantity ((i, D) + 1)/2 in the Riemannian case then becomes equal to 1, recovering the convergence theorem of AMSGRAD. It is also interesting

4The idea of parallel-transporting mt from Txt M to Txt+1 M previously appeared in Cho & Lee (2017).

5

Under review as a conference paper at ICLR 2019

to understand at which speed does the regret bound worsen when the curvature is small but non-zero: by a multiplicative factor of approximately 1 + D||/6 (see Eq.(9)). Similar remarks hold for RADAMNC, whose convergence guarantee is shown in Theorem 2. Finally, notice that 1 := 0 in Theorem 2 yields a convergence proof for RADAGRAD, whose update rule we defined in Eq. (8).

Theorem 1 (Convergence of RAMSGRAD). Let (xt) and (v^t) be the sequences obtained from Algorithm 1a, t = / t, 1 = 11, 1t  1 for all t  [T ] and  = 1/ 2 < 1. We then have:

RT



 T D2
2(1 - 1)

n i=1

v^Ti

+

D2 2(1 - 1)

n i=1

T t=1

1t

v^ti + t

  1 + logT

n (i, D) + 1

(1 - 1)2(1 - ) 1 - 2 i=1

2

T

gti

2 xit

.

t=1

(10)

Proof. See appendix A.

Theorem 2 RADAMNC,

(Convergence of t = / t, 1 =

RADAMNC). Let (xt 11, 1t = 1t-1, 

) and (vt) < 1, 2t =

be the sequences obtained 1 - 1/t. We then have:

from

n
RT 
i=1

D 2(1 - 1)

+

((i, D) + (1 - 1)3

1)

T t=1

gti

2 xti

+

1D2 Gn 2(1 - 1)(1 -

)2

.

(11)

Proof. See appendix B.

The role of convexity. Note how the notion of convexity in Theorem 5 got replaced by the notion
of geodesic convexity in Theorem 1. Let us compare the two definitions: the differentiable functions f : Rn  R and g : M  R are respectively convex and geodesically convex if for all x, y  Rn, u, v  M:

f (x) - f (y)  gradf (x), x - y , g(u) - g(v)  u(gradg(u), - logu(v)). (12)

But how does this come at play in the proofs? Regret bounds for convex objectives are usually

obtained by bounding

T t=1

ft(xt)

-

ft(x)

using

Eq.

(12)

for

any

x



X

,

which

boils

down

to

bounding each gt, xt - x . In the Riemannian case, this term becomes xt (gt, - logxt (x)).

The role of the cosine law. How does one obtain a bound on gt, xt - x ? For simplicity, let us look at the particular case of an SGD update, from Eq. (1). Using a cosine law, this yields

gt, xt - x

1 =
2

xt - x 2 -

xt+1 - x 2

 +
2

gt 2.

(13)

One now has two terms to bound: (i) when summing over t, the first one simplifies as a telescopic

summation; (ii) the second term

T t=1

t

gt

2 will require a well chosen decreasing schedule for .

In Riemannian manifolds, this step is generalized using the analogue lemma 6 introduced by Zhang &

Sra (2016), valid in all Alexandrov spaces, which includes our setting of geodesically convex subsets

of Riemannian manifolds with lower bounded sectional curvature. The curvature dependent quantity

 of Eq. (10) appears from this lemma, letting us bound xi ti (gti, - logxi ti (xi )).

The benefit of adaptivity. Let us also mention that the above bounds significantly improve for
sparse (per-manifold) gradients. In practice, this could happen for instance for algorithms embedding each word i (or node of a graph) in a manifold Mi and when just a few words are updated at a time.

5 EXPERIMENTS
We empirically assess the quality of the proposed algorithms: RADAM, RAMSGRAD and RADAGRAD compared to the non-adaptive RSGD method (Eq. 2). For this, we follow (Nickel & Kiela, 2017) and embed the transitive closure of the WordNet noun hierarchy (Miller et al., 1990) in the n-dimensional

6

Under review as a conference paper at ICLR 2019

Poincare´ model Dn of hyperbolic geometry which is well-known to be better suited to embed tree-like
graphs than the Euclidean space (Gromov, 1987; De Sa et al., 2018). In this case, each word is embedded in the same space of constant curvature -1, thus Mi = Dn, i. The choice of the Poincare´ model is justified by the access to closed form expressions for all the quantities used in Alg. 1a:

·

Metric tensor: x

= 2xIn, x  Dn, where x

=

2 1- x

2

is the conformal factor.

· Riemannian gradients are rescaled Euclidean gradients: gradf (x) = (1/x2 )Ef (x).

· Distance function and geodesics, (Nickel & Kiela, 2017; Ungar, 2008; Ganea et al., 2018b).

· Exponential and logarithmic maps: expx(v) = x 

tanh

x v 2

generalized Mobius addition (Ungar, 2008; Ganea et al., 2018b).

v v

, where  is the

·

Parallel transport:

Pxy (v)

=

Px(v; w)

=

x y

· gyr[y, -x]v,

where y

=

expx(w).

This

formula was derived from (Ungar, 2008; Ganea et al., 2018b), gyr being given in closed

form in (Ungar, 2008, Eq. (1.27)).

Dataset & Model. The transitive closure of the WordNet taxonomy graph consists of 82,115 nouns and 743,241 hypernymy Is-A relations (directed edges E). These words are embedded in Dn such that
the distance between words connected by an edge is minimized, while being maximized otherwise.
We minimize the same loss function as (Nickel & Kiela, 2017) which is similar with log-likelihood,
but approximating the partition function using sampling of negative word pairs (non-edges), fixed to 10 in our case. Note that this loss does not use the direction of the edges in the graph5

L() =
(u,v)E

e-dD (u,v ) u N (v) e-dD(u ,v)

(14)

Metrics. We report both the loss value and the mean average precision (MAP) (Nickel & Kiela, 2017): for each directed edge (u, v), we rank its distance d(u, v) among the full set of ground truth negative examples {d(u , v)|(u , v) / E}. We use the same two settings as (Nickel & Kiela, 2017), namely: reconstruction (measuring representation capacity) and link prediction (measuring generalization). For link prediction we sample a validation set of 2% edges from the set of transitive closure edges that contain no leaf node or root. We only focused on 5-dimensional hyperbolic spaces.

Training details. For all methods we use the same "burn-in phase" described in (Nickel & Kiela, 2017) for 20 epochs, with a fixed learning rate of 0.03 and using RSGD with retraction as explained in Sec. 2.2. Solely during this phase, we sampled negative words based on their graph degree raised at power 0.75. This strategy improves all metrics. After that, when different optimization methods start, we sample negatives uniformly.

Optimization methods. Experimentally we obtained slightly better results for RADAM over RAMS-
GRAD, so we will mostly report the former. Moreover, we unexpectedly observed convergence to lower loss values when replacing the true exponential map with its first order approximation - i.e. the projected retraction Rx(v) = x + v - in both RSGD and in our adaptive methods from Alg. 1a. One possible explanation is that retraction methods need fewer steps and smaller gradients to "escape"
points sub-optimally collapsed on the ball border of D compared to full Riemannian methods. As a consequence, we report "retraction"-based methods in a separate setting as they are not directly
comparable with their fully Riemannian analogues.

Results. We show in Tables 2 and 3 results for "exponential" based and "retraction" based methods. We ran all our methods with different learning rates from the set {0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1.0, 3.0}. For the RSGD baseline we show in orange the best learning rate setting, but we also show the previous lower (slower convergence, in blue) and the next higher (faster overfitting, in green) learning rates. For RADAM and RAMSGRAD we only show the best settings. We always use 1 = 0.9 and 2 = 0.999 for these methods as these achieved the lowest training loss. RADAGRAD was consistently worse, so we do not report it.
5In a pair (u, v), u denotes the parent, i.e. u entails v.

7

Under review as a conference paper at ICLR 2019
Figure 2: Results for methods doing updates with the exponential map. From left to right we report: training loss, MAP on the train set, MAP on the validation set.
Figure 3: Results for methods doing updates with the retraction. From left to right we report: training loss, MAP on the train set, MAP on the validation set.
As one can see, RADAM always achieves the lowest training loss. On the MAP metric for both reconstruction and link prediction settings, the same method also outperforms all the other methods for the full Riemannian setting (i.e. Tab. 2). Interestingly, in the "retraction" setting, RADAM reaches the lowest training loss value and is on par with RSGD on the MAP evaluation for both reconstruction and link prediction settings. However, RAMSGRAD is faster to converge in terms of MAP for the link prediction task, suggesting that this method has a better generalization capability.
6 RELATED WORK
After Riemannian SGD was introduced by Bonnabel (2013), a pletora of other first order Riemannian methods arose, such as Riemannian SVRG (Zhang et al., 2016), Riemannian Stein variational gradient descent (Liu & Zhu, 2017), Riemannian accelerated gradient descent (Liu et al., 2017; Zhang & Sra, 2018) or averaged RSGD (Tripuraneni et al., 2018), along with new methods for their convergence analysis in the geodesically convex case (Zhang & Sra, 2016). Stochastic gradient Langevin dynamics was generalized as well, to improve optimization on the probability simplex (Patterson & Teh, 2013). Let us also mention that a first version of Riemannian ADAM for the Grassmann manifold G(1, n) was previously introduced by Cho & Lee (2017), proposing to transport the momentum term using parallel translation, which is an idea that we preserved. However, their algorithm completely removes the adaptive component, since the adaptivity term vt becomes a scalar. No adaptivity across manifolds is discussed, which is the main point of our discussion. Moreover, no convergence analysis is provided.
7 CONCLUSION
Driven by recent work in learning non-Euclidean embeddings for symbolic data, we propose to generalize popular adaptive optimization tools (e.g. ADAM, AMSGRAD, ADAGRAD) to Cartesian products of Riemannian manifolds in a principled and intrinsic manner. We derive convergence rates that are similar with the Euclidean corresponding models. Experimentally we show that our methods outperform popular non-adaptive methods such as RSGD on the realistic task of hyperbolic word taxonomy embedding.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Peter Auer, Nicolo Cesa-Bianchi, and Claudio Gentile. Adaptive and self-confident on-line learning algorithms. Journal of Computer and System Sciences, 64(1):48­75, 2002.
Silvere Bonnabel. Stochastic gradient descent on riemannian manifolds. IEEE Transactions on Automatic Control, 58(9):2217­2229, 2013.
Anoop Cherian and Suvrit Sra. Riemannian dictionary learning and sparse coding for positive definite matrices. IEEE transactions on neural networks and learning systems, 28(12):2859­2871, 2017.
Minhyung Cho and Jaehyung Lee. Riemannian approach to batch normalization. In Advances in Neural Information Processing Systems, pp. 5225­5235, 2017.
Christopher De Sa, Albert Gu, Christopher Re´, and Frederic Sala. Representation tradeoffs for hyperbolic embeddings. 2018. URL https://www.cs.cornell.edu/~cdesa/papers/ arxiv2018_hyperbolic.pdf.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 12(Jul):2121­2159, 2011.
Octavian-Eugen Ganea, Gary Be´cigneul, and Thomas Hofmann. Hyperbolic entailment cones for learning hierarchical embeddings. In International Conference on Machine Learning, 2018a.
Octavian-Eugen Ganea, Gary Be´cigneul, and Thomas Hofmann. Hyperbolic neural networks. In Advances in Neural Information Processing Systems, 2018b.
Mikhael Gromov. Hyperbolic groups. In Essays in group theory, pp. 75­263. Springer, 1987.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International Conference on Learning Representations, 2015.
Chang Liu and Jun Zhu. Riemannian stein variational gradient descent for bayesian inference. arXiv preprint arXiv:1711.11216, 2017.
Yuanyuan Liu, Fanhua Shang, James Cheng, Hong Cheng, and Licheng Jiao. Accelerated first-order methods for geodesically convex optimization on riemannian manifolds. In Advances in Neural Information Processing Systems 30, pp. 4868­4877. 2017.
George A Miller, Richard Beckwith, Christiane Fellbaum, Derek Gross, and Katherine J Miller. Introduction to wordnet: An on-line lexical database. International journal of lexicography, 3(4): 235­244, 1990.
Maximilian Nickel and Douwe Kiela. Learning continuous hierarchies in the lorentz model of hyperbolic geometry. In International Conference on Machine Learning, 2018.
Maximillian Nickel and Douwe Kiela. Poincare´ embeddings for learning hierarchical representations. In Advances in Neural Information Processing Systems, pp. 6341­6350, 2017.
Sam Patterson and Yee Whye Teh. Stochastic gradient riemannian langevin dynamics on the probability simplex. In Advances in Neural Information Processing Systems, pp. 3102­3110, 2013.
Jeffrey Pennington, Richard Socher, and Christopher D Manning. Glove: Global vectors for word representation. In EMNLP, volume 14, pp. 1532­43, 2014.
Sashank J Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In ICLR, 2018.
Joel W Robbin and Dietmar A Salamon. Introduction to differential geometry. ETH, Lecture Notes, preliminary version, January, 2011.
Michael Spivak. A comprehensive introduction to differential geometry. volume four. 1979.
Suvrit Sra and Reshad Hosseini. Conic geometric optimization on the manifold of positive definite matrices. SIAM Journal on Optimization, 25(1):713­739, 2015.
9

Under review as a conference paper at ICLR 2019
Mingkui Tan, Ivor W Tsang, Li Wang, Bart Vandereycken, and Sinno Jialin Pan. Riemannian pursuit for big matrix recovery. In International Conference on Machine Learning, pp. 1539­1547, 2014.
Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26­31, 2012.
Nilesh Tripuraneni, Nicolas Flammarion, Francis Bach, and Michael I Jordan. Averaging stochastic gradient descent on riemannian manifolds. In Conference On Learning Theory, COLT 2018, Stockholm, Sweden, 6-9 July 2018., 2018.
Abraham Albert Ungar. A gyrovector space approach to hyperbolic geometry. Synthesis Lectures on Mathematics and Statistics, 1(1):1­194, 2008.
Bart Vandereycken and Stefan Vandewalle. A riemannian optimization approach for computing low-rank solutions of lyapunov equations. SIAM Journal on Matrix Analysis and Applications, 31 (5):2553­2579, 2010.
Tran Dang Quang Vinh, Yi Tay, Shuai Zhang, Gao Cong, and Xiao-Li Li. Hyperbolic recommender systems. arXiv preprint arXiv:1809.01703, 2018.
Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.
Hongyi Zhang and Suvrit Sra. First-order methods for geodesically convex optimization. In Conference on Learning Theory, pp. 1617­1638, 2016.
Hongyi Zhang and Suvrit Sra. Towards riemannian accelerated gradient methods. arXiv preprint arXiv:1806.02812, 2018.
Hongyi Zhang, Sashank J Reddi, and Suvrit Sra. Riemannian svrg: Fast stochastic optimization on riemannian manifolds. In Advances in Neural Information Processing Systems, pp. 4592­4600, 2016.
10

Under review as a conference paper at ICLR 2019

A PROOF OF THEOREM 1

Proof. Denote by x~ti+1 := expxi it (-tmti/ v^ti) and consider the geodesic triangle defined by x~ti+1, xit and xi. Now let a = di(x~ti+1, xi), b = di(x~it+1, xti), c = di(xti, xi) and A = x~it+1xitxi . Combining the following formula6:

di(xti, x~ti+1)di(xit, xi ) cos(x~it+1xtixi ) = -tmit/ v^ti, logixit (xi ) xit , with the following inequality (given by lemma 6):

(15)

yields

a2  (, c)b2 + c2 - 2bc cos(A), with (, c) :=

||c ,

tanh( ||c)

(16)

-mit, logxi ti (xi ) xti 

v^ti 2t

di(xti, xi )2 - di(x~ti+1, xi )2

+



(i,

di(xti

,

xi

))

2

t v^ti

mti

2 xit

,

(17)

where the use the notation ·, · xi for ixi (·, ·) when it is clear which metric is used. By definition of Xi , we can safely replace x~it+1 by xit+1 in the above inequality. From now on, for

simplicity, we will use the notation Pxitixit+1 (·) to designate Pxiti (· ; -tmit/ v^ti). Plugging

mti

=

1t

Pi
xit-1

xit

(mit-1

)

+

(1

-

1t)gti

into

Eq.

(17)

gives

us

-gti, logxti (xi )

xit



v^ti 2t(1 - 1t)

di(xti, xi)2 - di(xit+1, xi )2

+



(i

,

di

(xit,

xi ))

2(1

-

t 1t)

v^ti

mti

2 xit

+

1t (1 - 1t)

Pi
xit-1

xit

(mti-1

),

logxit

(xi

)

xti .

(18)

Now applying Cauchy-Schwarz' and Young's inequalities to the last term yields

-gti, logxit (xi)

xit



v^ti 2t(1 - 1t)

di(xti, xi)2 - di(xit+1, xi )2

+



(i

,

di

(xit,

xi))

2(1

-

t 1t)

v^ti

mti

2 xit

+

1t 2(1 - 1t)

t v^ti

mit-1

2 xti-1

+

1t 2(1 - 1t)

v^ti t

logxit (xi )

2 xti

.

(19)

From the geodesic convexity of ft for 1  t  T , we have

TT

nT

ft(xt) - ft(x) 

-gt, logxt (x) xt =

-gti, logixit (xi) xti .

t=1 t=1

i=1 t=1

(20)

6Note that since each Xi is geodesically convex, logarithms are well-defined.

11

Under review as a conference paper at ICLR 2019

Let's look at the first term. Using 1t  1 and with a change of indices, we have

nT

v^ti

i=1 t=1 2t(1 - 1t)

di(xit, xi )2 - di(xit+1, xi )2





1 2(1 - 1)

n

i=1

T

t=2

v^ti t

-

v^ti-1 t-1

 

di (xti ,

xi)2

+

n i=1



v^1i 1

di

(xi1,

xi)2

(21) (22)



1 nT



2(1 - 1)


i=1


t=2

v^ti t

-

v^ti-1 t-1

 

D2

+

n i=1



v^1i 1

D2 

(23)

=

D2 2T (1 - 1)

n i=1

v^Ti ,

(24)

where the last equality comes from a standard telescopic summation. We now need the following lemma.

Lemma 3.

T t=1

t v^ti



mti

2 xit



 1 + logT (1 - 1)(1 - ) 1 - 2

T

gti

2 xti

t=1

(25)

Proof. Let's start by separating the last term, and removing the hat on v.

T t=1

t v^ti

T -1

mti

2 xti



t=1

t v^ti

mit

2 xit

+

T v^Ti

mTi

2 xiT

T -1

t=1

t v^ti

mti

2 xti

+

T vTi

mTi

2 xiT

Let's now have a closer look at the last term. We can reformulate miT as:

T
mTi = (1 - 1j )
j=1

T -j
1,(T -k+1)
k=1

Pi
xTi -1xTi

 · · ·  Pxiji xij+1 (gji )

Applying lemma 7, we get

(26) (27)
(28)


T

miT

2 xTi



(1 - 1j)

j=1

T -j
1,(T -k+1)
k=1

 ×


T
 (1 - 1j)
j=1

T -j
1,(T -k+1)
k=1



Pi
xiT -1xTi

 · · ·  Pxiji xij+1 (gji )

2 xiT



.

(29)

Since parallel transport is an isometry, we always have Pxy(u) y = u x, i.e.

Pi
xiT -1xiT

 · · ·  Pxiij xji+1 (gji )

2 xTi

=

gji

2 xij

.

Using that 1k  1 for all k  [T ],


T


T



mTi

2 xiT



(1 - 1j )1T -j  

(1 - 1j )1T -j

gji

2 xji



.

j=1

j=1

Finally, (1 - 1j)  1 and

T j=1

1T -j



1/(1

-

1)

yield



mTi

2 xiT



1 1 - 1

T
 1T -j
j=1

gji

2 xij



.

(30) (31) (32)

12

Under review as a conference paper at ICLR 2019

Let's now look at vTi . It is given by

T

vTi = (1 - 2)

2T -j

gji

2 xij

j=1

Combining Eq. (32) and Eq. (33) allows us to bound the last term of Eq. (26):

T vTi

miT

2 xiT



 (1 - 1) T

T j=1

1T

-j

gji

2 xji

(1 - 2)

T j=1

2T

-j

gji

2 xji

  T (1 - 1) T j=1

1T -j

gji

2 xji

(1 - 2)2T -j

gji

2 xji

= (1 - 1)



T
T -j

T (1 - 2) j=1

gji

xij

With this inequality, we can now bound every term of Eq. (26):

T t=1

t v^ti

mit

2 xti



T t=1

(1

-

1)

 t(1

-

2)

t
 t-j
j=1

gji

xij

=



T 1

t
 t-j

(1 - 1) 1 - 2 t=1 t j=1

gji

xij

=  T (1 - 1) 1 - 2 t=1

T

gti xji

j-t/

j=t

j

  T (1 - 1) 1 - 2 t=1

T

gti xij

j-t/ t

j=t

  T (1 - 1) 1 - 2 t=1

gti

xji

(1

1 - ) t

  (1 - 1)(1 - ) 1 - 2 
  1 + logT (1 - 1)(1 - ) 1 - 2

T

gti

2 xij

t=1

T

gti

2 xji

t=1

T1 t
t=1

Putting together Eqs. (19), (20), (24) and lemma 3 lets us bound the regret:

T nT

ft(xt) - ft(x) 

-gti, logxti (xi ) xit

t=1

  T D2

n

2(1 - 1) i=1

i=1 t=1

v^Ti

+

D2 2(1 - 1)

n i=1

T
1t
t=1

+

(1

-

  1 + logT 1)2(1 - ) 1

-

2

n i=1

(i, D) 2

+

1

v^ti t
T
t=1

gti

2 xij

,

13

(33)
(34) (35) (36)
(37) (38) (39) (40) (41) (42) (43)
(44) (45) (46)

Under review as a conference paper at ICLR 2019

where we used the facts that d  (, d) is an increasing function, and that t/ v^ti  t-1/ v^ti-1, which enables us to bound both the second and third terms of the right-hand side of Eq. (19) using lemma 3.
Remark. Let us notice that similarly as for AMSGRAD, RAMSGRAD also has a regret bounded by O(G T ). This is easy to see from the proofof lemma 4. Hence the actual upper-bound on the regret is a minimum between the one in O(G T ) and the one of Theorem 1.

B PROOF OF THEOREM 2

Proof. Similarly as for the proof of Theorem 1 (and with same notations), we obtain the inequality:

-gti, logxit (xi )

xit



vti 2t(1 - 1t)

di(xti, xi)2 - di(xti+1, xi)2

+



(i

,

di

(xit,

xi))

2(1

-

t 1t)

vti

mti

2 xti

+ 1t

t

2(1 - 1t) vti

mit-1

2 xti-1

+

1t 2(1 - 1t)

vti t

logxit (xi)

2 xit

.

From the geodesic convexity of ft for 1  t  T , we have

(47)

TT

nT

ft(xt) - ft(x) 

-gt, logxt (x) xt =

-gti, logixti (xi) xti .

t=1 t=1

i=1 t=1

With the same techniques as before, we obtain the same bound on the first term:

(48)

nT

vti

i=1 t=1 2t(1 - 1t)

di(xti, xi)2 - di(xti+1, xi )2

 D2

n

2T (1 - 1) i=1

However, for the other terms, we now need a new lemma:

vTi .

(49)

Lemma 4.

T t=1

t v^ti

mit

2 xit



2 (1 - 1)2

T

gti

2 xit

.

t=1

(50)

Proof. Let's start by separating the last term.

T t=1

t vti

T -1

mti

2 xit



t=1

t vti

mti

2 xti

+

T vTi

mTi

2 xTi

.

Similarly as before, we have



miT

2 xTi



1 1 - 1

T
 1T -j
j=1

gji

2 xij



.

Let's now look at vTi . Since 2t = 1 - 1/t, it is simply given by

T

vTi =

gti

2 xti

/T

.

t=1

Combining these yields:

T vTi

miT

2 xiT



 1 - 1

T j=1

1T

-j

gji

2 xji





T

T t=1

gti

2 xti

1 - 1 j=1

1T -j

gji

2 xij

.

j k=1

gki

2 xik

(51) (52) (53) (54)

14

Under review as a conference paper at ICLR 2019

Using this inequality at all time-steps gives

T t=1

t vti

mti

2 xti



T 1 - 1 j=1

T -j l=0

1l

gji

2 xij

j k=1

gki

2 xik



 (1 - 1)2

T j=1

gji

2 xji

j k=1

gki

2 xki



2 (1 - 1)2

T

gji

2 xji

,

j=1

where the last inequality comes from lemma 8.

(55) (56) (57)

Putting everything together, we finally obtain

T nT

ft(xt) - ft(x) 

-gti, logxit (xi ) xti

t=1

  T D2

n

2(1 - 1) i=1

i=1 t=1

vTi

+

D2 2(1 - 1)

n i=1

T t=1

1t

vti t

n

+

(1 -

1)3

((i, D) +
i=1

1)

T

gti

2 xji

,

t=1

(58) (59) (60)

where we used that for this choice of t and 2t, we have t/ vti  t-1/ vti-1. Finally,

D2 2(1 - 1)

n i=1

T t=1

1t

vti t



D2 Gn 2(1 - 1)

T t=1

 t1t



1D2 Gn 2(1 - 1)(1 -

)2

.

This combined with Eq. (53) yields the final result.

(61)

Remark. Notice the appearance of a factor n/ in the last term of the last equation. This term is missing in corollaries 1 and 2 of Reddi et al. (2018), which is a mistake. However, this dependence in n is not too harmful here, since this term does not depend on T .

C AMSGRAD

Theorem 5 (Convergence of AMSGRAD). Let (ft) be a family of differentiable, convex functions from Rn to R. Let (xt) and (vt) be thesequences obtained from Algorithm 1b, t = / t, 1 = 11, 1t  1 for all t  [T ] and  = 1/ 2 < 1. Assume that each Xi  R has a diameter bounded by D and that for all 1  i  n, t  [T ] and x  X , (gradft(x))   G. For (xt) generated
using the AMSGRAD (Algorithm 1b), we have the following bound on the regret

RT



 T D2
2(1 - 1)

n i=1

v^Ti

+

D2 2(1 - 1)

n i=1

T t=1

1t

v^ti + t

  1 + logT

n

(1 - 1)2(1 - ) 1 - 2 i=1

T
(gti)2 (62)
t=1

Proof. See Theorem 4 of Reddi et al. (2018).

15

Under review as a conference paper at ICLR 2019

D USEFUL LEMMAS

The following lemma is a user-friendly inequality developed by Zhang & Sra (2016) in order to prove convergence of gradient-based optimization algorithms, for geodesically convex functions, in Alexandrov spaces.
Lemma 6 (Cosine inequality in Alexandrov spaces). If a, b, c, are the sides (i.e., side lengths) of a geodesic triangle in an Alexandrov space with curvature lower bounded by , and A is the angle between sides b and c, then

a2 

||c b2 + c2 - 2bc cos(A).

tanh( ||c)

(63)

Proof. See section 3.1, lemma 6 of Zhang & Sra (2016).

Lemma 7 (An analogue of Cauchy-Schwarz). For all p, k  N, u1, ..., uk  Rp, a1, ..., ak  R+, we have

aiui

2 2



i

ai
i

ai

ui

2 2

.

i

(64)

Proof. The proof consists in applying Cauchy-Schwarz' inequality two times:

aiui

2 2

=

aiaj uTi uj

i i,j

=

 ai

aj

 ( ai

ui)T

 ( aj

uj

)

i,j







aiaj aiui 2 aj uj 2

i,j

2
 = ai aiui 2

i

(65) (66) (67)
(68)

 ai
i

i

ui

2 2

.

i

(69)

Finally, this last lemma is used by Reddi et al. (2018) in their convergence proof for ADAMNC. We need it too, in an analogue lemma.
Lemma 8 ((Auer et al., 2002)). For any non-negative real numbers y1, ..., yt, the following holds:

t

yi

t
 2 yi.

i=1

i j=1

yj

i=1

(70)

16

