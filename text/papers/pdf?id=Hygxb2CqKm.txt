Under review as a conference paper at ICLR 2019
STABLE RECURRENT MODELS
Anonymous authors Paper under double-blind review
ABSTRACT
Stability is a fundamental property of dynamical systems, yet to this date it has had little bearing on the practice of recurrent neural networks. In this work, we conduct a thorough investigation of stable recurrent models. Theoretically, we prove stable recurrent neural networks are well approximated by feed-forward networks for the purpose of both inference and training by gradient descent. Empirically, we demonstrate stable recurrent models often perform as well as their unstable counterparts on benchmark sequence tasks. Taken together, these findings shed light on the effective power of recurrent networks and suggest much of sequence learning happens, or can be made to happen, in the stable regime. Moreover, our results help to explain why in many cases practitioners succeed in replacing recurrent models by feed-forward models.
1 INTRODUCTION
Recurrent neural networks are a popular modeling choice for solving sequence learning problems arising in domains such as speech recognition and natural language processing. At the outset, recurrent neural networks are non-linear dynamical systems commonly trained to fit sequence data via some variant of gradient descent.
Stability is of fundamental importance in the study of dynamical system. Surprisingly, however, stability has had little impact on the practice of recurrent neural networks. Recurrent models trained in practice do not satisfy stability in an obvious manner, suggesting that perhaps training happens in a chaotic regime. The difficulty of training recurrent models has compelled practitioners to successfully replace recurrent models with non-recurrent, feed-forward architectures.
This state of affairs raises important unresolved questions. Is sequence modeling in practice inherently unstable? When and why are recurrent models really needed?
In this work, we shed light on both of these questions through a theoretical and empirical investigation of stability in recurrent models.
We first prove stable recurrent models can be approximated by feed-forward networks. In particular, not only are the models equivalent for inference, they are also equivalent for training via gradient descent. While it is easy to contrive non-linear recurrent models that on some input sequence cannot be approximated by feed-forward models, our result implies such models are inevitably unstable. This means in particular they must have exploding gradients, which is in general an impediment to learnibility via gradient descent.
Second, across a variety of different sequence tasks, we show how recurrent models can often be made stable without loss in performance. Combined with our first result, this observation helps to explain why an increasingly large body of empirical research succeeds in replacing recurrent models with feed-forward models in important applications, including translation (Vaswani et al., 2017; Gehring et al., 2017), speech synthesis (Van Den Oord et al., 2016), and language modeling (Dauphin et al., 2017). While stability does not always hold in practice to begin with, it is often possible to generate a high-performing stable model by imposing stability during training.
Our results also shed light on the effective representational properties of recurrent networks trained in practice. In particular, stable models cannot have long-term memory. Therefore, when stable and unstable models achieve similar results, either the task does not require long-term memory, or the unstable model does not have it.
1

Under review as a conference paper at ICLR 2019

1.1 CONTRIBUTIONS
In this work, we make the following contributions.
1. We present a generic definition of stable recurrent models in terms of non-linear dynamical systems and give sufficient conditions for stability of several commonly used model classes, including long short-term memory (LSTM) networks. These sufficient conditions come with efficient projection operators that can be used at training time to enforce stability.
2. We prove, under the stability assumption, feed-forward networks can approximate recurrent networks for purposes of both inference and training by gradient descent. While simple in the case of inference, the training result relies on non-trivial stability properties of gradient descent.
3. We conduct extensive experimentation on a variety of sequence benchmarks, show stable models often have comparable performance with their unstable counterparts, and discuss when, if ever, there is an intrinsic performance price to using stable models.

2 STABLE RECURRENT MODELS

In this section, we define stable recurrent models and illustrate the concept for various popular model classes. From a pragmatic perspective, stability roughly corresponds to the criterion that the gradients of the training objective do not explode over time. Common recurrent models can operate in both the stable and unstable regimes, depending on their parameters. To study stable variants of common architectures, we give sufficient conditions to ensure stability and describe how to efficiently enforce these conditions during training.

2.1 DEFINING STABLE RECURRENT MODELS

A recurrent model is a non-linear dynamical system given by a differentiable state-transition map w : Rn × Rd  Rn, parameterized by w  Rm. The hidden state ht  Rn evolves in discrete time steps according to the update rule

ht = w(ht-1, xt) ,

(1)

where the vector xt  Rd is an arbitrary input provided to the system at time t. This general formulation allows us to unify many examples of interest. For instance, for a recurrent neural network, given weight matrices W and U , the state evolves according to

ht = W,U (ht-1, xt) = tanh (W ht-1 + U xt) .

Recurrent models are typically trained using some variant of gradient descent. One natural--even if not strictly necessary--requirement for gradient descent to work is that the gradients of the training objective do not explode over time. Stable recurrent models are precisely the class of models where the gradients cannot explode. They thus constitute a natural class of models where gradient descent can be expected to work. In general, we define a stable recurrent model as follows.

Definition 1. A recurrent model w is stable if there exists some  < 1 such that, for any weights w  Rm, states h, h  Rn, and input x  Rd,

w(h, x) - w(h , x)   h - h .

(2)

Equivalently, a recurrent model is stable if the map w is -contractive in h. If w is -stable, then

 w (h,x) h

< . Hence, as a consequence of stability, for sufficiently regular loss functions p,

wp is always bounded (Pascanu et al., 2013).

Stable models are particularly well-behaved and well-justified from a theoretical perspective. For instance, at present, only stable linear dynamical systems are known to be learnable via gradient descent (Hardt et al., 2016a). In unstable models, the gradients of the objective can explode. In this situation, it is a delicate matter to even show that gradient descent converges to a stationary point. The following proposition offers one such example. The proof is provided in the appendix.
Proposition 1. There exists an unstable system w where gradient descent does not converge to a stationary point, and wp   as the number of iterations N  .

2

Under review as a conference paper at ICLR 2019

2.2 EXAMPLES OF STABLE RECURRENT MODELS
In this section, we provide sufficient conditions to ensure stability for several common recurrent models­linear dynamical systems, recurrent neural networks, and long short-term memory networks. These conditions offer a way to require learning to happen in the stable regime­ after each iteration of gradient descent, one simply imposes the corresponding stability condition.

Linear dynamical systems and recurrent neural networks. Given a Lipschitz, point-wise nonlinearity  and matrices W  Rn×n and U  Rn×d, the state-transition map for a recurrent neural
network (RNN) is

ht = (W ht-1 + U xt).

If  is the identity, then the system is a linear dynamical system. If  is L-Lipschitz, the model is

stable provided

W

<

1 L

.

Indeed,

for

any

states

h, h

,

and

any

x,

(W h + U x) - (W h + U x)  L W h + U x - W h - U x  L W h - h .

In the case of a linear dynamical system, the model is stable provided W < 1. Similarly, for the 1-Lipschitz tanh-nonlinearity, stability obtains provided W < 1. In the appendix, we verify the assumptions required by the theorems given in the next section for this example. Imposing this
condition during training corresponds to projecting onto the spectral norm ball.

Long short-term memory networks. Long Short-Term Memory (LSTM) networks are another commonly used class of sequence models (Hochreiter & Schmidhuber, 1997). The state is a pair of vectors s = (c, h)  R2d, and the model is parameterized by eight matrices, W  Rd×d and U  Rd×n, for  {i, f, o, z}. The state-transition map LSTM is given by
ft = (Wf ht-1 + Uf xt) it = (Wiht-1 + Uixt) ot = (Woht-1 + Uoxt) zt = tanh(Wzht-1 + Uzxt) ct = it  zt + ft  ct-1 ht = ot · tanh(ct),
where  denotes elementwise multiplication, and  is the logistic function.
We provide conditions under which the iterated system rLSTM = LSTM  · · ·  LSTM is stable. Let f  = supt ft . If the weights Wf , Uf and inputs xt are bounded, then f  < 1 since || < 1 for any finite input. This means the next state ct must "forget" a non-trivial portion of ct-1. We leverage this phenomenon to give sufficient conditions for LSTM to be contractive in the  norm, which in turn implies the iterated system Lr STM is contractive in the 2 norm for r = O(log(d)). Let W  denote the induced  matrix norm, which corresponds to the maximum absolute row sum maxi j |Wij|.
Proposition 2. If Wi  , Wo  < (1 - f ), Wz   (1/4)(1 - f ), Wf  < (1 - f )2, and r = O(log(d)), then the iterated system rLSTM is stable.
The proof is given in the appendix. The conditions given in Proposition 2 are fairly restrictive. Somewhat surprisingly we show in the experiments models satisfying these stability conditions still achieve good performance on a number of tasks. We leave it as an open problem to find different parameter regimes where the system is stable, as well as resolve whether the original system LSTM is stable. Imposing these conditions during training and corresponds to simple row-wise normalization of the weight matrices and inputs. More details are provided in Section 4 and the appendix.

3 STABLE RECURRENT MODELS HAVE FEED-FORWARD APPROXIMATIONS
In this section, we prove stable recurrent models can be well-approximated by feed-forward networks for the purposes of both inference and training by gradient descent. In a loose sense, stable

3

Under review as a conference paper at ICLR 2019

recurrent models are equivalent to feed-forward networks. This equivalence has important consequences for sequence modeling in practice. When a stable recurrent model achieves satisfactory performance on some task, a feed-forward network can achieve similar performance. Consequently, if sequence learning in practice is inherently stable, then recurrent models are not truly necessary. Conversely, if feed-forward models cannot match the performance of recurrent models, then sequence learning in practice is inherently in the unstable regime.

3.1 TRUNCATED RECURRENT MODELS

For our purposes, the salient distinction between a recurrent and feed-forward model is the latter has finite-context. Therefore, we say a model is feed-forward if the prediction made by the model at step t is a function only of the inputs xt-k, . . . , xt for some finite k.
While there are many choices for a feed-forward approximation, we consider the simplest one-- truncation of the system to some finite context k. In other words, the feed-forward approximation moves over the input sequence with a sliding window of length k producing an output every time the sliding window advances by one step. Formally, for context length k chosen in advance, we define the truncated model via the update rule

hkt = w(htk-1, xt), hkt-k = 0 .

(3)

Note that htk is a function only of the previous k inputs xt-k, . . . , xt. While this definition is perhaps an abuse of the term "feed-forward", the truncated model can be implemented as a standard autoregressive, depth-k feed-forward network, albeit with significant weight sharing.
Let f denote a prediction function that maps a state ht to outputs f (ht) = yt. Let ytk denote the predictions from the truncated model. To simplify the presentation, the prediction function f is not parameterized. This is without loss of generality because it is always possible to fold the parameters into the system w itself. In the sequel, we study yt - ytk both during and after training.

3.2 APPROXIMATION DURING INFERENCE

Suppose we train a full recurrent model w and obtain a prediction yt. For an appropriate choice of context k, the truncated model makes essentially the same prediction ytk as the full recurrent model. To show this result, we first control the difference between the hidden states of both models.

Lemma 1. Assume w is -contractive and Lx-Lipschitz in x. Assume the input sequence xt 

Bx for all t. If the truncation length k  log1/

Lx Bx (1-)

, then the difference in hidden states

ht - hkt  .

Lemma 1 effectively says stable models do not have long-term memory­ distant inputs do not change the states of the system. For this reason, it is a key building block for both our inference and our subsequent training-time analysis. A full proof is given in the appendix. If the prediction function is Lipschitz, Lemma 1 immediately implies that the predictions between the recurrent and truncated model are nearly identical. This leads us to the following proposition.

Proposition 3. If w is a Lx-Lipschitz and -contractive map, and f is Lf Lipschitz and the trun-

cation length k  log1/

Lf LxBx (1-)

, then

yt - ytk

 .

3.3 APPROXIMATION DURING TRAINING VIA GRADIENT DESCENT
Equipped with our inference result, we turn towards optimization. We show gradient descent for stable recurrent models finds essentially the same solutions as gradient descent for truncated models. Consequently, both the recurrent and truncated models found by gradient descent make essentially the same predictions.
Our proof technique is to initialize both the recurrent and truncated models at the same point and track the divergence in weights throughout the course of gradient descent. Roughly, we show if k  O(log(N/)), then after N steps of gradient descent, the difference in the weights between the recurrent and truncated models is at most .

4

Under review as a conference paper at ICLR 2019

Even if the gradients are similar for both models at the same point, it is a priori possible that slight differences in the gradients accumulate over time and lead to divergent weights where no meaningful comparison is possible. Building on similar techniques as Hardt et al. (2016b), we show that gradient descent itself is stable, and this type of divergence cannot occur.

Our gradient descent result requires two essential lemmas. The first bounds the difference in gradient between the full and the truncated model. The second establishes the gradient map of both the full and truncated models is Lipschitz. We defer proofs of both lemmas to the appendix.

Let pT denote the loss function similarly for the truncated model.

evaluated on recurrent model after T time steps, Assume there some compact, convex domain  

and Rm

define so that

pTk the

map w is stable for all choices of parameters w  .

Lemma 2. Assume p (and therefore pk) is Lipschitz and smooth. Assume w is smooth, contractive, and Lipschitz in x and w. Assume the inputs satisfy xt  Bx, then

wpT - wpkT = kk,

where  = O Bx(1 - )-2 , suppressing dependence on the Lipschitz and smoothness parameters.
Lemma 3. For any w, w  , suppose w is smooth, -contractive, and Lipschitz in w. If p is Lipschitz and smooth, then

wpT (w) - wpT (w )   w - w ,

where  = O (1 - )-3 , suppressing dependence on the Lipschitz and smoothness parameters.

Let wriecurr be the weights of the recurrent model on step i and define wtirunc similarly for the truncated model. At initialization, wr0ecurr = wt0runc. For k sufficiently large, Lemma 2 guarantees the difference between the gradient of the recurrent and truncated models is negligible. Therefore, after a gradient update, wr1ecurr - wt1runc is small. Lemma 3 then guarantees that this small difference in weights does not lead to large differences in the gradient on the subsequent time step. For an appropriate choice of learning rate, formalizing this argument leads to the following proposition.
Proposition 4. Under the assumptions of Lemmas 2 and 3, for compact, convex , after N steps of projected gradient descent with step size t = /t, wrNecurr - wtNrunc  kkN +1.
The decaying step size in our theorem is consistent with the regime in which gradient descent is known to be stable for non-convex training objectives (Hardt et al., 2016b). While the decay is faster than many learning rates encountered in practice, classical results nonetheless show that with this learning rate gradient descent still converges to a stationary point; see p. 119 in Bertsekas (1999) and references there. In the appendix, we give empirical evidence the O(1/t) rateis necessary for our theorem and show examples of stable systems trained with constant or O(1/ t) rates that do not satisfy our bound.
Critically, the bound in Proposition 4 goes to 0 as k  . In particular, if we take  = 1 and k = O log(N /) , then after N steps of projected gradient descent, wrNecurr - wtNrunc  . For this choice of k, we obtain the main theorem. The proof is left to the appendix.
Theorem 1. Let p be Lipschitz and smooth. Assume w is smooth, -contractive, Lipschitz in x and w. Assume the inputs are bounded, and the prediction function f is Lf -Lipschitz. If k = O(log(N /)), then after N steps of projected gradient descent with step size t = 1/t,
yT - yTk  .

4 EXPERIMENTS

In the experiments, we show stable recurrent models can achieve solid performance on several benchmark sequence tasks. Namely, we show unstable recurrent models can often be made stable without a loss in performance. In some cases, there is a small gap between the performance between unstable and stable models. We analyze whether this gap is indicative of a "price of stability" and show the unstable models involved are stable in a data-dependent sense.

5

Under review as a conference paper at ICLR 2019

Training Perplexity Training Loss

Word-Level Language Model (Wikitext-2)
Stable RNN 400 Unstable RNN
Stable LSTM Unstable LSTM
200

100 50 0

50000

100000

Number of Iterations

(a) Word-level language modeling

Polyphonic Music Modeling (Bach Chorales)

14 Stable RNN Unstable RNN

12

Stable LSTM Unstable LSTM

10

8

0

10000

20000

Number of Iterations

(b) Polyphonic music modeling

Figure 1: Stable and unstable variants of common recurrent architectures achieve similar performance across a range of different sequence tasks.

4.1 TASKS
We consider four benchmark sequence problems­word-level language modeling, character-level language modeling, polyphonic music modeling, and slot-filling.
Language modeling. In language modeling, given a sequence of words or characters, the model must predict the next word or character. For character-level language modeling, we train and evaluate models on Penn Treebank (Marcus et al., 1993). To increase the coverage of our experiments, we train and evaluate the word-level language models on the Wikitext-2 dataset, which is twice as large as Penn Treebank and features a larger vocabulary (Merity et al., 2016). Performance is reported using bits-per-character for character-level models and perplexity for word-level models.
Polyphonic music modeling. In polyphonic music modeling, a piece is represented as a sequence of 88-bit binary codes corresponding to the 88 keys on a piano, with a 1 indicating a key that is pressed at a given time. Given a sequence of codes, the task is to predict the next code. We evaluate our models on JSB Chorales, a polyphonic music dataset consisting of 382 harmonized chorales by J.S. Bach (Allan & Williams, 2005). Performance is measured using negative log-likelihood.
Slot-filling. In slot filling, the model takes as input a query like "I want to Boston on Monday" and outputs a class label for each word in the input, e.g. Boston maps to Departure City and Monday maps to Departure Time. We use the Airline Travel Information Systems (ATIS) benchmark and report the F1 score for each model (Price, 1990).
4.2 COMPARING STABLE AND UNSTABLE MODELS
For each task, we first train an unconstrained RNN and an unconstrained LSTM. All the hyperparameters are chosen via grid-search to maximize the performance of the unconstrained model. For consistency with our theoretical results in Section 3 and stability conditions in Section 2.2, both models have a single recurrent layer and are trained using plain SGD. In each case, the resulting model is unstable. However, we then retrain the best models using projected gradient descent to enforce stability without retuning the hyperparameters. In the RNN case, we constrain W < 1. After each gradient update, we project the W onto the spectral norm ball by computing the SVD and thresholding the singular values to lie in [0, 1). In the LSTM case, after each gradient update, we normalize each row of the weight matrices to satisfy the sufficient conditions for stability given in Section 2.2. Further details are given in the appendix.
Stable and unstable models achieve similar performance. Table 1 gives a comparison of the performance between stable and unstable RNNs and LSTMs on each of the different tasks. Each of the reported metrics is computed on the held-out test set. We also show a representative comparison of learning curves for word-level language modeling and polyphonic music modeling in Figures 1(a) and 1(b).
6

Under review as a conference paper at ICLR 2019

Table 1: Comparision of stable and unstable models on a variety of sequence modeling tasks. For all the tasks, stable and unstable RNNs achieve the same performance. For polyphonic music and slot-filling, stable and unstable LSTMs achieve the same results. On language modeling, there is a small gap between stable and unstable LSTMs. We discuss this in Section 4.3. Performance is evaluated on the held-out test set. For negative log-likelihood (nll), bits per character (bpc), and perplexity, lower is better. For F1 score, higher is better.

Sequence Task

Dataset (measure)

Model

RNN

LSTM

Unstable Stable Unstable Stable

Polyphonic Music Slot-Filling Word-level LM Character-level LM

JSB Chorales (nll) Atis (F1 score) Wikitext-2 (perplexity) Penn Treebank (bpc)

8.9 94.7 146.7 1.8

8.9 94.7 143.5 1.9

8.5 95.1 95.7 1.4

8.5 94.6 113.2 1.9

Across all the tasks we considered, stable and unstable RNNs have roughly the same performance. Stable RNNs and LSTMs achieve results comparable to published baselines on slot-filling (Mesnil et al., 2015) and polyphonic music modeling (Bai et al., 2018). On word and character level language modeling, both stable and unstable RNNs achieve comparable results to (Bai et al., 2018).
On the language modeling tasks, however, there is a gap between stable and unstable LSTM models. Given the restrictive conditions we place on the LSTM to ensure stability, it is surprising they work as well as they do. Weaker conditions ensuring stability of the LSTM could reduce this gap. It is also possible imposing stability comes at a cost in representational capacity required for some tasks.

4.3 WHAT IS THE "PRICE OF STABILITY" IN SEQUENCE MODELING?
The gap between stable and unstable LSTMs on language modeling raises the question of whether there is an intrinsic performance cost for using stable models on some tasks. If we measure stability in a data-dependent fashion, then the unstable LSTM language models are stable, indicating this gap is illusory. However, in some cases with short sequences, instability can offer modeling benefits.

LSTM language models are stable in a "data-dependent" way. Our notion of stability is very

conservative and requires stability to hold for every input and pair of hidden states. If we instead

consider a weaker, data-dependent notion of stability, the word and character-level LSTM models

are stable (in the iterated sense of Proposition 2). In particular, we compute the stability parameter

only using input sequences from the data. Furthermore, we only evaluate stability on hidden states

reachable via gradient descent. More precisely, to estimate , we run gradient ascent to find worst-

case hidden states h, h to maximize

w(h,x)-w(h ,x) h-h

. More details are provided in the appendix.

Using this measure, in Figure 2(a), we show the iterated character-level LSTM, rLSTM, is stable for r  80 iterations. A similar result holds for the word-level language model for r  100. These findings are consistent with experiments in Laurent & von Brecht (2016) which find LSTM trajectories converge after approximately 70 steps only when evaluated on sequences from the data. For language models, the "price of stability" is therefore much smaller than the gap in Table 1 suggests­ even the "unstable" models are operating in the stable regime on the data distribution.

Unstable systems can offer performance improvements for short-time horizons. When se-
quences are short, training unstable models is less difficult because exploding gradients are less of
an issue. In these case, unstable models can offer performance gains. To demonstrate this, we trained
truncated unstable models on the polyphonic music modeling task for various values of the truncation parameter k. In Figure 2(b), we simultaneously plot the performance of the unstable model and the stability parameter  for the converged model for each k. For short-sequences, the final model is more unstable (  3.5) and achieves a better test-likelihood. For longer sequence lengths,  decreases closer to the stable regime (  1.5), and this improved test-likelihood performance disappears.

7

Under review as a conference paper at ICLR 2019

Data-dependent Stability for Iterated LSTM (Char-LM)
Iterated LSTM 10 Stability Threshold

Stability Constant vs. Truncation Length 9.00 (Polyphonic Music) 3.5

Data-Dependent Stability Test Log-Likelihood Lambda

5
1 0 0 75 150
Number of Iterations (a) Data-dependent stability of character-level language models. The iterated-LSTM refers to the iteration system Lr STM = LSTM  · · ·  LSTM.

8.85 1.5
Unstable RNN Stability Parameter 8.70 20 40 60 80 100 0.0 Truncation Length
(b) Unstable models can boost performance for short sequences.

Figure 2: What is the intrinsic "price of stability"? For language modeling, we show the unstable LSTMs are actually stable in weaker, data-dependent sense. On the other hand, for polyphonic music modeling with short sequences, instability can improve model performance.

5 DISCUSSION
We view our empirical results as strong evidence sequence learning happens or can be made to happen in the stable regime. Imposing stability on recurrent models often does not change their performance, and unstable models like our LSTM language model are often stable in an data-dependent sense. This result is somewhat surprising both given the restrictive conditions required for stability and our theoretical result showing stable models are inherently feed-forward. As a consequence, we conjecture recurrent networks trained in practice are always approximable by feed-forward networks. Resolving this conjecture requires understanding how much and what kind of memory natural problems require and identifying when, if ever, unstable recurrent models are truly necessary.
6 RELATED WORK
Learning dynamical systems with gradient descent has been a recent topic of interest in the machine learning community. Hardt et al. (2016a) show gradient descent can efficiently learn a class of stable, linear dynamical systems, Oymak (2018) shows gradient descent learns a class of stable, non-linear dynamical systems. Work by Sedghi & Anandkumar (2016) gives a moment-based approach for learning some classes of stable non-linear recurrent neural networks. Our work explores the theoretical and empirical consequences of the stability assumption made in these works. In particular, our empirical results show models trained in practice can be made closer to those currently being analyzed theoretically without large performance penalties.
In the linear dynamical system setting, Tu et al. (2017) exploit the connection between stability and a truncated system approximation to provably learn a truncated approximation to the full stable system. Their approximation result is the same as our inference result in the linear dynamical system case, and we extend this result to the non-linear setting. We also analyze the impact of truncation on training with gradient descent. Our training time analysis builds on the stability analysis of gradient descent in Hardt et al. (2016b), but interestingly uses it for an entirely different purpose. Results of this kind are completely new to our knowledge.
From an empirical perspective, Laurent & von Brecht (2016) introduce a non-chaotic recurrent architecture and demonstrate it can perform as well more complex models like LSTMs. Bai et al. (2018) conduct a detailed evaluation of recurrent and convolutional, feed-forward models on a variety of sequence modeling tasks. In diverse settings, they find feed-forward models outperform their recurrent counterparts. Their experiments are complimentary to ours; we find recurrent models can often be replaced with stable recurrent models, which we show are equivalent to feed-forward networks.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Moray Allan and Christopher Williams. Harmonising chorales by probabilistic inference. In Advances in neural information processing systems, pp. 25­32, 2005.
Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and recurrent networks for sequence modeling. arXiv preprint arXiv:1803.01271, 2018.
Dimitri P. Bertsekas. Nonlinear Programming. Athena Scientific, 1999.
Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional networks. In International Conference on Machine Learning, pp. 933­941, 2017.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to sequence learning. In International Conference on Machine Learning, pp. 1243­ 1252, 2017.
Moritz Hardt, Tengyu Ma, and Benjamin Recht. Gradient descent learns linear dynamical systems. arXiv preprint arXiv:1609.05191, 2016a.
Moritz Hardt, Benjamin Recht, and Yoram Singer. Train faster, generalize better: Stability of stochastic gradient descent. In International Conference on Machine Learning, pp. 1225­1234, 2016b.
Sepp Hochreiter and Ju¨rgen Schmidhuber. Long short-term memory. Neural computation, 9(8): 1735­1780, 1997.
Thomas Laurent and James von Brecht. A recurrent neural network without chaos. arXiv preprint arXiv:1612.06212, 2016.
Mitchell P Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a large annotated corpus of english: The penn treebank. Computational linguistics, 19(2):313­330, 1993.
Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models. arXiv preprint arXiv:1609.07843, 2016.
Stephen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and Optimizing LSTM Language Models. arXiv preprint arXiv:1708.02182, 2017.
Gre´goire Mesnil, Yann Dauphin, Kaisheng Yao, Yoshua Bengio, Li Deng, Dilek Hakkani-Tur, Xiaodong He, Larry Heck, Gokhan Tur, Dong Yu, et al. Using recurrent neural networks for slot filling in spoken language understanding. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 23(3):530­539, 2015.
Samet Oymak. Stochastic gradient descent learns state equations with nonlinear activations. arXiv preprint arXiv:1809.03019, 2018.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural networks. In International Conference on Machine Learning, pp. 1310­1318, 2013.
Patti J Price. Evaluation of spoken language systems: The atis domain. In Speech and Natural Language: Proceedings of a Workshop Held at Hidden Valley, Pennsylvania, June 24-27, 1990, 1990.
Hanie Sedghi and Anima Anandkumar. Training input-output recurrent neural networks through spectral methods. CoRR, abs/1603.00954, 2016.
Stephen Tu, Ross Boczar, Andrew Packard, and Benjamin Recht. Non-asymptotic analysis of robust control from coarse-grained identification. arXiv preprint arXiv:1707.04791, 2017.
Aaron Van Den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. Wavenet: A generative model for raw audio. arXiv preprint arXiv:1609.03499, 2016.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, pp. 6000­6010, 2017.
9

Under review as a conference paper at ICLR 2019

A PROOFS FROM SECTION 2

A.1 GRADIENT DESCENT ON UNSTABLE SYSTEMS NEED NOT CONVERGE

Proof of Proposition 1. Consider a scalar linear dynamical system

ht = aht-1 + bxt y^t = ht,

(4) (5)

where h0 = 0, a, b  R are parameters, and xt, yt  R are elements the input-output sequence {(xt, yt)}Tt=1, where L is the sequence length, and y^t is the prediction at time t. Stability of the above system corresponds to |a| < 1.

Suppose (xt, yt) = (1, 1) for t = 1, . . . , L. Then the desired system (4) simply computes the identity mapping. Suppose we use the squared-loss (yt, y^t) = (1/2)(yt - y^t)2, and suppose further b = 1, so the problem reduces to learning a = 0. We first compute the gradient. Compactly write

t-1
ht = atb =
i=0

1 - at 1-a

.

Let t = (y^t - yt). The gradient for step T is then

d da

(yT , y^T )

=

T

d da

=

T

T -1
aT -1-tht

t=0

T -1

= T

aT -1-t

t=0

1 - at 1-a

= T

(1

1 -

a)

T -1

at

-

T aT -1 (1 - a)

t=0

= T

(1 - aT ) (1 - a)2

-

T aT -1 (1 - a)

.

Plugging in yt = 1, this becomes

d da

(yT , y^T ) =

(1 - aT ) (1 - a)

-

1

(1 - aT ) (1 - a)2

-

T aT -1 (1 - a)

.

(6)

For large T , if |a| > 1, then aL grows exponentially with T and the gradient is approximately

d da

(yT , y^T ) 

aT -1 - 1

T aT -2  T a2T -3

Therefore, if a0 is initialized outside of [-1, 1], the iterates ai from gradient descent with step size i = (1/i) diverge, i.e. ai  , and from equation (6), it is clear that such ai are not stationary
points.

A.2 PROOFS FROM SECTION 2.2
A.2.1 RECURRENT NEURAL NETWORKS
Assume W   < 1 and U  BU . Notice tanh (x) = 1 - tanh(x)2, so since tanh(x)  [-1, 1], tanh(x) is 1-Lipschitz and 2-smooth. We previously showed the system is stable since, for any states h, h ,
tanh(W h + U x) - tanh(W h + U x)  Wh + Ux - Wh - Ux  W h-h .

10

Under review as a conference paper at ICLR 2019

Using Lemma 1 with k = 0,

ht



BU Bx (1-)

for

all

t.

Therefore,

for

any

W, W

,

U, U

,

tanh(W ht + U x) - tanh(W ht + U x)

 W ht + U x - W ht - U x

 sup ht W - W + Bx U - U .
t



BU Bx (1 - )

W -W

+ Bx U - U

,

so the model is Lipschitz in U, W . We can similarly argue the model is BU Lipschitz in x. For smoothness, the partial derivative with respect to h is

w(h, x) = diag(tanh (W h + U x))W, h
so for any h, h , bounding the  norm with the 2 norm,
w(h, x) - w(h , x) = diag(tanh (W h + U x))W - diag(tanh (W h + U x))W h h  W diag(tanh (W h + U x) - tanh (W h + U x))  2 W Wh + Ux - Wh - Ux   22 h - h .

For any W, W , U, U satisfying our assumptions,

w(h, x) - w (h, x) h h

= diag(tanh (W h + U x))W - diag(tanh (W h + U x))W

 diag(tanh (W h + U x) - tanh (W h + U x)) W

+ diag(tanh (W h + U x)) W - W

 2 (W - W )h + (U - U )x  + W - W  2 (W - W ) h + 2 U - U x + W - W



2BU Bx + (1 (1 - )

-

)

W -W

+ 2Bx U - U

.

Similar

manipulations

establish

 w (h,x) w

is

Lipschitz

in

h

and

w.

A.2.2 LSTMS

Similar to the previous sections, we assume s0 = 0.

The state-transition map is not Lipschitz in s, much less stable, unless c is bounded. However, assuming the weights are bounded, we first prove this is always the case.

Lemma 4. Let f  = supt ft . If Wf  < , Uf  < , and xt   Bx, then

f

 < 1 and

ct



1 (1- f

) for all t.

Proof of Lemma 4. Note |tanh(x)| , |(x)|  1 for all x. Therefore, for any t, ht  = ot  tanh(ct)   1. Since (x) < 1 for x <  and  is monotonically increasing
ft    Wf ht-1 + Uf xt    Wf  ht-1  + Uf  xt    (BW + BuBx) < 1.
Using the trivial bound, it   1 and zt   1, so ct+1  = it  zt + ft  ct   1 + ft  ct  .

11

Under review as a conference paper at ICLR 2019

Unrolling this recursion, we obtain a geometric series

t
ct+1  
i=0

ft

i 



(1 -

1 f

. )

Proof of Proposition 2. We show LSTM is -contractive in the -norm for some  < 1. For r  log1/( d), this in turn implies the iterated system Lr STM is contractive is the 2-norm.
Consider the pair of reachable hidden states s = (c, h), s = (c , h ). By Lemma 4, c, c are bounded. Analogous to the recurrent network case above, since  is (1/4)-Lipschitz and tanh is 1-Lipschitz,

i-i f -f o-o z-z



1 4

Wi 

h-h





1 4

Wf



h-h





1 4

Wo 

h-h



 Wz  h - h  .

Both z  , i   1 since they're the output of a sigmoid. Letting c+ and c+ denote the state on the next time step, applying the triangle inequality,

c+ - c+    


iz-i z + f c-f c 

(i - i )  z  + i  (z - z )  + f  (c - c )  + c  (f - f ) 

i-i  z + z-z  i + c-c  f + f -f  c 

Wi  +

c 4

Wf

+

Wz 

h-h + f  c-c .

A similar argument shows

h+ - h+  

o-o

+

c+ - c+  

Wo  4

h-h

+

c+ - c+  .

By assumption,

Wi  +

c  Wf 4

+

Wo  +

Wz 

<1- f ,

and so

h+ - h+  < (1 - f ) h - h  + f  c - c   s - s  , as well as

c+ - c+  < (1 - f ) h - h  + f  c - c   s - s  , which together imply

s+ - s+  < s - s  , establishing LSTM is contractive in the  norm.

B PROOFS FROM SECTION 3
Throughout this section, we assume the initial state h0 = 0. Without loss of generality, we also assume w(0, 0) = 0 for all w. Otherwise, we can reparameterize w(h, x)  w(h, x) - w(0, 0) without affecting expressivity of w. For stable models, we also assume there some compact, convex domain   Rm so that the map w is stable for all choices of parameters w  .

12

Under review as a conference paper at ICLR 2019

Proof of Lemma 1. For any t  1, by triangle inequality,

ht = w(ht-1, xt) - w(0, 0)  w(ht-1, xt) - w(0, xt) + w(0, xt) - w(0, 0) .

Applying the stability and Lipschitz assumptions and then summing a geometric series,

ht



ht-1

+ Lx

xt



t

iLxBx



LxBx (1 - )

.

i=0

Now, consider the difference between hidden states at time step t. Unrolling the iterates k steps and then using the previous display yields

ht - hkt

=

w(ht-1, xt) - w(htk-1, xt)

  ht-1 - hkt-1

 k ht-k



k Lx (1 -

Bx )

,

and solving for k gives the result.

B.1 PROOFS FROM SECTION 3.3

Before proceeding, we introduce notation for our smoothness assumption. We assume the map w satisfies four smoothness conditions: for any reachable states h, h , and any weights w, w  ,
there are some scalars ww, wh, hw, hh such that

1.

 w (h,x) w

-

w (h,x) w

 ww w - w

.

2.

 w (h,x) w

-

 w (h w

,x)

 wh h - h .

3.

 w (h,x) h

-

w (h,x) h

 hw w - w

.

4.

 w (h,x) h

-

 w (h h

,x)

 hh h - h .

B.1.1 GRADIENT DIFFERENCE DUE TO TRUNCATION IS NEGLIGIBLE
In the section, we argue the difference in gradient with respect to the weights between the recurrent and truncated models is O(kk). For sufficiently large k (independent of the sequence length), the impact of truncation is therefore negligible. The proof leverages the "vanishing-gradient" phenomenon­ the long-term components of the gradient of the full recurrent model quickly vanish. The remaining challenge is to show the short-term components of the gradient are similar for the full and recurrent models.

Proof of Lemma 2. The Jacobian of the loss with respect to the weights is

pT = pT w hT

T hT ht t=0 ht w

,

where

ht w

is

the partial derivative of ht

with

respect

to w,

assuming

ht-1

is

constant

with

respect

to w. Expanding the expression for the gradient, we wish to bound

T
wpT (w) - wpkT (w) =
t=1

hT ht ht w

T
hT pT -
t=T -k+1

hTk hkt htk w

hTk pTk

T -k

t=1

hT ht ht w

hT pT

T
+
t=T -k+1

hT ht ht w

hT pT -

hkT htk htk w

hTk pT .

The first term consists of the "long-term components" of the gradient for the recurrent model. The second term is the difference in the "short-term components" of the gradients between the recurrent and truncated models. We bound each of these terms separately.

13

Under review as a conference paper at ICLR 2019

For the first term, by the Lipschitz assumptions, hT pT  Lp and wht  Lw. Since w is

-contractive, so

ht  ht-1

 . Using submultiplicavity of the spectral norm,

pT T -k pT ht hT t=0 ht w



hT pT

T -k t=0

T hi i=t hi-1

w ht



LpLw

T -k

T -t



k

LpLw (1 - )

.

t=0

Focusing on the second term, by triangle inequality and smoothness,

T t=T -k+1

hT ht ht w

hT pT -

hTk htk hkt w

hkT pT

T

t=T -k+1

hT pT - hkT pkT

hTk hkt hkt w

+ hT pT

hT ht

ht w

-

hkT hkt

hkt w

T
 p
t=T -k+1

hT - hTk
(a)

T -tLw + Lp

hT ht

ht w

-

hTk hkt

htk w

(b)

.

Using Lemma 1 to upper bound (a),

T

p hT - hkT T -tLw 

T

T

-t

k

pLw (1 -

LxBx )



k

p Lw Lx Bx (1 - )2

.

t=T -k

t=T -k

Using the triangle inequality, Lipschitz and smoothness, (b) is bounded by

T
Lp
t=T -k+1

hT ht

ht w

-

hkT htk

hkt w

T
 Lp
t=T -k+1

hT ht

ht - hkt w w

+ Lp

htk w

hT ht

-

hkT htk

T
 LpT -twh
t=T -k+1

ht - htk

+ LpLw

hT ht

-

hTk hkt



kk

LpwhLxBx (1 - )

+ LpLw

T

t=T -k+1

hT ht

-

hTk hkt

,

(c)

where the last line used

ht - htk



t-(T

-k)

Lx Bx (1-)

for

t



T

-

k.

It

remains

to

bound

(c),

the

difference of the hidden-to-hidden Jacobians. Peeling off one term at a time and applying triangle

inequality, for any t  T - k + 1,

hT ht

-

hkT hkt



hT hT -1

-

hkT hkT -1

hT -1 ht

+

hkT hTk -1

hT -1 ht

-

hTk -1 hkt

 hh hT -1 - hT -1 T -t-1 + 

hT -1 ht

-

hTk -1 hkt

T -1
 hhT -t-1 hi - hki

i=t



k hhLxBx

T -1
i-t

(1 - )

i=t



k

hhLxBx (1 - )2

,

so

(c)

is

bounded

by

kk

LpLw hhLxBx (1-)2

.

Ignoring

Lipschitz

and

smoothness

constants,

we've

shown

the entire sum is O

kk (1-)2

.

14

Under review as a conference paper at ICLR 2019

B.1.2 STABLE RECURRENT MODELS ARE SMOOTH

In this section, we prove that the gradient map wpT is Lipschitz. First, we show on the forward pass, the difference between hidden states ht(w) and ht(w ) obtained by running the model with weights w and w , respectively, is bounded in terms of w - w . Using smoothness of , the difference in gradients can be written in terms of ht(w) - ht(w ) , which in turn can be bounded in terms of w - w . We repeatedly leverage this fact to conclude the total difference in gradients
must be similarly bounded.

We first show small differences in weights don't significantly change the trajectory of the recurrent model.
Lemma 5. For some w, w , suppose w, w are -contractive and Lw Lipschitz in w. Let ht(w), ht(w ) be the hidden state at time t obtain from running the model with weights w, w on common inputs {xt}. If h0(w) = h0(w ), then

ht(w) - ht(w )



Lw w - w (1 - )

.

Proof. By triangle inequality, followed by the Lipschitz and contractivity assumptions,

ht(w) - ht(w ) = w(ht-1(w), xt) - w (ht-1(w ), xt)  w(ht-1(w), xt) - w (ht-1(w), xt) + w (ht-1(w), xt) - w (ht-1(w ), xt)  Lw w - w +  ht-1(w) - ht-1(w ) .

Iterating this argument and then using h0(w) = h0(w ), we obtain a geometric series in .

ht(w) - ht(w )

 Lw w - w +  ht-1(w) - ht-1(w )

t
 Lw w - w i

i=0



Lw w - w (1 - )

.

The proof of Lemma 3 is similar in structure to Lemma 2, and follows from repeatedly using smoothness of  and Lemma 5.

Proof of Lemma 3. Let ht = ht(w ). Expanding the gradients and using ht(w) - ht(w ) 

Lw w-w (1-)

from Lemma 5.

wpT (w) - wpT (w )

T

t=1

hT ht ht w

hT pT -

hT ht ht w

hT pT

T
 hT pT - hT pT
t=1

hT ht ht w

+ hT pT

hT ht - hT ht ht w ht w

T
 p hT - hT
t=1

T -tLw + Lp

hT ht - hT ht ht w ht w



pL2w (1

w-w - )2

T
+ Lp
t=1

hT ht - hT ht ht w ht w

.

(a)

15

Under review as a conference paper at ICLR 2019

Focusing on term (a),

T
Lp
t=1

hT ht - hT ht ht w ht w

T
 Lp
t=1

hT - hT ht ht

ht w

+ Lp

hT ht

ht - ht w w

T
 LpLw
t=1

hT - hT ht ht

T
+ Lp T -t (wh ht - ht + ww w - w
t=1

T
 LpLw
t=1

hT - hT ht ht

+

Lp

whLw (1 -

w- )2

w

+

Lpww (1

w- - )

w

,

)

(b)

where the penultimate line used,

ht - ht  w(ht-1, xt) - w(ht-1, xt) + w(ht-1, xt) - w (ht-1, xt)

w w

w

w

w w

 wh h - h + ww w - w .

To bound (b), we peel off terms one by one using the triangle inequality,

T
LpLw
t=1

hT - hT ht ht

T
 LpLw
t=1

hT - hT hT -1 hT -1

hT -1 + hT ht hT -1

hT -1 - hT -1 ht ht

T
 LpLw
t=1

hh hT -1 - hT -1 + hw w - w

T -t-1 +  hT -1 - hT -1 ht ht

T T -t

 LpLw

hw(T - t)T -t-1 w - w + hh

hT -i - hT -i T -t-1

t=1 i=1

T
 LpLw

hw(T - t)T -t-1 w - w

+

hhLw (1

w- - )

w

(T - t)T -t-1

t=1



LpLwhw w - (1 - )2

w

+

Lp L2w hh (1 -

w- )3

w

.

Supressing Lipschitz and smoothness constants, we've shown the entire sum is O(1/(1 - )3), as required.

B.1.3 GRADIENT DESCENT ANALYSIS
Equipped with the smoothness and truncation lemmas (Lemmas 2 and 3), we turn towards proving the main gradient descent result.

Proof of Proposition 4. Let  denote the Euclidean projection onto , and let i = wriecurr - wtirunc . Initially 0 = 0, and on step i + 1, we have the following recurrence rela16

Under review as a conference paper at ICLR 2019

tion for i+1,
i+1 = wri+ec1urr - wti+ru1nc = (wriecurr - ipT (wi)) - (wtirunc - ipkT (wtirunc))  wriecurr - ipT (wi)) - wtirunc - ipkT (wtirunc)  wriecurr - wtirunc + i pT (wriecurr) - pTk (wtirunc)  i + i pT (wriecurr) - pT (wtirunc) + i pT (wtirunc) - pkT (wtirunc)  i + i i + kk  exp (i) i + ikk,
the penultimate line applied lemmas 2 and 3, and the last line used 1 + x  ex for all x. Unwinding the recurrence relation at step N ,



NN



N 

exp(j) ikk

i=1 j=i+1





NN
 

exp



 kk

i=1 j=i+1

j i





N
 = exp 

N

1  kk .

i=1 

j
j=i+1



i

Bounding the inner summation via an integral,

N j=i+1

1 j



log(N/i)

and

simplifying

the

resulting

expression,

N 

N

exp( log(N/i)) kk i

i=1

= kkN 

N

1 i+1

i=1

 kkN +1 .

B.1.4 PROOF OF THEOREM 1

Proof of Theorem 1. Using f is Lf -Lipschitz and the triangle inequality,

yT - yTk  Lf hT (wrNecurr) - hTk (wtNrunc)  Lf hT (wrNecurr) - hT (wtNrunc) + Lf hT (wtNrunc) - hTk (wtNrunc) .

By Lemma 5, the first term is bounded by Lw

wrNecurr -wtNrunc (1-)

, and by Lemma 1, the second term is

bounded

by

k

Lx Bx (1-)

.

Using

Proposition

4,

after

N

steps

of

gradient

descent,

we

have

yT - yTk

 Lf Lw

wrNecurr - wtNrunc (1 - )

+

k

Lf Lx (1 -

Bx )



kk

Lf LwN +1 (1 - )

+

k

Lf Lx (1 -

Bx )

,

and solving for k such that both terms are less than /2 gives the result.

17

Under review as a conference paper at ICLR 2019

Difference in Recurrent Weight Matrices during Gradient Descent ( = 0.75, k = 35)
100

Difference in Spectral Norm Wrecurr - Wtrunc 2

10-1

10-2 10-3
0

LDS, step-size: 1/t LTTDaannShh,--srrnntennp,,-sssttizeeepp:--ss1iizz/ee:, 11t//tt
Bound from proposition 2

100 Number of Gradient Steps

200

Figure 3: Empirical validation Proposition 4 on random Gaussian instances. Without the 1/t rate, the gradient descent bound no longer appears qualitatively correct, suggesting the O(1/t) rate is
necessary.

C EXPERIMENTS
The O(1/t) rate may be necessary. The key result underlying Theorem 1 is the bound on the parameter difference wtrunc - wrecurr while running gradient descent obtained in Proposition 4. We show this bound has the correct qualitative scaling using random instances and training randomly initialized, stable linear dynamical systems and tanh-RNNs. In Figure 3, we plot the parameter error wttrunc - wrtecurr as training progresses for both models (averaged over 10 runs). The error scales comparably with the bound given in Proposition 4. We also find for larger step-sizes like / t or constant , the bound fails to hold, suggesting the O(1/t) condition is necessary.
Concretely, we generate random problem instance by fixing a sequence length T = 200, sampling input data xt i.i.d. N (0, 4 · I32), and sampling yT  Unif[-2, 2]. Next, we set  = 0.75 and randomly initialize a stable linear dynamical system or RNN with tanh non-linearity by sampling Uij, Wij i.i.d. N (0, 0.5) and thresholding the singular values of W so W  . We use the squared loss and prediction function f (ht, xt) = Cht + Dxt, where C, D i.i.d. N (0, I32). We fix the truncation length to k = 35, set the learning rate to t = /t for  = 0.01, and take N = 200 gradient steps. These parameters are chosen so that the kkN +1 bound from Proposition 4 does not become vacuous ­ by triangle inequality, we always have wtrunc - wrecurr  2.
Stable vs. unstable models. The word and character level language modeling experiments are based on publically available code from Merity et al. (2017). The polyphonic music modeling code is based on the code in Bai et al. (2018), and the slot-filling model is a reimplementation of Mesnil et al. (2015) 1
Since the sufficient conditions for stability derived in Section 2.2 only apply for networks with a single layer, we use a single layer RNN or LSTM for all experiments. Further, our theoretical results are only applicable for vanilla SGD, and not adaptive gradient methods, so all models are trained with SGD. Table 2 contains a summary of all the hyperparameters for each experiment.
All hyperparameters are shared between the stable and unstable variants of both models. In the RNN case, enforcing stability is conceptually simple, though computationally expensive. Since tanh is 1Lipschitz, the RNN is stable as long as W < 1. Therefore, after each gradient update, we project W onto the spectral norm ball by taking the SVD and thresholding the singular values to lie in [0, 1). In the LSTM case, enforcing stability is conceptually more difficult, but computationally simple. To ensure the LSTM is stable, we appeal to Proposition 2. We enforce the following inequalities after each gradient update
1The word-level language modeling code is based on https://github.com/pytorch/examples/ tree/master/word_language_model, the character-level code is based on https://github. com/salesforce/awd-lstm-lm, and the polyphonic music modeling code is based on https:// github.com/locuslab/TCN.
18

Under review as a conference paper at ICLR 2019

Table 2: Hyperparameters for all experiments
Model RNN LSTM

Word LM Char LM Polyphonic Music Slot-Filling

Number layers Hidden units Embedding size Dropout Batch size Learning rate BPTT Gradient clipping Epochs Number layers Hidden units Embedding size Dropout Weight decay Batch size Learning rate BPTT Gradient clipping Epochs Number layers Hidden units Dropout Batch size Learning rate Gradient clipping Epochs Number layers Hidden units Embedding size Dropout Weight decay Batch size Learning rate Gradient clipping Epochs

1 256 1024 0.25 20 2.0 35 0.25 40 1 768 400 0.1 1e-6 80 2.0 150 1.0 300 1 1024 0.1 1 0.05 5.0 100 1 128 64 0.5 1e-4 128 10.0 1.0 100

1 1024 512 0.65 20 20. 35 1.0 40 1 1024 400 0.1 1e-6 80 20.0 150 1.0 300 1 1024 0.1 1 2.0 5.0 100 1 128 64 0.5 1e-4 128 10.0 1.0 100

19

Under review as a conference paper at ICLR 2019

1. The hidden-to-hidden forget gate matrix should satisfy Wf  < 0.128, which is enforced by normalizing the 1- norm of each row to have value at most 0.128.
2. The input vectors xt must satisfy xt   Bx = 0.75, which is achieved by thresholding all values to lie in [-0.75, 0.75].
3. The bias of the forget gate bf , must satsify bf   0.25, which is again achieved by thresholding all values to lie in [-0.25, 0.25].
4. The input-hidden forget gate matrix Uf should satisfy Uf   0.25. This is enforced by normalizing the 1- norm of each row to have value at most 0.25.
5. Given 1-4, the forget gate can take value at most f < 0.64. Consequently, we enforce Wi  , Wo   0.36, Wz  0.091, and Wf  < min 0.128, (1 - 0.64)2 = 0.128.
After 1-5 are enforced, by Proposition 2, the resulting (iterated)-LSTM is stable. Although the above description is somewhat complicated, the implementation boils down to normalizing the rows of the LSTM weight matrices, which can be done very efficiently in a few lines of PyTorch.

Data-dependent stability. Unlike the RNN, in an LSTM, it is not clear how to analytically compute the stability parameter . Instead, we rely on a heuristic method to estimate . Recall a model is stable if for all x, h, h , we have

S(h, h , x) :=

w(h, x) - w(h , x) h-h

  < 1.

(7)

To estimate suph,h ,x S(h, h , x), we do the following. First, we take x to be point in the training set. In the language modeling case, x is one of the learned word-vectors. We randomly sample and fix x,
and then we perform gradient ascent on S(h, h , x) to find worst-case h, h . In our experiments, we initialize h, h  N (0, 0.1 · I) and run gradient ascent with learning rate 0.9 for 1000 steps. This procedure is repeated 20 times, and we estimate  as the maximum value of S(h, h , x) encounted
during any iteration from any of the 20 random starting points.

20

