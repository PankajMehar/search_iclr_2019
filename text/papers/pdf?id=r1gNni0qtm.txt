Under review as a conference paper at ICLR 2019
GENERALIZED TENSOR MODELS FOR RECURRENT NEURAL NETWORKS
Anonymous authors Paper under double-blind review
ABSTRACT
Recurrent Neural Networks (RNNs) are very successful at solving challenging problems with sequential data. However, this observed efficiency is not yet entirely explained by theory. It is known that a certain class of multiplicative RNNs enjoys the property of depth efficiency -- a shallow network of exponentially large width is necessary to realize the same score function as computed by such an RNN. Such networks, however, are not very often applied to real life tasks. In this work, we attempt to reduce the gap between theory and practice by extending the theoretical analysis to RNNs which employ various nonlinearities, such as Rectified Linear Unit (ReLU), and show that they also benefit from properties of universality and depth efficiency. Our theoretical results are verified by a series of extensive computational experiments.
1 INTRODUCTION
Recurrent Neural Networks are firmly established to be one of the best deep learning techniques when the task at hand requires processing sequential data, such as text, audio, or video (Graves et al., 2013; Mikolov et al., 2011; Gers et al., 1999). The ability of these neural networks to efficiently represent a rich class of functions with a relatively small number of parameters is often referred to as depth efficiency, and the theory behind this phenomenon is not yet fully understood. A recent line of work (Cohen & Shashua, 2016; Cohen et al., 2016; Khrulkov et al., 2018; Cohen et al., 2018) focuses on comparing various deep learning architectures in terms of their expressive power.
It was shown in (Cohen et al., 2016) that ConvNets with product pooling are exponentially more expressive than shallow networks, that is there exist functions realized by ConvNets which require an exponentially large number of parameters in order to be realized by shallow nets. A similar result also holds for RNNs with multiplicative recurrent cells (Khrulkov et al., 2018). We aim to extend this analysis to RNNs with rectifier nonlinearities which are often used in practice. The main challenge of such analysis is that the tools used for analyzing multiplicative networks, namely, properties of standard tensor decompositions and ideas from algebraic geometry, can not be applied in this case, and thus some other approach is required. Our objective is to apply the machinery of generalized tensor decompositions, and show universality and existence of depth efficiency in such RNNs.
2 RELATED WORK
In recent years a great deal of work was done in applications of tensor calculus to both theoretical and practical aspects of deep learning algorithms. (Lebedev et al., 2015) represented filters in a convolutional network with CP decomposition (Harshman, 1970; Carroll & Chang, 1970) which allowed for much faster inference at the cost of a negligible drop in performance. (Novikov et al., 2015) proposed to use Tensor Train (TT) decomposition (Oseledets, 2011) to compress fully­connected layers of large neural networks while preserving their expressive power. Later on, TT was exploited to reduce the number of parameters and improve the performance of recurrent networks in long­term forecasting (Yu et al., 2017) and video classification (Yang et al., 2017) problems.
In addition to the practical benefits, tensor decompositions were used to analyze theoretical aspects of deep neural nets. (Cohen et al., 2016) investigated a connection between various network architectures and tensor decompositions, which made possible to compare their expressive power. Specifically, it
1

Under review as a conference paper at ICLR 2019

was shown that CP and Hierarchial Tucker (Grasedyck, 2010) decompositions correspond to shallow networks and convolutional networks respectively. Recently, this analysis was extended by (Khrulkov et al., 2018) who showed that TT decomposition can be represented as a recurrent network with multiplicative connections. This specific form of RNNs was also empirically proved to provide a substantial performance boost over standard RNN models (Wu et al., 2016).
First results on the connection between tensor decompositions and neural networks were obtained for rather simple architectures, however, later on, they were extended in order to analyze more practical deep neural nets. It was shown that theoretical results can be generalized to a large class of CNNs with ReLU nonlinearities (Cohen & Shashua, 2016) and dilated convolutions (Cohen et al., 2018), providing valuable insights on how they can be improved. However, there is a missing piece in the whole picture as theoretical properties of more complex nonlinear RNNs have yet to be analyzed. In this paper, we elaborate on this problem and present new tools for conducting a theoretical analysis of such RNNs, specifically when rectifier nonlinearities are used.

3 ARCHITECTURES INSPIRED BY TENSOR DECOMPOSITIONS
Let us now recall the known results about the connection of tensor decompositions and multiplicative architectures, and then show how they are generalized in order to include networks with ReLU nonlinearities.

3.1 SCORE FUNCTIONS AND FEATURE TENSOR

Suppose that we are given a dataset of objects with a sequential structure, i.e. every object in the dataset can be written as

X = x(1), x(2), . . . , x(T ) , x(t)  RN .

(1)

We also introduce a parametric feature map f : RN  RM which essentially preprocesses the data before it is fed into the network. Assumption 1 holds for many types of data, e.g. in the case of natural images we can cut them into rectangular patches which are then arranged into vectors x(t). A
typical choice for the feature map f in this particular case is an affine map followed by a nonlinear activation: f(x) = (Ax + b). To draw the connection between tensor decompositions and feature tensors we consider the following score functions (logits):

(X) = W, (X) = (vec W) vec (X),

(2)

where W  RM×M×···×M is a trainable T ­way weight tensor and (X)  RM×M×···×M is the so­called feature tensor, defined as

(X) = f(x(1))  f(x(2)) · · ·  f(x(T )),

(3)

where we have used the operation of outer product , which is important in tensor calculus. For a tensor A of order N and a tensor B of order M their outer product C = A  B is a tensor of order N + M defined as:

Ci1i2...iN j1j2...jM = Ai1i2···iN Bj1j2···jM .

(4)

It is known that equation 2 possesses the universal approximation property (it can approximate any function with any prescribed precision given sufficiently large M ) under mild assumptions on f (Cohen et al., 2016; Girosi & Poggio, 1990).

3.2 TENSOR DECOMPOSITIONS
Working the entire weight tensor W in eq. (2) is impractical for large M and T , since it requires exponential in T number of parameters. Thus, we compactly represent it using tensor decompositions, which will further lead to different neural network architectures, referred to as tensor networks (Cichocki et al., 2017).

2

Under review as a conference paper at ICLR 2019

CP-decomposition The most basic decomposition is the so-called Canonical (CP) decomposition (Harshman, 1970; Carroll & Chang, 1970) which is defined as follows

R
W = rvr(1)  vr(2) · · ·  vr(T ),
r=1

(5)

where vr(t)  RM and minimal value of R such that decomposition equation 5 exists is called canonical rank of a tensor (CP­rank). By substituting eq. (5) into eq. (2) we find that

R RT
(X) = r f(x(1)), vr(1)  · · ·  f(x(T )), vr(T ) = r f(x(t)), vr(t) . (6)

r=1

r=1 t=1

In the equation above, outer products  are taken between scalars and coincide with the ordinary

products between two numbers. However, we would like to keep this notation as it will come in

handy later, when we generalize tensor decompositions to include various nonlinearities.

TT-decomposition Another tensor decomposition is Tensor Train (TT) decomposition (Oseledets, 2011) which is defined as follows

R1 RT -1

W = ···

gr(10)r1



gr(21)r2



···



gr(TT

)
-1

rT

,

r1=1 rT -1=1

(7)

where

g(t)
rt-1 rt



RM

and r0

= rT

=

1 by definition.

If

we

gather

vectors

g(t)
rt-1 rt

for all corre-

sponding indices rt-1  {1, . . . , Rt-1} and rt  {1, . . . , Rt} we will obtain three­dimensional

tensors G(t)  RM×Rt-1×Rt (for t = 1 and t = T we will get matrices G(1)  RM×1×R1 and

G(T )  RM×RT-1×1). The set of all such tensors {G(t)}tT=1 is called TT­cores and minimal values of {Rt}tT=-11 such that decomposition equation 7 exists are called TT­ranks. In the case of TT

decomposition, the score function has the following form:

R1 RT -1 T

(X) = · · ·

f

(x(t)

),

g(t)
rt-1

rt

.

r1=1 rT -1=1 t=1

(8)

3.3 CONNECTION BETWEEN TT AND RNN

Now we want to show that the score function for Tensor Train decomposition exhibits particular recurrent structure similar to that of RNN. We define the following hidden states:

h(1)  RR1 : hr(11) = f(x(1)), gr(10)r1 ,

Rt-1

h(t)  RRt : h(rtt) =

f

(x(t)

),

g(t)
rt-1

rt

h(rtt--11)

rt-1 =1

t = 2, . . . , T.

(9)

Such definition of hidden states allows for more compact form of the score function.

Lemma 3.1. Under the notation introduced in eq. (9), the score function can be written as

(X) = h(T )  R1.

Proof of Lemma 3.1 as well as the proofs of our main results from Section 5 were moved to Appendix A due to limited space.

Note that with a help of TT­cores we can rewrite eq. (9) in a more convenient index form:

h(kt) =

G

(t) ijk

f (x(t) )i

hj(t-1)

=

G (ijt)k

f(x(t))  h(t-1) ,
ij

k = 1, . . . , Rt,

i,j i,j

(10)

where the operation of tensor contraction is used. Combining all weights from G(t) and f(·) into a single variable G(t) and denoting the composition of feature map, outer product, and contraction as g : RRt-1 × RN × RN×Rt-1×Rt  RRt we arrive at the following vector form:

h(t) = g(h(t-1), x(t); (Gt)), h(t)  RRt .

(11)

3

Under review as a conference paper at ICLR 2019

This equation can be considered as a generalization of hidden state equation for Recurrent Neural
Networks as here all hidden states h(t) may in general have different dimensionalities and weight
tensors (Gt) depend on the time step. However, if we set R = R1 = · · · = RT -1 and G = G(2) = · · · = G(T -1) we will get simplified hidden state equation used in standard recurrent architectures:

h(t) = g(h(t-1), x(t); G), h(t)  RR, t = 2, . . . , T - 1.

(12)

Note that this equation is applicable to all hidden states except for the first h(1) = G(1)f(x(1)) and for the last h(T ) = f (x(T ))G(T )h(T -1), due to two­dimensional nature of the corresponding TT­cores. However, we can always pad the input sequence with two auxiliary vectors x(0) and
x(T +1) to get full compliance with the standard RNN structure. Figure 1 depicts tensor network
induced by TT decomposition with cores {G(t)}tT=1.

Figure 1: Neural network architecture which corresponds to recurrent TT­Network.

4 GENERALIZED TENSOR NETWORKS

4.1 GENERALIZED OUTER PRODUCT

In the previous section we showed that tensor decompositions correspond to neural networks of
specific structure, which are simplified versions of those used in practice as they contain multiplicative
nonlinearities only. One possible way to introduce more practical nonlinearities is to replace outer product  in eq. (6) and eq. (10) with a generalized operator  in analogy to kernel methods when scalar product is replaced by nonlinear kernel function. Let  : R × R  R be an associative and commutative binary operator (x, y, z  R : ((x, y), z) = (x, (y, z)) and x, y  R : (x, y) = (y, x)). Note that this operator easily generalizes to the arbitrary number of operands due to associativity. For a tensor A of order N and a tensor B of order M we define their generalized outer product C = A  B as an (N + M ) order tensor with entries given by:

Ci1...iN j1...jM =  (Ai1...iN , Bj1...jM ) .

(13)

Now we can replace  in eqs. (6) and (10) with  and get networks with various nonlinearities. For example, if we take (x, y) = max(x, y, 0) we will get an RNN with rectifier nonlinearities; if we take (x, y) = ln(ex + ey) we will get an RNN with softplus nonlinearities; if we take (x, y) = xy
we will get a simple RNN defined in the previous section. Concretely, we will analyze the following
networks.

Generalized shallow network with ­nonlinearity
· Score function:
R
(X) = r f(x(1)), vr(1)  · · ·  f(x(T )), vr(T )
r=1 R
= r f(x(1)), vr(1) , . . . , f(x(T )), vr(T )
r=1
· Parameters of the network:
 = {r}Rr=1  R, {vr(t)}Rr=,T1,t=1  RM

(14) (15)

4

Under review as a conference paper at ICLR 2019

Generalized RNN with ­nonlinearity

· Score function:

h(kt) =

G (ijt)k

i,j

C(t)f(x(t))  h(t-1) =
ij

G

(t) ijk



i,j

(X) = h(T )

[C(t)f(x(t))]i, hj(t-1) (16)

· Parameters of the network:

 = {C(t)}Tt=1  RL×M , {G(t)}tT=1  RL×Rt-1×Rt

(17)

Note that in eq. (16) we have introduced the matrices C(t) acting on the input states. The purpose of
this modification is to obtain the plausible property of generalized shallow networks being able to be represented as generalized RNNs of width 1 (i.e., with all Ri = 1) for an arbitrary nonlinearity . In the case of (x, y) = xy, the matrices C(t) were not necessary, since they can be simply absorbed by G(t) via tensor contraction (see Appendix A for further clarification on these points).

Initial hidden state Note that generalized RNNs require some choice of the initial hidden state h(0). We find that it is convenient both for theoretical analysis and in practice to initialize h(0) as unit of the operator , i.e. such an element u that (x, y, u) = (x, y) x, y  R. Henceforth, we will assume that such an element exists (e.g., for (x, y) = max(x, y, 0) we take u = 0, for (x, y) = xy we take u = 1), and set h(0) = u. For example, in eq. (9) it was implicitly assumed that h(0) = 1.

4.2 GRID TENSORS

Introduction of generalized outer product allows us to investigate RNNs with wide class of nonlinear activation functions, especially ReLU. While this change looks appealing from the practical viewpoint, it complicates following theoretical analysis, as the transition from obtained networks back to tensors is not straightforward.

In the discussion above, every tensor network had corresponding weight tensor W and we could compare expressivity of associated score functions by comparing some properties of this tensors, such as ranks (Khrulkov et al., 2018; Cohen et al., 2016). This method enabled comprehensive analysis of score functions, as it allows us to calculate and compare their values for all possible input sequences X = x(1), . . . , x(T ) . Unfortunately, we can not apply it in case of generalized tensor networks, as the replacement of standard outer product  with its generalized version  leads to the loss of conformity between tensor networks and weight tensors. Specifically, not for every generalized tensor network with corresponding score function (X) now exists a weight tensor W such that (X) = W, (X) . Also, such properties as universality no longer hold automatically and we have to prove them separately. Indeed as it was noticed in (Cohen & Shashua, 2016) shallow networks with (x, y) = max(x, 0) + max(y, 0) no longer have the universal approximation property. In order to conduct proper theoretical analysis, we adopt the apparatus of so-called grid tensors, first introduced in (Cohen & Shashua, 2016).
Given a set of fixed vectors X = x(1), . . . , x(M) referred to as templates, the grid tensor of X is defined to be the tensor of order T and dimension M in each mode, with entries given by:

 (X)i1i2...iT = (X) , X = x(i1), x(i2), . . . , x(iT ) ,

(18)

where each index it can take values from {1, . . . , M }, i.e. we evaluate the score function on every possible input assembled from the template vectors {x(i)}iM=1. To put it simply, we previously considered the equality of score functions represented by tensor decomposition and tensor network on set of all possible input sequences X = x(1), . . . , x(T ) , x(t)  RN , and now we restricted this set to exponentially large but finite grid of sequences consisting of template vectors only.
Define the matrix F  RM×M which holds the values taken by the representation function f : RN  RM on the selected templates X:

F f(x(1)) f(x(2)) . . . f(x(M)).

(19)

5

Under review as a conference paper at ICLR 2019

Using the matrix F we note that the grid tensor of generalized shallow network has the following form (see Appendix A for derivation):

R
 (X) = r Fvr(1)  Fvr(2)  · · ·  Fvr(T ) .
r=1

(20)

Construction of the grid tensor for generalized RNN is a bit more involved. We find that its grid tensor  (X) can be computed recursively, similar to the hidden state in the case of a single input sequence. The exact formulas turned out to be rather cumbersome and we moved them to Appendix A.

5 MAIN RESULTS

With grid tensors at hand we are ready to compare the expressive power of generalized RNNs and generalized shallow networks. In the further analysis, we will assume that (x, y) = max(x, y, 0), i.e., we analyze RNNs and shallow networks with rectifier nonlinearity. However, we need to make two additional assumptions. First of all, similarly to (Cohen & Shashua, 2016) we fix some templates X such that values of the score function outside of the grid generated by X are irrelevant for classification and call them covering templates. It was argued that for image data values of M of order 100 are sufficient (corresponding covering template vectors may represent Gabor filters). Secondly, we assume that the feature matrix F is invertible, which is a reasonable assumption and in the case of f(x) = (Ax + b) for any distinct template vectors X the parameters A and b can be chosen in such a way that the matrix F is invertible.

5.1 UNIVERSALITY
As was discussed in section 4.2 we can no longer use standard algebraic techniques to verify universality of tensor based networks. Thus, our first result states that generalized RNNs with (x, y) = max(x, y, 0) are universal in a sense that any tensor of order T and size of each mode being m can be realized as a grid tensor of such RNN (and similarly of a generalized shallow network).

Theorem 5.1 (Universality). Let H  RM×M×···×M be an arbitrary tensor of order T . Then there exist a generalized shallow network and a generalized RNN with rectifier nonlinearity (x, y) = max(x, y, 0) such that grid tensor of each of the networks coincides with H.
Part of Theorem 5.1 which corresponds to generalized shallow networks readily follows from (Cohen & Shashua, 2016, Claim 4). In order to prove the statement for the RNNs the following two lemmas are used.
Lemma 5.1. Given two generalized RNNs with grid tensors  A (X),  B (X), and arbitrary -nonlinearity, there exists a generalized RNN with grid tensor  C (X) satisfying
 C (X) = a A (X) + b B (X), a, b  R.

This lemma essentially states that the collection of grid tensors of generalized RNNs with any nonlinearity is closed under taking arbitrary linear combinations. Note that the same result clearly holds for generalized shallow networks because they are linear combinations of rank 1 shallow networks by definition.
Lemma 5.2. Let E(j1j2...jT ) be an arbitrary one­hot tensor, defined as

E (j1j2...jT )
i1 i2 ...iT

=

1, 0,

jt = it t  {1, . . . , T }, otherwise.

Then there exists a generalized RNN with rectifier nonlinearities such that its grid tensor satisfies

 (X) = E (j1j2...jT ).

This lemma states that in the special case of rectifier nonlinearity (x, y) = max(x, y, 0) any basis tensor can be realized by some generalized RNN.

6

Under review as a conference paper at ICLR 2019

Proof of Theorem 5.1. By Lemma 5.2 for each one­hot tensor E(i1i2...iT ) there exists a generalized RNN with rectifier nonlinearities, such that its grid tensor coincides with this tensor. Thus, by Lemma 5.1 we can construct an RNN with

 (X) =

Hi1i2...id E (i1i2...iT ) = H.

i1 ,i2 ,...,iT

For generalized shallow networks with rectifier nonlinearities see the proof of (Cohen & Shashua, 2016, Claim 4).

The same result regarding networks with product nonlinearities considered in (Khrulkov et al., 2018) directly follows from the well­known properties of tensor decompositions (see Appendix A).
We see that at least with such nonlinearities as (x, y) = max(x, y, 0) and (x, y) = xy all the networks under consideration are universal and can represent any possible grid tensor. Now let us head to a discussion of expressivity of these networks.

5.2 EXPRESSIVITY

As was discussed in the introduction, expressivity refers to the ability of some class of networks to represent the same functions as some other class much more compactly. In our case the parameters defining size of networks are ranks of the decomposition, i.e. in the case of generalized RNNs ranks determine the size of the hidden state, and in the case of generalized shallow networks rank determines the width of a network. It was proven in (Cohen et al., 2016; Khrulkov et al., 2018) that ConvNets and RNNs with multiplicative nonlinearities are exponentially more expressive than the equivalent shallow networks: shallow networks of exponentially large width are required to realize the same score functions as computed by these deep architectures. Similarly to the case of ConvNets (Cohen & Shashua, 2016), we find that expressivity of generalized RNNs with rectifier nonlinearity holds only partially, as discussed in the following two theorems. For simplicity, we assume that T is even.

Theorem 5.2 (Expressivity 1). For every value of R there exists a generalized RNN with ranks

 R and rectifier nonlinearity which is exponentially more efficient than shallow networks, i.e., the

corresponding grid tensor may be realized only by a shallow network with rectifier nonlinearity of

width

at

least

2 MT

min(M, R)T/2.

This result states that at least for some subset of generalized RNNs expressivity holds: exponentially wide shallow networks are required to realize the same grid tensor. Proof of the theorem is rather straightforward: we explicitly construct an example of such RNN which satisfies the following description. Given an arbitrary input sequence X = x(1), . . . x(T ) assembled from the templates, these networks (if M = R) produce 0 if X has the property that x(1) = x(2), x(3) = x(4), . . . , x(T -1) = x(T ), and 1 in every other case, i.e. they measure pairwise similarity of the input vectors. A precise proof is given in Appendix A. In the case of multiplicative RNNs (Khrulkov et al., 2018) almost every network possessed this property. This is not the case, however, for generalized RNNs with rectifier nonlinearities.
Theorem 5.3 (Expressivity 2). For every value of R there exists an open set (which thus has positive measure) of generalized RNNs with rectifier nonlinearity (x, y) = max(x, y, 0), such that for each RNN in this open set the corresponding grid tensor can be realized by a rank 1 shallow network with rectifier nonlinearity.

In other words, for every rank R we can find a set of generalized RNNs of positive measure such that the property of expressivity does not hold. In the numerical experiments in Section 6 and Appendix A we validate whether this can be observed in practice, and find that the probability of obtaining CP­ranks of polynomial size becomes negligible with large T and R. Proof of Theorem 5.3 is provided in Appendix A.

Shared case Note that all the RNNs used in practice have shared weights, which allows them to
process sequences of arbitrary length. So far in the analysis we have not made such assumptions about RNNs (i.e., G(2) = · · · = G(T -1)). By imposing this constraint, we lose the property of
universality; however, we believe that the statements of Theorems 5.2 and 5.3 still hold (without

7

Under review as a conference paper at ICLR 2019
requiring that shallow networks also have shared weights). Note that the example constructed in the proof of Theorem 5.3 already has this property, and for Theorem 5.2 we provide numerical evidence in Appendix A.
6 EXPERIMENTS
In this section, we study if our theoretical findings are supported by experimental data. In particular, we investigate whether generalized tensor networks can be used in practical settings, especially in problems typically solved by RNNs (such as natural language processing problems). Secondly, according to Theorem 5.3 for some subset of RNNs the equivalent shallow network may have a low rank. To get a grasp of how strong this effect might be in practice we numerically compute an estimate for this rank in various settings.
Performance For the first experiment, we use two computer vision datasets MNIST (LeCun et al., 1990) and CIFAR­10 (Krizhevsky & Hinton, 2009), and natural language processing dataset for sentiment analysis IMDB (Maas et al., 2011). For the first two datasets, we cut natural images into rectangular patches which are then arranged into vectors x(t) (similar to (Khrulkov et al., 2018)) and for IMDB dataset the input data already has the desired sequential structure. Figure 2 depicts test accuracy on IMDB dataset for generalized shallow networks and RNNs with rectifier nonlinearity. We see that generalized shallow network of much higher rank is required to get the level of performance close to that achievable by generalized RNN. Due to limited space, we have moved the results of the experiments on the visual datasets to Appendix B.

Figure 2: Test accuracy on IMDB dataset for generalized RNNs and generalized shallow networks with respect to the total number of parameters (m = 50, T = 100, (x, y) = max(x, y, 0)).

Figure 3: Distribution of lower bounds on the rank of generalized shallow networks equivalent to randomly generated generalized RNNs of ranks 1, 2, 4, 8 (M = 10, T = 6).

Expressivity For the second experiment we generate a number of generalized RNNs with different values of TT-rank r and calculate a lower bound on the rank of shallow network necessary to realize the same grid tensor (to estimate the rank we use the same technique as in the proof of Theorem 5.2). Figure 3 shows that for different values of R and generalized RNNs of the corresponding rank there exist shallow networks of rank 1 realizing the same grid tensor, which agrees well with Theorem 5.3. This result looks discouraging, however, there is also a positive observation. While increasing rank of generalized RNNs, more and more corresponding shallow networks will necessarily have exponentially higher rank. In practice we usually deal with RNNs of R = 102 - 103 (dimension of hidden states), thus we may expect that effectively any function besides negligible set realized by generalized RNNs can be implemented only by exponentially wider shallow networks. The numerical results for the case of shared cores and other nonlinearities are given in Appendix B.
8

Under review as a conference paper at ICLR 2019
7 CONCLUSION
In this paper, we sought a more complete picture of the connection between Recurrent Neural Networks and Tensor Train decomposition, one that involves various nonlinearities applied to hidden states. We showed how these nonlinearities could be incorporated into network architectures and provided complete theoretical analysis on the particular case of rectifier nonlinearity, elaborating on points of generality and expressive power. We believe our results will be useful to advance theoretical understanding of RNNs. In future work, we would like to extend the theoretical analysis to most competitive in practice architectures for processing sequential data such as LSTMs and attention mechanisms.
REFERENCES
J Douglas Carroll and Jih-Jie Chang. Analysis of individual differences in multidimensional scaling via an N-way generalization of Eckart-Young decomposition. Psychometrika, 1970.
Andrzej Cichocki, Anh-Huy Phan, Qibin Zhao, Namgil Lee, Ivan Oseledets, Masashi Sugiyama, Danilo P Mandic, et al. Tensor networks for dimensionality reduction and large-scale optimization: Part 2 applications and future perspectives. Foundations and Trends® in Machine Learning, 9(6): 431­673, 2017.
Nadav Cohen and Amnon Shashua. Convolutional rectifier networks as generalized tensor decompositions. In International Conference on Machine Learning, pp. 955­963, 2016.
Nadav Cohen, Or Sharir, and Amnon Shashua. On the expressive power of deep learning: A tensor analysis. In Conference on Learning Theory, pp. 698­728, 2016.
Nadav Cohen, Ronen Tamari, and Amnon Shashua. Boosting dilated convolutional networks with mixed tensor decompositions. In International Conference on Learning Representations, 2018. URL https://openreview.net/forum?id=S1JHhv6TW.
Felix A Gers, Ju¨rgen Schmidhuber, and Fred Cummins. Learning to forget: Continual prediction with LSTM. 1999.
Federico Girosi and Tomaso Poggio. Networks and the best approximation property. Biological cybernetics, 63(3):169­176, 1990.
Lars Grasedyck. Hierarchical singular value decomposition of tensors. SIAM Journal on Matrix Analysis and Applications, 31(4):2029­2054, 2010.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recurrent neural networks. In Acoustics, speech and signal processing (icassp), 2013 ieee international conference on, pp. 6645­6649. IEEE, 2013.
Richard A Harshman. Foundations of the PARAFAC procedure: Models and conditions for an "explanatory" multimodal factor analysis. 1970.
Valentin Khrulkov, Alexander Novikov, and Ivan Oseledets. Expressive power of recurrent neural networks. In International Conference on Learning Representations, 2018. URL https:// openreview.net/forum?id=S1WRibb0Z.
Tamara G Kolda and Brett W Bader. Tensor decompositions and applications. SIAM review, 51(3): 455­500, 2009.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Vadim Lebedev, Yaroslav Ganin, Maksim Rakhuba, Ivan Oseledets, and Victor Lempitsky. Speedingup convolutional neural networks using fine-tuned cp-decomposition. International Conference on Learning Representations, 2015.
Yann LeCun, Bernhard E Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne E Hubbard, and Lawrence D Jackel. Handwritten digit recognition with a back-propagation network. In Advances in neural information processing systems, pp. 396­404, 1990.
9

Under review as a conference paper at ICLR 2019
Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. Learning word vectors for sentiment analysis. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pp. 142­150, Portland, Oregon, USA, June 2011. Association for Computational Linguistics. URL http: //www.aclweb.org/anthology/P11-1015.
Toma´s Mikolov, Stefan Kombrink, Luka´s Burget, Jan C ernocky`, and Sanjeev Khudanpur. Extensions of recurrent neural network language model. In Acoustics, Speech and Signal Processing (ICASSP), 2011 IEEE International Conference on, pp. 5528­5531. IEEE, 2011.
Alexander Novikov, Dmitrii Podoprikhin, Anton Osokin, and Dmitry P Vetrov. Tensorizing neural networks. In Advances in Neural Information Processing Systems, pp. 442­450, 2015.
Ivan V Oseledets. Tensor-train decomposition. SIAM Journal on Scientific Computing, 33(5): 2295­2317, 2011.
Yuhuai Wu, Saizheng Zhang, Ying Zhang, Yoshua Bengio, and Ruslan R Salakhutdinov. On multiplicative integration with recurrent neural networks. In Advances in Neural Information Processing Systems, pp. 2856­2864, 2016.
Yinchong Yang, Denis Krompass, and Volker Tresp. Tensor-train recurrent neural networks for video classification. arXiv preprint arXiv:1707.01786, 2017.
Rose Yu, Stephan Zheng, Anima Anandkumar, and Yisong Yue. Long-term forecasting using tensor-train RNNs. arXiv preprint arXiv:1711.00073, 2017.
10

Under review as a conference paper at ICLR 2019

A PROOFS

Lemma 3.1. Under the notation introduced in eq. (9), the score function can be written as (X) = h(T )  R1.

Proof.

R1 RT -1 T

l(X) = · · ·

f

(x(t)

),

g(t)
rt-1

rt

r1=1 rT -1=1 t=1

R1 RT -1 T

= ···

f

(x(t)

),

g(t)
rt-1

rt

r1=1 rT -1=1 t=2

f(x(1)), gr(10)r1
h(r11)

RT -1

R1 T

= ···

f

(x(t)

),

g(t)
rt-1

rt

h(r11)

rT -1=1 r1=1 t=2

RT -1

R2 T

= ···

f

(x(t)

),

g(t)
rt-1

rt

rT -1=1 r2=1 t=3

r1
f(x(2)), gr(21)r2 hr(11)
r1 =1

RT -1

R2 T

= ···

f

(x(t)

),

g(t)
rt-1

rt

h(r22)

rT -1=1 r2=1 t=3

= ...

hr(22)

RT -1

=

f

(x(T

)

),

gr(TT

)
-1

rT

hr(TT

-1)
-1

=

h(rTT )

=

h(T ).

rT -1=1

Proposition A.1. If we replace the generalized outer product  in eq. (16) with the standard outer product , we can subsume matrices C(t) into tensors G(t) without loss of generality.

Proof. Let us rewrite hidden state equation eq. (16) after transition from  to :

h(kt) =

G

(t) ijk

C(t)f(x(t))  h(t-1)
ij

i,j

=

G

(t) ijk

C(ilt) f (x(t) )l h(jt-1)

i,j l

=

G~

(t) ljk

f

(x(t)

)l

hj(t-1)

l,j

=

G~

(t) ljk

f(x(t))  h(t-1)

.

lj

l,j

G~ l(jt)k =

G

(t) ijk

Ci(lt)

i

We see that the obtained expression resembles those presented in eq. (10) with TT-cores G(t) replaced by G~ (t) and thus all the reasoning applied in the absence of matrices C(t) holds valid.

Proposition A.2. Grid tensor of generalized shallow network has the following form (eq. (20)):

R
 (X) = r Fvr(1)  Fvr(2)  · · ·  Fvr(T ) .
r=1

11

Under review as a conference paper at ICLR 2019

Proof. Let X = x(i1), x(i2), . . . , x(iT ) denote an arbitrary sequence of templates. Corresponding element of the grid tensor defined in eq. (20) has the following form:

R

 (X)i1i2...iT =

r

r=1

Fvr(1)  Fvr(2)  · · ·  Fvr(T )
i1 i2 ...iT

R
= r
r=1

Fvr(1) 
i1

Fvr(2)  · · · 
i2

Fvr(T )
iT

R
= r
r=1

f(x(i1)), vr(1) , . . . , f(x(iT )), vr(T )

= (X).

Proposition A.3. Grid tensor of a generalized RNN has the following form:

 ,0(X) = h(0)  R1,

 ,1(X)km1 =

G

(1) ijk

i,j

C(1)F

  ,0

 RR1×M ,

im1 j

 ,2(X)km1m2 =

G (ij2k)

i,j

···

C(2)F

  ,1

 RR2×M×M ,

im2 j m1

(21)

 ,T (X)km1m2...mT =

G

(T ) ijk

i,j

 (X) =  ,T (X)1,:,:,...,:

C(T )F

  ,T -1

 R1×M×M×···×M ,

imT jm1...mT -1

Proof. Proof is similar to that of Proposition A.2 and uses eq. (16) to compute the elements of the grid tensor.
Lemma 5.1. Given two generalized RNNs with grid tensors  A (X),  B (X), and arbitrary -nonlinearity, there exists a generalized RNN with grid tensor  C (X) satisfying
 C (X) = a A (X) + b B (X), a, b  R.

Proof. Let these RNNs be defined by the weight parameters

A =

{CA(t)}tT=1



RLA

×M

,

{G

(t) A

}tT=1



RLA ×Rt-1,A ×Rt,A

,

and

B =

{C(Bt)}Tt=1



RLB

×M

,

{G

(t) B

}Tt=1



RLB ×Rt-1,B ×Rt,B

.

12

Under review as a conference paper at ICLR 2019

We claim that the desired grid tensor is given by the RNN with the following weight settings.

CC(t)  R(LA+LB )×M

CC(t) =

C(At) CB(t)

G

(1) C



R(LA+LB )×1×(Rt,A+Rt,B )


 

[G (A1) ]i,:,:

0,

i  {1, . . . , LA}

[G(C1)]i,:,: = 



 

0

[G

(1) B

](i-LA

),:,:

,

i  {LA + 1, . . . , LA + LB}

G  R ,(t) (LA+LB )×(Rt-1,A+Rt-1,B )×(Rt,A+Rt,B )
C

1<t<T


 

[G (At) ]i,:,:



  

0

0, 0

i  {1, . . . , LA}

[GC(t)]i,:,: = 

  

0





 

0

0

[G

(t) B

](i-LA

),:,:

,

i  {LA + 1, . . . , LA + LB}

G  R(T )
C

(LA+LB )×(Rt-1,A+Rt-1,B )×1


 

a[G

(T A

)]i,:,:



 

0



[G(CT )]i,:,: = 

,

i  {1, . . . , LA}

  

0



  

b[G

(T B

)

](i-LA

),:,:

,

i  {LA + 1, . . . , LA + LB}.

It is straightforward to verify that the network defined by these weights possesses the following property:

hC(t) =

h(At) h(Bt)

,

0 < t < T,

and hC(T ) = ahA(T ) + bh(BT ),

concluding the proof. We also note that these formulas generalize the well­known formulas for addition of two tensors in the Tensor Train format (Oseledets, 2011).

Proposition A.4. For any associative and commutative binary operator , an arbitrary generalized rank 1 shallow network with ­nonlinearity can be represented in a form of generalized RNN with unit ranks (R1 = · · · = RT -1 = 1) and ­nonlinearity.

Proof. Let  = , {v(t)}Tt=1 be the parameters specifying the given generalized shallow network. Then the following weight settings provide the equivalent generalized RNN (with h(0) being the unity of the operator ).
C(t) = v(t)  R1×M , G(t) = 1, t < T, G(T ) = .
Indeed, in the notation defined above, hidden states of generalized RNN have the following form:

13

Under review as a conference paper at ICLR 2019

h(t) = G(t) [C(t)f(x(t))], h(t-1) =  f(x(t)), v(t) , h(t-1) , t = 1, . . . , T - 1
h(T ) =  f(x(T )), v(T ) , h(T -1) .
The score function of generalized RNN is given by eq. (16):
(X) = h(T ) =  f(x(T )), v(T ) , h(T -1) =  f(x(T )), v(T ) , f(x(T -1)), v(T -1) , h(T -2) ... =  f(x(T )), v(T ) , . . . , f(x(1)), v(1) ,
which coincides with the score function of rank-one shallow network defined by parameters .

Lemma 5.2. Let E(j1j2...jT ) be an arbitrary one­hot tensor, defined as

E (j1j2...jT )
i1 i2 ...iT

=

1, 0,

jt = it t  {1, . . . , T }, otherwise.

Then there exists a generalized RNN with rectifier nonlinearities such that its grid tensor satisfies

 (X) = E (j1j2...jT ).

Proof. It is known that the statement of the lemma holds for generalized shallow networks with rectifier nonlinearities (see (Cohen & Shashua, 2016, Claim 4)). Based on Proposition A.4 and Lemma 5.1 we can conclude that it also holds for generalized RNNs with rectifier nonlinearities.
Proposition A.5. Statement of Theorem 5.1 holds with (x, y) = xy.

Proof. By assumption the matrix F is invertible. Consider the following tensor H :

Hi1i2...iT =

Hj1,...,jT F-j11i1 . . . F-jT1iT ,

j1 ,...,jT

and the score function in the form of eq. (2):

(X) = H, (X) .

Note that by construction for any input assembled from the template vectors we obtain
(x(i1), . . . , x(iT )) = Hi1...iT . By taking the standard TT and CP decompositions of H which always exist (Oseledets, 2011; Kolda & Bader, 2009), and using Lemma 3.1 and eq. (6) we conclude
that universality holds.

Theorem 5.2 (Expressivity 1). For every value of R there exists a generalized RNN with ranks

 R and rectifier nonlinearity which is exponentially more efficient than shallow networks, i.e., the

corresponding grid tensor may be realized only by a shallow network with rectifier nonlinearity of

width

at

least

2 MT

min(M, R)T/2.

In order to prove the theorem we will use the standard technique of matricizations. Simply put, by
matricizing a tensor we reshape it into a matrix by splitting the indices of a tensor into two collections, and converting each one of them into one long index. I.e., for a tensor A of order T with mode sizes being m, we split the set {1, . . . , T } into two non­overlapping ordered subsets s and t, and define the matricization A(s,t)  RM|s|×M|t| by simply reshaping (and possibly transposing) the tensor A according to s and t. We will consider the matricization obtained by taking sodd = (1, 3, . . . , T - 1),

14

Under review as a conference paper at ICLR 2019

teven = (2, 4, . . . , T ), i.e., we split out even and odd modes. A typical application of matricization is the following: suppose that we can upper and lower bound the ordinary matrix rank of a certain matricization using the parameters specifying each of the architectures being analyzed. Then under the assumption that both architectures realize the same grid tensor (and thus ranks of the matricization coincide) we can compare the sizes of corresponding architectures. In the case of generalized shallow networks with rectifier nonlinearity we will use the following result (Cohen & Shashua, 2016, Claim 9).
Lemma A.1. Let  (X) be a grid tensor generated by a generalized shallow network of rank R and (x, y) = max(x, y, 0). Then

rank

 (X)

(sodd ,teven )



TM R

,

2

where the ordinary matrix rank is assumed.

This result is a generalization of a well­known property of the standard CP-decomposition (i.e. if (x, y) = xy), which states that for a rank R decomposition, the matrix rank of every matricization is bounded by R.
In order to prove Theorem 5.2 we will construct an example of a generalized RNN with exponentially large matrix rank of the matricization of grid tensor, from which and Lemma A.1 the statement of the theorem will follow.
Lemma A.2. Without loss of generality assume that xi = ei (which can be achieved since F is invertible). Let 1(p,q) denote the matrix of size p×q with each entry being 1, I(p,q) denote the matrix of size p×q with Ii(jp,q) = ij ( being the Kronecker symbol), and b = [1-min(M, R), 0R-1]  R1×R. Consider the following weight setting for a generalized RNN with (x, y) = max(x, y, 0).

C(t) =

1M,M - IM,M , t odd, 1M+1,M - IM+1,M , t even.

IM,R  RM×1×R, t odd,



G(t) = IM,R b

 R(M+1)×R×1, t even.

Then grid tensor  (X) of this RNN satisfies rank  (X) (sodd,teven)  min(M, R)T/2,
where the ordinary matrix rank is assumed.

Proof. Informal description of the network defined by weights in the statement in the lemma is the following. Given some input vector ei it is first transformed into its bitwise negative ei, and its first R components are saved into the hidden state. The next block then measures whether the first min(R, M ) components of the current input coincide with the hidden state (after again taking bitwise negative). If this is the case, the hidden state is set 0 and the process continues. Otherwise, the hidden state is set to 1 which then flows to the output independently of the other inputs. In other words, for all the inputs of the form X = (xi1 , xi1 , . . . , xiT/2 , xiT/2 ) with i1  R, . . . , iT/2  R we obtain that (X) = 0, and in every other case (X) = 1. Thus, we obtain that  (X) (sodd,teven)
is a matrix with all the entries equal to 1, except for min(M, R)T/2 entries on the diagonal, which are equal to 0. Rank of such a matrix is RT/2 + 1 if R < M and M T/2 otherwise, and the statement of the lemma follows.

Based on these two lemmas we immediately obtain Theorem 5.2.

Proof of Theorem 5.2. Consider the example constructed in the proof of Lemma A.2. By

Lemma A.1 the rank of the shallow network with rectifier nonlinearity which is able to represent the

same

grid

tensor

is

at

least

2 TM

min(M, R)T/2.

15

Under review as a conference paper at ICLR 2019

Theorem 5.3 (Expressivity 2). For every value of R there exists an open set (which thus has positive measure) of generalized RNNs with rectifier nonlinearity (x, y) = max(x, y, 0), such that for each RNN in this open set the corresponding grid tensor can be realized by a rank 1 shallow network with rectifier nonlinearity.

Proof. As before, let us denote by I(p,q) a matrix of size p × q such that Ii(jp,q) = ij, and by a(p1,p2,...pd) we denote a tensor of size p1 × · · · × pd with each entry being a (sometimes we will omit the dimensions when they can be inferred from the context). Consider the following weight settings for a generalized RNN.
C(t) = F -1 ,

2(M,1,R), t = 1  G(t) = 1(M,R,R), t = 2, . . . , T - 1 1(M,R,1), t = T

The RNN defined by these weights has the property that  (X) is a constant tensor with each entry being 2(M R)T -1, which can be trivially represented by a rank 1 generalized shallow network. We will show that this property holds under a small perturbation of C(t), G(t) and F. Let us denote each of these perturbation (and every tensor appearing size of which can be assumed indefinitely small) collectively by . Applying eq. (21) we obtain (with (x, y) = max(x, y, 0)).
 ,0(X) = 0  R1,

 ,1(X)km1 =

G i(j1k)

i,j

(I(M,M) + )  0

= 1  (2 + ),

im1 j

 ,2(X)km1m2 =

G

(2) ijk

i,j

···

(I(M,M) + )   ,1(X)

= 1  (2MR + )  1,

im2 j m1

 ,T (X)km1m2...mT = 1  (2(MR)T-1 + )  1 · · ·  1,
 (X) =  ,T (X)1,:,:,...,: = (2(MR)T-1 + )  1 · · ·  1,
where we have used a simple property connecting  with (x, y) = max(x, y, 0) and ordinary : if for tensors A and B each entry of A is greater than each entry of B, A  B = A  1. The obtained grid tensors can be represented using rank 1 generalized shallow networks with the following weight settings.
 = 1,

vt =

F- 1(2(MR)T-1 + ), t = 1, 0, t > 1,

where F is the feature matrix of the corresponding perturbed network.

B ADDITIONAL EXPERIMENTS
In this section we provide the results additional computational experiments, aimed to provide more thorough and complete analysis of generalized RNNs.
Different -nonlinearities In this paper we presented theoretical analysis of rectifier nonlinearity which corresponds to (x, y) = max(x, y, 0). However, there is a number of other associative binary operators  which can be incorporated in generalized tensor networks. Strictly speaking, every one of them has to be carefully explored theoretically in order to speak about their generality and expressive power, but for now we can compare them empirically.
Table 1 shows the performance (accuracy on test data) of different nonlinearities on MNIST, CIFAR--10, and IMDB datasets for classification. Although these problems are not considered hard to solve, we see that the right choice of nonlinearity can lead to a significant boost in performance. For the experiments on the visual datasets we used T = 16, m = 32, R = 64 and for the experiments on the IMDB dataset we had T = 100, m = 50, R = 50. Parameters of all networks were optimized using Adam (learning rate  = 10-4) and batch size 250.

16

Under review as a conference paper at ICLR 2019

(x, y)
MNIST CIFAR-10
IMDB

xy
97.39 43.08 83.33

max(x, y, 0)
97.45 48.09 84.35

ln (ex + ey)
97.68 55.37 82.25

x+y
96.28 57.18 81.28

x2 + y2
96.44 49.04 79.76

Table 1: Performance of generalized RNN with various nonlinearities.

Expressivity in the case of shared cores We repeat the expressivity experiments from Section 6 in the case of equal TT­cores (G(2) = · · · = G(T -1)). We observe that similar to the case of different cores, there always exist rank 1 generalized shallow networks which realize the same score function as generalized RNN of higher rank, however, this situation seems too unlikely for big values of R.

Figure 4: Distribution of lower bounds on the rank of generalized shallow networks equivalent to randomly generated generalized RNNs of ranks (M = 6, T = 6, (x, y) = max(x, y, 0)).

Figure 5: Distribution of lower bounds on the rank of generalized shallow networks equivalent to randomly generated generalized RNNs of
ranks (M = 6, T = 6, (x, y) = x2 + y2).

17

