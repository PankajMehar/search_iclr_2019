Under review as a conference paper at ICLR 2019
NEAR-OPTIMAL REPRESENTATION LEARNING FOR HIERARCHICAL REINFORCEMENT LEARNING
Anonymous authors Paper under double-blind review
ABSTRACT
We study the problem of representation learning in goal-conditioned hierarchical reinforcement learning. In such hierarchical structures, a higher-level controller solves tasks by iteratively communicating goals which a lower-level policy is trained to reach. Accordingly, the choice of representation ­ the mapping of observation space to goal space ­ is crucial. To study this problem, we develop a notion of sub-optimality of a representation, defined in terms of expected reward of the optimal hierarchical policy using this representation. We derive expressions which bound the sub-optimality and show how these expressions can be translated to representation learning objectives which may be optimized in practice. Results on a number of difficult continuous-control tasks show that our approach to representation learning yields qualitatively better representations as well as quantitatively better hierarchical policies, compared to existing methods.1
1 INTRODUCTION
Hierarchical reinforcement learning has long held the promise of extending the successes of existing reinforcement learning (RL) methods (Gu et al., 2017; Schulman et al., 2015; Lillicrap et al., 2015) to more complex, difficult, and temporally extended tasks (Parr & Russell, 1998; Sutton et al., 1999; Barto & Mahadevan, 2003). Recently, goal-conditioned hierarchical designs, in which higher-level policies communicate goals to lower-levels and lower-level policies are rewarded for reaching states (i.e. observations) which are close to these desired goals, have emerged as an effective paradigm for hierarchical RL (Nachum et al., 2018; Levy et al., 2017; Vezhnevets et al., 2017). In this hierarchical design, representation learning ­ the mapping between observation space and goal space ­ determines the types of sub-tasks the lower-level can be instructed to perform, and is therefore a critical component determining the success or failure of a hierarchical agent.
Previous works have largely studied two ways to choose the representation: learning the representation end-to-end together with the higher- and lower-level policies (Vezhnevets et al., 2017), or using the state space as-is for the goal space (i.e., the goal space is a subspace of the state space) (Nachum et al., 2018; Levy et al., 2017). The former approach is appealing, but in practice often produces poor results (see Nachum et al. (2018) and our own experiments), since the resulting representation is under-defined; i.e., not all possible sub-tasks are expressible as goals in the space. On the other hand, fixing the representation to be the full state means that no information is lost, but this choice is difficult to scale to higher dimensions. For example, if the state observations are entire images, the higher-level must output target images for the lower-level, which can be very difficult.
We instead study how unsupervised objectives can be used to train a representation that is more concise than the full state, but also not as under-determined as in the end-to-end approach. In order to do so in a principled manner, we propose a measure of sub-optimality of a given representation. This measure aims to answer the question: How much does using the learned representation in place of the full representation cause us to lose, in terms of expected reward, against the optimal policy? This question is important, because a useful representation will compress the state, hopefully making the learning problem easier. At the same time, the compression might cause the representation to lose information, making the optimal policy impossible to express. It is therefore critical to understand how lossy a learned representation is, not in terms of reconstruction, but in terms of the ability to represent near-optimal policies on top of this representation.
1See videos at https://sites.google.com/view/representation-hrl
1

Under review as a conference paper at ICLR 2019

Our main theoretical result shows that, for a particular choice of representation learning objective, we can learn representations for which the return of the hierarchical policy approaches the return of the optimal policy within a bounded error. This suggests that, if the representation is learned with a principled objective, the `lossy-ness' in the resulting representation should not cause a decrease in overall task performance. We then formulate a representation learning approach that optimizes this bound. We further extend our result to the case of temporal abstraction, where the higher-level controller only chooses new goals at fixed time intervals. To our knowledge, this is the first result showing that hierarchical goal-setting policies with learned representations and temporal abstraction can achieve bounded sub-optimality against the optimal policy. We further observe that the representation learning objective suggested by our theoretical result closely resembles several other recently proposed objectives based on mutual information (van den Oord et al., 2018; Ishmael Belghazi et al., 2018; Hjelm et al., 2018), suggesting an intriguing connection between mutual information and goal representations for hierarchical RL. Results on a number of difficult continuous-control navigation tasks show that our principled representation learning objective yields good qualitative and quantitative performance compared to existing methods.

2 FRAMEWORK

Following previous work (Nachum et al., 2018), we consider a two-level hierarchical policy on an MDP M = (S, A, R, T ), in which the higher-level policy modulates the behavior of a lower-
level policy by choosing a desired goal state and rewarding the lower-level policy for reaching this
state. While prior work has used a sub-space of the state space as goals (Nachum et al., 2018),
in more general settings, some type of state representation is necessary. That is, consider a state representation function f : S  Rd. A two-level hierarchical policy on M is composed of a higher-level policy hi(g|s), where g  G = Rd is the goal space, that samples a high-level action (or goal) gt  hi(g|st) every c steps, for fixed c. A non-stationary, goal-conditioned, lower-level policy lo(a|st, gt, st+k, k) then translates these high-level actions into low-level actions at+k  A for k  [0, c - 1]. The process is then repeated, beginning with the higher-level policy selecting
another goal according to st+c. The policy lo is trained using a goal-conditioned reward; e.g. the reward of a transition g, s, s is -D(f (s ), g), where D is a distance function.

In this work we adopt a slightly differ-

ent interpretation of the lower-level pol-
icy and its relation to hi. Every c steps, the higher-level policy chooses a goal gt based on a state st. We interpret this

hi

g0 

Pfroosrtdaaurpctipenrsgoaofrcpohtmiimngsa0lg.00

Representation space

neg low-level reward

g0

f(s1 ) f(s2 ) . . . f(sc )

hi
gc 

state-goal pair as being mapped to a non-

0

stationary policy (a|st+k, k),   , s0 where  denotes the set of all possible

a0

0 s1 a1

. . . sc - 1

0 ac - 1

c sc ac

...

c-step policies acting on M. We use  to denote this mapping from S × G to

Environment

...

...

. In other words, on every cth step, we encounter some state st  S. We use the higher-level policy to sample a goal

R0 R1

Rc-1

Rc

Figure 1: The hierarchical design we consider.

gt  hi(g|st) and translate this to a policy t = (st, gt). We then use t to sample actions

at+k  t(a|st+k, k) for k  [0, c - 1]. The process is then repeated from st+c.

Although the difference in this interpretation is subtle, the introduction of  is crucial for our sub-
sequent analysis. The communication of gt is no longer as a goal which hi desires to reach, but rather more precisely, as an identifier to a low-level behavior which hi desires to induce or activate.

The mapping  is usually expressed as the result of an RL optimization over ; e.g.,

c
(st, g) = arg max k-1EP(st+k|st)[-D(f (st+k), g)],
 k=1

(1)

where we use P(st+k|st) to denote the probability of being in state st+k after following  for k steps starting from st. We will consider variations on this low-level objective in later sections. From Equation 1 it is clear how the choice of representation f affects  (albeit indirectly).

We will restrict the environment reward function R to be defined only on states. We use Rmax to denote the maximal absolute reward: Rmax = supS |R(s)|.

2

Under review as a conference paper at ICLR 2019

3 HIERARCHICAL POLICY SUB-OPTIMALITY

In the previous section, we introduced two-level policies where a higher-level policy hi chooses goals g, which are translated to lower-level behaviors via . The introduction of this hierarchy leads to a natural question: How much do we lose by learning hi which is only able to act on M via ? The choice of  restricts the type and number of lower-level behaviors that the higher-level policy can induce. Thus, the optimal policy on M is potentially not expressible by hi. Despite the potential lossy-ness of , can one still learn a hierarchical policy which is near-optimal?

To approach this question, we introduce a notion of sub-optimality with respect to the form of : lLabponeohewhsiteosa-rpilvbehttiviiloom(eerglala|onbslwe,hoh-iplgae)tvhvibimeeowerlra-stlhblhe.ievhecLheihoaeelvprtipasitoiromahcrlpihiseac.pirlyclWbhiaeeliedghpthtihthoe(oeelri-nMcc|losyed)rverefeanolsgorppntaoetoohglnsiencdtoiyficnsoaatgltsiclocotftiuhwtnolegil;nfhoigu.inele.cl.rGhaTseritovaecenerhpadrdisyrce.cuafihcIlsnniipscenottagehllpiicpssyo,wawlosiacenhtyyhi,bMeresemgahs.miiuanWlppmtbieplneayiwgsnygiiafnelrlfxtolrrcopmooowrmdem-uslGcpsheiaivantr.elogell We would like to compare hier to , and we do so in terms of state values. Let V (s) be the future value achieved by a policy  starting at state s. We define the sub-optimality of  as

SubOpt() = sup V  (s) - V hier (s).
sS

(2)

The state values V hier (s) are determined by the form of , which is in turn determined by the choice of representation f . However, none of these relationships are direct. It is unclear how a change in f will result in a change to the sub-optimality. In the following section, we derive a series of bounds which establish a more direct relationship between SubOpt() and f . Our main result will show that if one defines  as a slight modification of the traditional objective given in Equation 1, then one may translate sub-optimality of  to a practical representation learning objective for f .

4 GOOD REPRESENTATIONS LEAD TO BOUNDED SUB-OPTIMALITY
In this section, we provide proxy expressions that bound the sub-optimality induced by a specific choice of . Our main result is Claim 4, which connects the sub-optimality of  to both goalconditioned policy objectives (i.e., the objective in 1) and representation learning (i.e., an objective for the function f ).

4.1 SINGLE-STEPS (c = 1) AND DETERMINISTIC POLICIES

For ease of presentation, we begin by presenting our results in the restricted case of c = 1 and deterministic lower-level policies. In this setting, the class of low-level policies  may be taken to be simply A, where a   corresponds to a policy which always chooses action a. There is no temporal abstraction: The higher-level policy chooses a high-level action g  G at every step, which is translated via  to a low-level action a  A. Our claims are based on quantifying how many of the possible low-level behaviors (i.e., all possible state to state transitions) can be produced by  for different choices of g. To quantify this, we make use of an auxiliary inverse goal model (s, a), which aims to predict which goal g will cause  to yield an action a~ = (s, g) that induces a next state distribution P (s |s, a~) similar to P (s |s, a).2 We have the following theorem, which bounds the sub-optimality in terms of total variation divergences between P (s |s, a) and P (s |s, a~):
Theorem 1. If there exists  : S × A  G such that,

sup DTV(P (s |s, a)||P (s |s, (s, (s, a))))  ,
sS,aA

(3)

then SubOpt()  C

, where C

=

2 (1-

)2

Rmax

.

Proof. See Appendices A and B for all proofs.
Theorem 1 allows us to bound the sub-optimality of  in terms of how recoverable the effect of any action in A is, in terms of transition to the next state. One way to ensure that effects of actions in A are recoverable is to have an invertible . That is, if there exists  : S × A  G such that (s, (s, a)) = a for all s, a, then the sub-optimality of  is 0.
2In a deterministic, c = 1 setting,  may be seen as a state-conditioned action abstraction mapping A  G.

3

Under review as a conference paper at ICLR 2019

However, in many cases it may not be desirable or feasible to have an invertible . Looking back at Theorem 1, we emphasize that its statement requires only the effect of any action to be recoverable. That is, for any s,  S, a  A, we require only that there exist some g  G (given by (s, a)) which yields a similar next-state distribution. To this end, we have the following claim, which connects the sub-optimality of  to both representation learning and the form of the low-level objective.
Claim 2. Let (s) be a prior and f,  be so that, for K(s |s, a)  (s ) exp(-D(f (s ), (s, a))),3

sup DKL(P (s |s, a)||K(s |s, a))  2/2.
sS,aA

(4)

If the low-level objective is defined as

(s, g) = arg max EP (s |s,a)[-D(f (s ), g) + log (s ) - log P (s |s, a)],
aA

(5)

then the sub-optimality of  is bounded by C .

We provide an intuitive explanation of the statement of Claim 2. First, consider that the distribution K(s |s, a) appearing in Equation 4 may be interpreted as a dynamics model determined by f and . By bounding the difference between the true dynamics P (s |s, a) and the dynamics K(s |s, a) implied by f and , Equation 4 states that the representation f should be chosen in such a way that dynamics in representation space are roughly given by (s, a). This is essentially a representation learning objective for choosing f , and in Section 5 we describe how to optimize it in practice.
Moving on to Equation 5, we note that the form of  here is only slightly different than the onestep form of the standard goal-conditioned objective in Equation 1. Therefore, all together Claim 2 establishes a deep connection between representation learning (Equation 4), goal-conditioned policy learning (Equation 5), and sub-optimality. Specifically, if the low-level RL objective is expressed as in Equation 5, then to minimize the sub-optimality we need only optimize a representation learning objective based on Equation 4.

4.2 TEMPORAL ABSTRACTION (c  1) AND GENERAL POLICIES

We now move on to presenting the same results in the fully general, temporally abstracted setting, in

which the higher-level policy chooses a high-level action g  G every c steps, which is transformed

via  to a c-step lower-level behavior policy   . In this setting, the auxiliary inverse goal model

(s, ) is a mapping from S ×  to G and aims to predict which goal g will cause  to yield a

policy ~ = (s, g) that induces future state distributions P~ (st+k|st) similar to P(st+k|st), for

k  [1, c]. We weight wk = (1 - )-1 for

the divergences between k = c. We denote w =

the distributions

c k=1

 k-1

wk

.

by weights wk The analogue

= to

1 for k < c and Theorem 1 is as

follows:

Theorem 3. Consider a mapping  : S ×   G and define k : S ×   R for k  [1, c] as,

k(st, ) = DTV(P(st+k|st)||P(st,(st,))(st+k|st)).

(6)

If

1 sup stS, w

c
k-1wk
k=1

k(st, ) 

,

then SubOpt()  C

, where C

=

2 1-

c

Rmax

w.

(7)

For the analogue to Claim 2, we simply replace the single-step KL divergences and low-level rewards with a discounted weighted sum thereof:

Claim 4. Let (s) be a prior over S. Let f,  be such that,

sup
st S, 

1 w

c k=1

 k-1 wk DKL (P (st+k |st )||K (st+k |st ,

))



2/2,

(8)

where K(st+k|st, )  (st+k) exp(-D(f (st+k), (st, ))).

3K may be interpreted as the conditional P (state = s |repr = (s, a)) of the joint distribution P (state = s )P (repr = z|state = s ) = (s ) exp(-D(f (s ), z))/Z for normalization constant Z.

4

Under review as a conference paper at ICLR 2019

If the low-level objective is defined as
c
(st, g) = arg max k-1wkEP(st+k|st)[-D(f (st+k), g)+log (st+k)-log P(st+k|st)], (9)
 k=1
then the sub-optimality of  is bounded by C .
Claim 4 is the main theoretical contribution of our work. As in the previous claim, we have a strong statement, saying that if the low-level objective is defined as in Equation 9, then minimizing the sub-optimality may be done by optimizing a representation learning objective based on Equation 8.

5 LEARNING
We now have the mathematical foundations necessary to learn representations that are provably good for use in hierarchical RL. We begin by elaborating on how we translate Equation 8 into a practical training objective for f and auxiliary  (as well as a practical parameterization of policies  as input to ). We then continue to describe how one may train a lower-level policy to match the objective presented in Equation 9. In this way, we may learn f and lower-level policy to directly optimize a bound on the sub-optimality of . A pseudocode of the full algorithm is presented in the Appendix (see Algorithm 1).

5.1 LEARNING GOOD REPRESENTATIONS

Consider a representation function f : S  Rd and an auxiliary function  : S ×   Rd, parameterized by vector . In practice, these are separate neural networks: f1 , 2 ,  = [1, 2].

While the form of Equation 8 suggests to optimize a supremum over all st and , in practice we only have access to a replay buffer which stores experience s0, a0, s1, a1, . . . sampled from our hierarchical behavior policy. Therefore, we propose to choose st sampled uniformly from the replay buffer and use the subsequent c actions at:t+c-1 as a representation of the policy , where we use at:t+c-1 to denote the sequence at, . . . , at+c-1. Note that this is equivalent to setting the set of candidate policies  to Ac (i.e.,  is the set of c-step, deterministic, open-loop policies). This choice
additionally simplifies the possible structure of the function approximator used for  (a standard neural net which takes in st and at:t+c-1). Our proposed representation learning objective is thus,

J () = Est,at:t+c-1replay[J (, st, at:t+c-1)],

(10)

where J(, st, at:t+c-1) will correspond to the inner part of the supremum in Equation 8.

We now define the inner objective J(, st, at:t+c-1). To simplify notation, we use E(s , s, ) = exp(-D(f(s ), (s, ))) and use K(s |s, ) as the distribution over S such that K(s |s, )  (s )E(s , s, ). Equation 8 suggests the following learning objective on each st,   at:t+c-1:

c
J (, st, ) = k-1wkDKL(P(st+k|st)||K(st+k|st, ))

(11)

k=1

c

=B+

-k-1wkEP(st+k|st) [log K(st+k|st, )]

k=1

(12)

c
= B + -k-1wkEP(st+k|st) [log E(st+k, st, )] + k-1wk log Es~ [E(s~, st, )] ,
k=1
where B is a constant. The gradient with respect to  is then,

(13)

c k=1

- k-1 wk EP (st+k |st )

[

log

E (st+k ,

st,

)]

+

k-1wk

Es~ [E(s~, st, )] Es~ [E(s~, st, )]

(14)

The first term of Equation 14 is straightforward to estimate using experienced st+1:t+k. We set  to be the replay buffer distribution, so that the numerator of the second term is also straightforward.

We approximate the denominator of the second term using a mini-batch S of states independently

sampled from the replay buffer:

Es~ [E(s~, st, )]  |S|-1 s~S E(s~, st, ). This completes the description of our representation learning algorithm.

(15)

5

Under review as a conference paper at ICLR 2019

Connection to Mutual Information Estimators. The form of the objective we optimize (i.e. Equation 13) is very similar to mutual information estimators, mostly CPC (van den Oord et al., 2018). Indeed, one may interpret our objective as maximizing a mutual information M I(st+k; st, ) via an energy function given by E(st+k, st, ). The main differences between our approach and these previous proposals are as follows: (1) Previous approaches maximize a mutual information M I(st+k; st) agnostic to actions or policy. (2) Previous approaches suggest to define the energy function as exp(f (st+k)T Mkf (st)) for some matrix Mk, whereas our energy function is based on the distance D used for low-level reward. (3) Our approach is provably good for use in hierarchical RL, and hence our theoretical results may justify some of the good performance observed by others using mutual information estimators for representation learning. Different approaches to translating our theoretical findings to practical implementations may yield objectives more or less similar to CPC, some of which perform better than others (see Appendix D).

5.2 LEARNING A LOWER-LEVEL POLICY
Equation 9 suggests to optimize a policy st,g(a|st+k, k) for every st, g. This is equivalent to the parameterization lo(a|st, g, st+k, k), which is standard in goal-conditioned hierarchical designs. Standard RL algorithms may be employed to maximize the low-level reward implied by Equation 9:

- D(f (st+k), g) + log (st+k) - log P(st+k|st),

(16)

weighted by wk and where  corresponds to lo when the state st and goal g are fixed. While the first term of Equation 16 is straightforward to compute, the log probabilities log (st+k), log P(st+k|st) are in general unknown. To approach this issue, we take advantage of the representation learning
objective for f, . When f,  are optimized as dictated by Equation 8, we have

log P(st+k|st)  log (st+k) - D(f (st+k), (st, )) - log Es~[E(s~, st, )]. (17)

We may therefore approximate the low-level reward as

- D(f (st+k), g) + D(f (st+k), (st, )) + log Es~[E(s~, st, )].

(18)

As in Section 5.1, we use the sampled actions at:t+c-1 to represent  as input to . We approximate the third term of Equation 18 analogously to Equation 15. Note that this is a slight difference from
standard low-level rewards, which use only the first term of Equation 18 and are unweighted.

6 RELATED WORK
Representation learning for RL has a rich and diverse existing literature, often interpreted as an abstraction of the original MDP. Previous works have interpreted the hierarchy introduced in hierarchical RL as an MDP abstraction of state, action, and temporal spaces (Sutton et al., 1999; Dietterich, 2000; Bacon et al., 2017). In goal-conditioned hierarchical designs, although the representation is learned on states, it is in fact a form of action abstraction (since goals g are high-level actions). While previous successful applications of goal-conditioned hierarchical designs have either learned representations naively end-to-end (Vezhnevets et al., 2017), or not learned them at all (Levy et al., 2017; Nachum et al., 2018), we take a principled approach to representation learning in hierarchical RL, translating a bound on sub-optimality to a practical learning objective.
Bounding sub-optimality in abstracted MDPs has a long history, from early work in theoretical analysis on approximations to dynamic programming models (Whitt, 1978; Bertsekas & Castanon, 1989). Extensive theoretical work on state abstraction, also known as state aggregation or model minimization, has been done in both operational research (Rogers et al., 1991; Van Roy, 2006) and RL (Dean & Givan, 1997; Ravindran & Barto, 2002; Abel et al., 2017). Notably, Li et al. (2006) introduce a formalism for categorizing classic work on state abstractions such as bisimulation (Dean & Givan, 1997) and homomorphism (Ravindran & Barto, 2002) based on what information is preserved, which is similar in spirit to our approach. Exact state abstractions (Li et al., 2006) incur no performance loss (Dean & Givan, 1997; Ravindran & Barto, 2002), while their approximate variants generally have bounded sub-optimality (Bertsekas & Castanon, 1989; Dean & Givan, 1997; Sorg & Singh, 2009; Abel et al., 2017). While some of the prior work also focuses on learning state abstractions (Li et al., 2006; Sorg & Singh, 2009; Abel et al., 2017), they often exclusively apply to simple MDP domains as they rely on techniques such as state partitioning or Q-value based aggregation, which are difficult to scale to our experimented domains. Thus, the key differentiation of our work

6

Under review as a conference paper at ICLR 2019

from these prior works is that we derive bounds which may be translated to practical representation learning objectives. Our impressive results on difficult continuous-control, high-dimensional domains is a testament to the potential impact of our theoretical findings.
Lastly, we note the similarity of our representation learning algorithm to recently introduced scalable mutual information maximization objectives such as CPC (van den Oord et al., 2018) and MINE (Ishmael Belghazi et al., 2018). This is not a surprise, since maximizing mutual information relates closely with maximum likelihood learning of energy-based models, and our bounds effectively correspond to bounds based on model-based predictive errors, a basic family of bounds in representation learning in MDPs (Sorg & Singh, 2009; Brunskill & Li, 2014; Abel et al., 2017). To our knowledge, no prior work has connected these mutual information estimators to representation learning in hierarchical RL, and ours is the first to formulate theoretical guarantees on sub-optimality of the resulting representations in such a framework.
7 EXPERIMENTS
We evaluate our proposed representation learning objective compared to a number of baselines:
· XY: The oracle baseline which uses the x, y position of the agent as the representation.
· VAE: A variational autoencoder (Kingma & Welling, 2013) on raw observations.
· E2C: Embed to control (Watter et al., 2015). A method which uses variational objectives to train a representation of states and actions which have locally linear dynamics.
· E2E: End-to-end learning of the representation. The representation is fed as input to the higher-level policy and learned using gradients from the RL objective.
· Whole obs: The raw observation is used as the representation. No representation learning. This is distinct from Nachum et al. (2018), in which a subset of the observation space was pre-determined for use as the goal space.
We evaluate on the following continuous-control MuJoCo (Todorov et al., 2012) tasks (see Appendix C for details):
· Ant (or Point) Maze: An ant (or point mass) must navigate a -shaped corridor.
· Ant Push: An ant must push a large block to the side to reach a point behind it.
· Ant Fall: An ant must push a large block into a chasm so that it may walk over it to the other side without falling.
· Ant Block: An ant must push a small block to various locations in a square room.
· Ant Block Maze: An ant must push a small block through a -shaped corridor.

Ant Maze Env

XY

Ours

Ours (Images)

VAE VAE (Images) E2C E2C (Images)

Figure 2: Learned representations (2D embeddings) of our method and a number of variants on a MuJoCo Ant Maze environment, with color gradient based on episode time-step (black for beginning of episode, yellow for end). The ant travels from beginning to end of a -shaped corridor along an x, y trajectory shown under XY. Without any supervision, our method is able to deduce this nearideal representation, even when the raw observation is given as a top-down image. Other approaches are unable to properly recover a good representation.
7

Under review as a conference paper at ICLR 2019

Point Maze
1.0 0.8 0.6

Ant Maze
1.0
0.8
0.6

0.4 0.4

0.2 0.2

0.0
Point Maze (Images)
1.0
0.8
0.6
0.4

0.0
Ant Maze (Images)
0.8 0.6 0.4

0.2 0.2

0.0 0.0

XY (oracle)

Ours

Ant Push
0.8
0.6
0.4
0.2
0.0
Ant Push (Images)
0.5 0.4 0.3 0.2 0.1 0.0
VAE

0.6 0.5 0.4 0.3 0.2 0.1 0.0
0.7 0.6 0.5 0.4 0.3 0.2 0.1 0.0
E2C

Ant Fall Ant Fall (Images)
E2E

Ant Block
1.0 0.8 0.6 0.4 0.2 0.0
Ant Block Maze
1.0 0.8 0.6 0.4 0.2 0.0
Whole obs

Figure 3: Results of our method and a number of variants on a suite of tasks in 10M steps of training, plotted according to median over 10 trials with 30th and 70th percentiles. We find that outside of
simple point environments, our method is the only one which can approach the performance of oracle x, y representations. These results show that our method can be successful, even when the
representation is learned online concurrently while learning a hierarchical policy.

In these tasks, the raw observation is the agent's x, y coordinates and orientation as well as local coordinates and orientations of its limbs. In the Ant Block and Ant Block Maze environments we also include the x, y coordinates and orientation of the block. We also experiment with more difficult raw representations by replacing the x, y coordinates of the agent with a low-resolution 5 × 5 × 3 top-down image of the agent and its surroundings. These experiments are labeled `Images'.
For the baseline representation learning methods which are agnostic to the RL training (VAE and E2C), we provide comparative qualitative results in Figure 2. These representations are the result of taking a trained policy, fixing it, and using its sampled experience to learn 2D representations of the raw observations. We find that our method can successfully deduce the underlying near-optimal x, y representation, even when the raw observation is given as an image.
We provide quantitative results in Figure 3. In these experiments, the representation is learned concurrently while learning a full hierarchical policy (according to the procedure in Nachum et al. (2018)). Therefore, this setting is especially difficult since the representation learning must learn good representations even when the behavior policy is very far from optimal. Accordingly, we find that most baseline methods completely fail to make any progress. Only our proposed method is able to approach the performance of the XY oracle.

Ant and block

Ant pushing small block through corridor

Representations

Figure 4: We investigate importance of various observation coordinates in learned representations on a difficult block-moving task. In this task, a simulated robotic ant must move a small red block from beginning to end of a -shaped corridor. Observations include both ant and block x, y coordinates. We show the trajectory of the learned representations on the right (cyan). At four time steps, we also plot the resulting representations after perturbing the observation's ant coordinates (green) or the observation's block coordinates (magenta). The learned representations put a greater emphasis (i.e., higher sensitivity) on the block coordinates, which makes sense for this task as the external reward is primarily determined by the position of the block.
8

Under review as a conference paper at ICLR 2019
For the `Block' environments, we were curious what our representation learning objective would learn, since the x, y coordinate of the agent is not the only near-optimal representation. For example, another suitable representation is the x, y coordinates of the small block. To investigate this, we plotted (Figure 4) the trajectory of the learned representations of a successful policy (cyan), along with the representations of the same observations with agent x, y perturbed (green) or with block x, y perturbed (magenta). We find that the learned representations greatly emphasize the block x, y coordinates over the agent x, y coordinates, although in the beginning of the episode, there is a healthy mix of the two.
8 CONCLUSION
We have presented a principled approach to representation learning in hierarchical RL. Our approach is motivated by the desire to achieve maximum possible return, hence our notion of sub-optimality is in terms of optimal state values. Although this notion of sub-optimality is intractable to optimize directly, we are able to derive a mathematical relationship between it and a specific form of representation learning. Our resulting representation learning objective is practical and achieves impressive results on a suite of high-dimensional, continuous-control tasks.
REFERENCES
David Abel, D Ellis Hershkowitz, and Michael L Littman. Near optimal behavior via approximate state abstraction. arXiv preprint arXiv:1701.04113, 2017.
Joshua Achiam, David Held, Aviv Tamar, and Pieter Abbeel. Constrained policy optimization. arXiv preprint arXiv:1705.10528, 2017.
Pierre-Luc Bacon, Jean Harb, and Doina Precup. The option-critic architecture. In AAAI, pp. 1726­ 1734, 2017.
Andrew G Barto and Sridhar Mahadevan. Recent advances in hierarchical reinforcement learning. Discrete Event Dynamic Systems, 13(4):341­379, 2003.
Dimitri P Bertsekas and David Alfred Castanon. Adaptive aggregation methods for infinite horizon dynamic programming. IEEE transactions on Automatic Control, 34(6):589­598, 1989.
Emma Brunskill and Lihong Li. Pac-inspired option discovery in lifelong reinforcement learning. In International Conference on Machine Learning, pp. 316­324, 2014.
Thomas Dean and Robert Givan. Model minimization in markov decision processes. In AAAI/IAAI, pp. 106­111, 1997.
Thomas G Dietterich. Hierarchical reinforcement learning with the maxq value function decomposition. Journal of Artificial Intelligence Research, 13:227­303, 2000.
Shixiang Gu, Ethan Holly, Timothy Lillicrap, and Sergey Levine. Deep reinforcement learning for robotic manipulation with asynchronous off-policy updates. In Robotics and Automation (ICRA), 2017 IEEE International Conference on, pp. 3389­3396. IEEE, 2017.
R Devon Hjelm, Alex Fedorov, Samuel Lavoie-Marchildon, Karan Grewal, Adam Trischler, and Yoshua Bengio. Learning deep representations by mutual information estimation and maximization. arXiv preprint arXiv:1808.06670, 2018.
Mohamed Ishmael Belghazi, Aristide Baratin, Sai Rajeswar, Sherjil Ozair, Yoshua Bengio, Aaron Courville, and R Devon Hjelm. Mine: Mutual information neural estimation. arXiv preprint arXiv:1801.04062, 2018.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.
Andrew Levy, Robert Platt, and Kate Saenko. Hierarchical actor-critic. arXiv preprint arXiv:1712.00948, 2017.
9

Under review as a conference paper at ICLR 2019
Lihong Li, Thomas J Walsh, and Michael L Littman. Towards a unified theory of state abstraction for mdps. In ISAIM, 2006.
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015.
Ofir Nachum, Shane Gu, Honglak Lee, and Sergey Levine. Data-efficient hierarchical reinforcement learning. NIPS, 2018.
Ronald Parr and Stuart J Russell. Reinforcement learning with hierarchies of machines. In Advances in neural information processing systems, pp. 1043­1049, 1998.
Balaraman Ravindran and Andrew G Barto. Model minimization in hierarchical reinforcement learning. In International Symposium on Abstraction, Reformulation, and Approximation, pp. 196­211. Springer, 2002.
David F Rogers, Robert D Plante, Richard T Wong, and James R Evans. Aggregation and disaggregation techniques and methodology in optimization. Operations Research, 39(4):553­582, 1991.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region policy optimization. In International Conference on Machine Learning, pp. 1889­1897, 2015.
Jonathan Sorg and Satinder Singh. Transfer via soft homomorphisms. In Proceedings of The 8th International Conference on Autonomous Agents and Multiagent Systems-Volume 2, pp. 741­748. International Foundation for Autonomous Agents and Multiagent Systems, 2009.
Richard S Sutton, Doina Precup, and Satinder Singh. Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1-2):181­ 211, 1999.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control. In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026­ 5033. IEEE, 2012.
Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding. arXiv preprint arXiv:1807.03748, 2018.
Benjamin Van Roy. Performance loss bounds for approximate value iteration with state aggregation. Mathematics of Operations Research, 31(2):234­244, 2006.
Alexander Sasha Vezhnevets, Simon Osindero, Tom Schaul, Nicolas Heess, Max Jaderberg, David Silver, and Koray Kavukcuoglu. Feudal networks for hierarchical reinforcement learning. arXiv preprint arXiv:1703.01161, 2017.
Manuel Watter, Jost Springenberg, Joschka Boedecker, and Martin Riedmiller. Embed to control: A locally linear latent dynamics model for control from raw images. In Advances in neural information processing systems, pp. 2746­2754, 2015.
Ward Whitt. Approximations of dynamic programs, i. Mathematics of Operations Research, 3(3): 231­243, 1978.
10

Under review as a conference paper at ICLR 2019

A PROOF OF THEOREM 3 (GENERALIZATION OF THEOREM 1)

Consider the sub-optimality with respect to a specific state s0, V  (s0) - V hier (s0). Recall that

 is the hierarchical result of a policy hi : deterministic due to the Markovian nature of

S  (), M. We may

and use

tnhoetemtahpapt inhgimtaoytrbaensafsosrummedhitotobea

high-level policy hi on G and using the mapping :

g  hi(-|s)    hi(-|s), g := (s, ).

(19)

Let hier be the corresponding hierarchical policy. We will bound the quantity V  (s0)-V hier (s0), which will bound V  (s0) - V hier (s0). We follow logic similar to Achiam et al. (2017) and begin by bounding the total variation divergence between the -discounted state visitation frequencies of

the two policies.

Denote the k-step state transition distributions using either  or hier as,

Pk(s |s) = Phi(s)(st+k = s |st = s), Phkier(s |s) = P(s,hi(s))(st+k = s |st = s),

(20) (21)

for k  [1, c]. Considering P, Phier as linear operators, we may express the state visitation frequencies d, dhier of , hier, respectively, as

d = (1 - )A(I - cPc)-1µ,

(22)

dhier = (1 - )Ahier(I - cPhcier)-1µ,

(23)

where µ is a Dirac  distribution centered at s0 and

c-1
A = I + kPk,

(24)

k=1

c-1
Ahier = I + kPhkier.

(25)

k=1

We will use dc, dhcier to denote the every-c-steps -discounted state frequencies of , hier; i.e.,

dc = (1 - c)(I - cPc)-1µ, dhcier = (1 - c)(I - cPhcier)-1µ.

(26) (27)

By the triangle inequality, we have the following bound on the total variation divergence |dhier -d|:

|dhier - d|  (1 - )|Ahier(I - cPhcier)-1µ - Ahier(I - cPc)-1µ| + (1 - )|Ahier(I - cPc)-1µ - A(I - cPc)-1µ|.
We begin by attacking the first term of Equation 28. We note that

(28)

|Ahier|



|I |

+

c-1
 k |Phkier |

=

1 - c .
1-

k=1

Thus the first term of Equation 28 is bounded by

(29)

(1 - c)|(I - cPhcier)-1µ - (I - cPc)-1µ| = (1 - c)|(I - cPhcier)-1((I - cPc) - (I - cPhcier))(I - cPc)-1µ| = c|(I - cPhcier)-1(Phcier - Pc)dc|.

(30)

By |(I

expressing (I - cPhcier)-1

|-(c1Ph-cier)c-)1-1a,s

a geometric and we thus

series bound

and the

employing the triangle whole quantity (30) by

inequality,

we

have

c(1 - c)-1|(Phcier - Pc)dc|.

(31)

We now move to attack the second term of Equation 28. We may express this term as (1 - )(1 - c)-1|(Ahier - A)dc|.

(32)

11

Under review as a conference paper at ICLR 2019

Furthermore, by the triangle inequality we have

c-1
|(Ahier - A)dc |  k|(Phkier - Pk)dc|.
k=1

(33)

Therefore, recalling wk = 1 for k < c and wk = (1 - )-1 for k = c, we may bound the total variation of the state visitation frequencies as

c
|dhier - d|  (1 - )(1 - c)-1 k-1wk|(Phkier - Pk)dc|

k=1

c
= 2(1 - )(1 - c)-1 k-1wkEsdc [DTV(Pk(s |s)||Phkier(s |s))]
k=1

c

= 2(1 - )(1 - c)-1Esdc

k-1wkDTV(Pk(s |s)||Phkier(s |s))

k=1

.

(34) (35) (36)

By condition 7 of Theorem 3 we have, |dhier - d|  2(1 - )(1 - c)-1w

(37)

We now move to considering the difference in values. We have

V  (s0) = (1 - )-1 d(s)R(s) ds,
S

Therefore, we have

V hier (s0) = (1 - )-1 dhier(s)R(s) ds.
S

|V  (s0) - V hier (s0)|  (1 - )-1Rmax|dhier - d|



2 1 - c Rmaxw

,

as desired.

(38) (39)
(40) (41)

B PROOF OF CLAIM 4 (GENERALIZATION OF CLAIM 2)

Consider a specific st, . Let K(s |st, )  (s ) exp(-D(f (s ), (st, ))). Note that the definition of (st, (st, )) may be expressed in terms of a KL:

(st,

(st,

))

=

arg min


1 w

c k=1

 k-1 wk DKL (P (st+k |st )||K (st+k |st ,

)).

(42)

Therefore we have,

1 w

c

k-1wkDKL(P(s,(s,)(st+k|st)||K(st+k|st, ))

k=1

1 w

c

k-1wkDKL(P(st+k|st)||K(st+k|st, )).

k=1

By condition 8 we have,

1 w

c

k-1wkDKL(P(st+k|st)||K(st+k|st, )) 

2/2.

k=1

Jensen's inequality on the sqrt function then implies

1 w

c

k-1wk

k=1

1 2

DKL (P (st+k |st )||K (st+k |st ,

))



/2.

(43) (44) (45)

12

Under review as a conference paper at ICLR 2019

Pinsker's inequality now yields,

1 w

c

k-1wkDTV(P(st+k|st)||K(st+k|st, )) 

/2.

k=1

(46)

Similarly Jensen's and Pinsker's inequality on the LHS of Equation 43 yields

1 w

c

k-1wkDTV(P(st,(st,))(st+k|st)||K(st+k|st, ))  /2.

k=1

(47)

The triangle inequality and Equations 46 and 47 then give us,

1 w

c

 k-1 wk DTV (P (st+k |st )||P(s,(s,)) (st+k |st ))

k=1

1 w

c

k-1wk

DTV(P(st+k|st)||K(st+k|st, )) + DTV(P(st,(st,))(st+k|st)||K(st+k|st, ))

k=1

 , (48)

as desired.

C EXPERIMENTAL DETAILS
C.1 ENVIRONMENTS
The environments for Ant Maze, Ant Push, and Ant Fall are as described in Nachum et al. (2018). During training, target (x, y) locations are selected randomly from all possible points in the environment (in Ant Fall, the target includes a z coordinate as well). Final results are evaluated on a single difficult target point, equal to that used in Nachum et al. (2018).
The Point Maze is equivalent to the Ant Maze, with size scaled down by a factor of 2 and the agent replaced with a point mass, which is controlled by actions of dimension two ­ one action determines a rotation on the pivot of the point mass and the other action determines a push or pull on the point mass in the direction of the pivot.
For the `Images' versions of these environments, we zero-out the x, y coordinates in the observation and append a low-resolution 5 × 5 × 3 top-down view of the environment. The view is centered on the agent and each pixel covers the size of a large block (size equal to width of the corridor in Ant Maze). The 3 channels correspond to (1) immovable blocks (walls, gray in the videos), (2) movable blocks (shown in red in videos), and (3) chasms where the agent may fall.

Ant (or Point) Maze

Ant Push

Ant Fall

Ant Block

Ant Block Maze

Top-Down View

Figure 5: The tasks we consider in this paper. Each task is a form of navigation. The agent must navigate itself (or a small red block in `Block' tasks) to the target location (green arrow). We also show an example top-down view image (from an episode on the Ant Maze task). The image is centered on the agent and shows walls and blocks (at times split across multiple pixels).
13

Under review as a conference paper at ICLR 2019

The Ant Block environment puts the ant in a 16 × 16 square room next to a 0.8 × 0.8 × 0.4 small movable block. The agent is rewarded based on negative L2 distance of the block to a desired target location. During training, these target locations are sampled randomly from all possible locations. Evaluation is on a target location diagonally opposite the ant.
The Ant Block Maze environment consists of the same ant and small movable block in a -shaped corridor. During training, these target locations are sampled randomly from all possible locations. Evaluation is on a target location at the end of the corridor.
C.2 TRAINING DETAILS
We follow the basic training details used in Nachum et al. (2018). Some differences are listed below:
· We input the whole observation to the lower-level policy (Nachum et al. (2018) zero-out the x, y coordinates for the lower-level policy).
· We use a Huber function for D, the distance function used to compute the low-level reward. · We use a goal dimension of size 2. We train the higher-level policy to output actions in
[-10, 10]2. · We use a Gaussian with standard deviation 5 for high-level exploration. · Additional differences in low-level training (e.g. reward weights and discounting) are im-
plemented according to Section 5.
We parameterize f with a feed-forward neural network with two hidden layers using relu activations. The hidden dimensions were 400 and 300, respectively. The network structure for  is identitical. These networks are trained with the Adam optimizer using learning rate 0.0001.

D OBJECTIVE FUNCTION EVALUATION

Point Maze
1.0 0.8 0.6 0.4 0.2 0.0
Point Maze (Images)
1.0 0.8 0.6 0.4 0.2 0.0

Ant Maze
1.0 0.8 0.6 0.4 0.2 0.0
Ant Maze (Images)
1.0 0.8 0.6 0.4 0.2 0.0

Ant Push
0.8
0.6
0.4
0.2
0.0
Ant Push (Images)
0.5 0.4 0.3 0.2 0.1 0.0

Ant Fall
0.6 0.5 0.4 0.3 0.2 0.1 0.0
Ant Fall (Images)
0.7 0.6 0.5 0.4 0.3 0.2 0.1 0.0

XY (oracle) Ours

Ours (CPC-style with dot product) Ours (CPC-style with distance)

Ant Block
1.0 0.8 0.6 0.4 0.2 0.0
Ant Block Maze
1.0 0.8 0.6 0.4 0.2 0.0

Figure 6: For our method, we utilize an objective based on Equation 8. The objective is similar to mutual information maximizing objectives (CPC; van den Oord et al. (2018)). We compare to variants of our method that are implemented more in the style of CPC. Although we find that using a dot product rather than distance function D is detrimental, a number of distance-based variants of our approach may perform similarly.

14

Under review as a conference paper at ICLR 2019

Algorithm 1 Representation learning for hierarchical RL.
Input: Replay buffer D, number of training steps N , batch size B, parameterizations f, , hi, lo

function EstLogP art(S, st, at:t+c-1)

## Equation 15

Return log 1
|S|

s~S exp(-D(f(s~), (st, at:t+c-1))).

end function

function CompLowReward(g, st, s , at:t+c-1, L) ## Equation 18 Return -D(f(s ), g) + D(f(s ), (st, at:t+c-1)) + L.
end function

function CompReprLoss(st, s , at:t+c-1, s~, L) ## Equation 14
Compute attractive term Jatt = D(f(s ), (st, at:t+c-1)). Compute repulsive term Jrep = exp(-D(f(s~), (st, at:t+c-1)) - stopgrad(L)). Return Jatt + Jrep. end function

for T = 1 to N do

Sample experience g, s, a, r, s and add to replay buffer D (Nachum et al., 2018).
Sample batch of c-step transitions {(g(i), s(t:it)+c, a(t:it)+c-1, rt(:it)+c-1)}iB=1  D. Sample indices into transition: {k(i)}Bi=1  [1, c]B. Sample batch of states S = {s~(i)}Bi=1  D. Estimate log-partitions {L(i)}Bi=1 = {EstLogP art(S, st(i), a(t:it)+c-1)}Bi=1.

// Reinforcement learning
Compute low-level rewards {r~(i)}iB=1 = {CompLowReward(g(i), s(ti), s(t+i)k(i) , a(t:it)+c-1, L(i))}Bi=1. Update lo (Nachum et al., 2018) with experience {(g(i), st(+i)k(i)-1, at(+i)k(i)-1, r~(i), st(+i)k(i) )}Bi=1. Update hi (Nachum et al., 2018) with experience {(g(i), s(t:it)+c, at(:it)+c-1, rt(:it)+c-1)}Bi=1.

// Representation learning

Compute loss J

=

1 B

B i=1

wk(i)



Ck(i) -1

ompReprLoss(k(i),

st(i),

st(+i)k(i)

,

at(:it)+c-1,

s~(i),

L(i)).

Update  based on J.
end for =0

15

