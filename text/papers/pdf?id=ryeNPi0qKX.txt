Under review as a conference paper at ICLR 2019
LANGUAGE MODELING TEACHES YOU MORE SYNTAX THAN TRANSLATION DOES
Anonymous authors Paper under double-blind review
ABSTRACT
Recent work using auxiliary prediction task classifiers to investigate the properties of LSTM representations has begun to shed light on why pretrained representations, like ELMo (Peters et al., 2018) and CoVe (McCann et al., 2017), are so beneficial for neural language understanding models. We still, though, do not yet have a clear understanding of how the choice of pretraining objective affects the type of linguistic information that models learn. With this in mind, we compare four objectives--language modeling, translation, skip-thought, and autoencoding--on their ability to induce syntactic and part-of-speech information. We make a fair comparison between the tasks by holding constant the quantity and genre of the training data, as well as the LSTM architecture. We find that representations from language models consistently perform best on our syntactic auxiliary prediction tasks, even when trained on relatively small amounts of data. These results suggest that language modeling may be the best data-rich pretraining task for transfer learning applications requiring syntactic information. We also find that the representations from randomly-initialized, frozen LSTMs perform strikingly well on our syntactic auxiliary tasks, but this effect disappears when the amount of training data for the auxiliary tasks is reduced.
1 INTRODUCTION
Representation learning with deep recurrent neural networks has revolutionized natural language processing and replaced many of the expert-designed, linguistic features used previously. Recently, researchers have begun to investigate the properties of learned representations by training auxiliary classifiers that use the hidden states of frozen, pretrained models to perform other tasks. These investigations have shown that when deep LSTMs (Hochreiter & Schmidhuber, 1997) are trained on tasks like translation, they learn substantial syntactic and semantic information about their input sentences, including part-of-speech (Shi et al., 2016; Belinkov et al., 2017a;b; Blevins et al., 2018).
These intriguing findings lead us to ask the following questions:
1. How does the training task affect how well models learn syntactic properties? Which tasks are better at inducing these properties?
2. How does the amount of data the model is trained on affect these results? When does training on more data help?
We investigate these questions by holding the data source and model architecture constant, while varying both the training task and the amount of training data. Specifically, we examine models trained on English-German (En-De) translation, language modeling, skip-thought (Kiros et al., 2015), and autoencoding, and also compare to an untrained LSTM model as a baseline. We control for the data domain by exclusively training on datasets from the 2016 Conference on Machine Translation (WMT; Bojar et al., 2016). We train models on all tasks using the parallel En-De corpus, which allows us to make fair comparisons across tasks. We also train models on a subset of the this corpus to examine the effect of training data volume on learned representations. Additionally, we augment the parallel dataset with a large monolingual corpus from WMT to examine how the performance of the unsupervised tasks (all but translation) scale with more data.
Throughout our work, we focus on the syntactic evaluation tasks of part-of-speech (POS) tagging and Combinatorial Categorical Grammar (CCG) supertagging. Supertagging is considered a build-
1

Under review as a conference paper at ICLR 2019
ing block for parsing as these tags constrain the ways in which words can compose, largely determining the parse of the sentence. CCG supertagging thus allows us to measure the degree to which models learn syntactic structure above the word. We focus our analysis on representations learned by language models and by the encoders of sequence-to-sequence models, as translation encoders have been found to learn richer representations of POS and morphological information than translation decoders (Belinkov et al., 2017a).
We find that for POS and CCG tagging, bidirectional language models (BiLMs)--created by separately training forward and backward language models, and concatenating their hidden states-- outperform models trained on all other tasks. Even BiLMs trained on relatively small amounts of data (1 million sentences) outperform translation and skip-thought models trained on larger datasets (5 million and 63 million sentences respectively).
Our inclusion of an untrained LSTM baseline allows us to study the effect of training on hidden state representations of LSTMs. We find, surprisingly, that when we use all of the available labeled tag data to train our auxiliary task classifiers, our best trained models (BiLMs) only outperform the randomly initialized, untrained LSTMs by a few percentage points. When we reduce the amount of classifier training data though, the performance of the randomly initialized LSTM model drops far below those of trained models. We hypothesize that this occurs because training the classifiers on large amounts of auxiliary task data allows them to memorize configurations of words seen in the training set and their associated tags. We test this hypothesis by training classifiers to predict the identity of neighboring words from a given hidden state, and find that randomly initialized models outperform all trained models on this task. Our findings demonstrate that our best trained models do well on the tagging tasks because they are truly learning representations that conform to our notions of POS and CCG tagging, and not simply because the classifiers we train are able to recover neighboring word identity information.
2 RELATED WORK
Evaluating Learned Representations Adi et al. (2016) introduce the idea of examining sentence vector representations by training auxiliary classifiers to take sentence encodings and predict attributes like word order. Belinkov et al. (2017a) build on this work by examining the hidden states of LSTMs trained on translation and find that they learn substantial POS and morphological information without direct supervision for these linguistic properties. Beyond translation, Blevins et al. (2018) find that deep LSTMs learn hierarchical syntax when trained on a variety of tasks--including semantic role labeling, language modeling, and dependency parsing. By controlling for model size and the quantity and genre of the training data, we build on Blevins et al. (2018) by making direct comparisons between tasks on their ability to induce syntactic information.
Transfer Learning of Representations Much of the work on sentence-level pretraining has focused on sentence-to-vector models and evaluating learned representations on how well they can be used to perform sentence-level classification tasks. A prominent early success in this area with unlabeled data is skip-thought (Kiros et al., 2015), the technique of training a sequence-to-sequence model to predict the sentence preceding and following each sentence in a running text. InferSent (Conneau et al., 2017)--the technique of pretraining encoders on natural language inference data-- yields strikingly better performance when such labeled data is available.
Work in transfer learning of representations has recently moved beyond strict sentence-to-vector mappings. Newer models that incorporate LSTMs or Transformer networks pretrained on datarich tasks, like translation and language modeling, have achieved state-of-the-art results on many tasks--including semantic role labeling, natural language inference, and coreference resolution (Peters et al., 2018; McCann et al., 2017; Howard & Ruder, 2018; Radford et al., 2018). Although comparisons have previously been made between translation and language modeling as pretraining tasks (Peters et al., 2018; Wang et al., 2018), we investigate this issue more thoroughly by controlling for the quantity and content of the training data.
Training Dataset Size The performance of neural models depends immensely on the amount of training data used. Koehn & Knowles (2017) find that when training machine translation models on corpora with fewer than 15 million words (English side), statistical machine translation approaches
2

Under review as a conference paper at ICLR 2019

Task
Translation Translation LM Forward LM Backward LM Forward Skip-Thought Skip-Thought Autoencoder Autoencoder

Layer Size
2×500D 2×500D 1×500D 1×500D 1×1000D 2×500D 2×500D 2×500D 2×500D

Attn.

1 Million

Y 13.2 (17.6 BLEU) N 25.2 (6.8 BLEU) ­ 104.8 ­ 103.2 ­ 103.8 Y 99.0 N 104.1 Y 1.0 N 1.0

5 Million
9.1 (21.4 BLEU) 13.0 (12.3 BLEU)
81.2 80.8 73.6 69.2 72.0
1.0 1.1

15 Million
­ ­ 82.3 81.1 69.2 68.7 68.1 1.0 1.2

63 Million
­ ­ 76.9 77.3 66.5 67.9 66.7 1.0 1.1

Table 1: Perplexity of trained models by number of training sentences. All but the language models are 1000D BiLSTMs (500D per direction). The 500D forward and backward language models are combined into a single bidirectional language model for analysis experiments.

outperform neural ones. Similarly, Hestness et al. (2017) study the affect of training data volume on performance for several tasks--including translation and image classification. They find that for small amounts of data, neural models perform about as well as chance. After a certain threshold, model performance improves logarithmically with the amount of training data, but this eventually plateaus. With this in mind, we also vary the amount of training data to investigate the relationship between performance and data volume for each task.
Randomly Initialized Models Conneau et al. (2018) use randomly initialized LSTMs as a baseline when studying sentence-to-vector embedding models. They find that untrained models outperform many trained models on several auxiliary tasks, including predicting word content. Similarly in vision, untrained convolutional networks have been shown to capture many low-level image statistics and can be used for image denoising (Ulyanov et al., 2017). Our method of training auxiliary classifiers on randomly initialized RNNs builds on the tradition of reservoir computing, in which randomly initialized networks or "reservoirs" are fixed and only "read-out" classifier networks are trained (Lukosevicius & Jaeger, 2009). Echo state networks--reservoir computing with recurrent models--have been used for tasks like speech recognition, language modeling, and time series prediction (Verstraeten et al., 2006; Tong et al., 2007; Sun et al., 2017).
3 METHODS
3.1 MAIN TRAINING DATA
We use the parallel English-German (En-De) dataset from the 2016 ACL Conference on Machine Translation (WMT) shared task on news translation (Bojar et al., 2016). This dataset contains 5 million ordered sentence translation pairs. We also use the 2015 English monolingual news discussion dataset from the same WMT shared task, which contains approximately 58 million ordered sentences. To examine how the volume of training data affects learned representations, we use four corpus sizes: 1, 5, 15, and 63 million sentences (translation is only trained on the smaller two sizes). We create the 1 million sentence corpora from the 5 million sentence dataset by sampling (i) sentence pairs for translation, (ii) English sentences for autoencoders, and (iii) ordered English sentence pairs for skip-thought and language models1. Similarly, we create the 15 million sentence corpora for the unsupervised tasks by sampling sentences from the entire corpus of 63 million sentences. We use word-level representations throughout and use the Moses package (Koehn et al., 2007) to tokenize and truecase our data. Finally, we limit both the English and German vocabularies to the 50k most frequent tokens in the training set.
3.2 MODEL ARCHITECTURE AND TRAINING
We train all our models using OpenNMT-py (Klein et al., 2017) and use the default options for model sizes, hyperparameters, and training procedure--except we increase the size of the LSTMs, make
1Note, in training we initialize the language model LSTM hidden states with the final state after reading the previous sentence.
3

Under review as a conference paper at ICLR 2019

Soon she was running the office RB P RP V BD V BG DT N N
(a) POS tags

Soon she

was running the office

S/S N P (S\N P )/N P N P > N P/N N >

(S\N P )/N P

NP >

S\N P

<

S>

S

(b) A CCG parse, with supertags shown immediately below the words.

Figure 1: An annotated PTB example sentence.

the encoders bidirectional, and use validation-based learning rate decay instead of a fixed schedule. Specifically, all our models (except language models) are 1000D, two-layer encoder-decoder LSTMs with bidirectional encoders (500D per direction) and 500D embeddings. We train models both with and without attention (Bahdanau et al., 2015). For language models, we train a single 1000D forward language model and a bidirectional language model--two 500D language models (one forward, one backward) trained separately, whose hidden states are concatenated. All models, including our untrained baseline models, are randomly initialized with a uniform distribution between -0.1 and 0.1, the default in OpenNMT-py.
We use the same training procedure for all our models. We evaluate on the validation set every epoch when training on the 1 and 5 million sentence datasets, and evaluate approximately every 5 million sentences when training on the larger datasets. We use SGD with an initial learning rate of 1. Whenever a model's validation loss increases relative to the previous evaluation, we halve the learning rate and stop training when the learning rate reaches 0.515. For each training task and dataset size, we select the model with the lowest validation perplexity to perform auxiliary task evaluations on. We report model performance in terms of perplexity and BLEU (Papineni et al., 2002) in Table 1. For translation we use beam search (B = 5) when decoding.
3.3 CLASSIFIER DATA AND ARCHITECTURE
POS and CCG For Part-of-Speech (POS) tagging evaluation, we use the Wall Street Journal (WSJ) portion of the Penn Treebank (PTB; Marcus et al., 1993) We follow the standard WSJ split (train 2-21; dev 22; test 23). The dataset contains approximately 50k sentences and 45 tag types.
For CCG supertagging, we use CCG Bank (Hockenmaier & Steedman, 2007), which is based on PTB WSJ. CCG supertagging provides fine-grained information about the role of each word in its larger syntactic context and is considered almost parsing, since sequences of tags map sentences to small subsets of possible parses. The entire dataset contains approximately 50k sentences and 1327 tag types. We display POS and CCG tags for an example sentence in Figure 1.
To study the impact of auxiliary task training data volume, for both datasets we create smaller classifier training sets by sampling 10% and 1% of the sentences. We truecase both datasets using the same truecase model trained on WMT and restrict the vocabularies to the 50k tokens used in pretraining our LSTM models. In addition to the untrained LSTM baseline, we also compare to the word-conditional most frequent class (WC-MFC)--the most frequently assigned tag class for each distinct word in the training set. For this baseline we restrict the vocabulary to that of our LSTM models and map all out-of-vocabulary words to a single UNK token. Note that while PTB and WMT are both drawn from news text, there is slight genre mismatch.
Word Identity For this task, the classifier takes a single LSTM hidden state as input and predicts the identity of the word at a different time step. For example, for the sentence "I love NLP" and a time step shift of -2, we would train the classifier to take the hidden state for "NLP" and predict the word "I". We use the WSJ dataset for this task. Following Conneau et al. (2018), we take all words that occur between 100 and 1000 times (about 1000 words total) as the possible targets for neighboring word prediction.
4

Under review as a conference paper at ICLR 2019
Figure 2: POS and CCG tagging accuracies for different amounts of LSTM encoder and classifier training data. We show results for the best performing layer of each model. Note, BiLMs are displayed with the attention models and forward LMs are displayed with the models without attention. Classifier Training Procedure We train multi-layer perceptron (MLP) classifiers that take an LSTM hidden state (from one time step and one layer) and output a distribution over the possible labels (tags or word identities). The MLPs we train have a single 1000D hidden layer with a ReLU activation. For classifier training, we use the same training and learning rate decay procedure used for pretraining the LSTM encoders.
4 COMPARING PRETRAINING TASKS
In this section we discuss the main POS and CCG tagging results displayed in Figure 2. Overall, POS and CCG tagging accuracies tend to increase with the amount of data the LSTM encoders are trained on, but the marginal improvement decreases as the amount of training data increases. Language Modeling and Translation For all pretraining dataset sizes, bidirectional language model (BiLM) and translation encoder representations perform best on both POS and CCG tagging. Translation encoders, however, slightly underperform BiLMs, even when both models are trained on the same amount of data. In fact, even BiLMs trained on the smallest amount of data (1 million sentences) outperform models trained on all other tasks and dataset sizes (up to 5 million sentences for translation, and 63 million sentences for skip-thought and autoencoding). Especially since BiLMs
5

Under review as a conference paper at ICLR 2019

(a) WC-MFC baselines for different amounts of PTB (b) WC-MFC baselines for different amounts of CCG

training data: 1% PTB: 81.8%; 10% PTB: 88.6%; training data: 1% CCG: 62.3%; 10% CCG: 68.3%;

100% PTB: 89.9%.

100% CCG: 71.6%.

Figure 3: POS and CCG tagging accuracies for different amounts of classifier training data in terms of percentage points over the word-conditional most frequent class (WC-MFC) baseline. We show results for the best performing layer and model for each task.

do not require aligned data to train, the superior performance of BiLM representations on these tasks suggests that BiLMs (like ELMo; Peters et al., 2018) are better than translation encoders (like CoVe; McCann et al., 2017) for transfer learning of syntactic information.
For all amounts of training data, the BiLMs significantly outperform the 1000D forward-only language models. The gap in performance between bidirectional and forward language models is greater for CCG supertagging than for POS tagging. When using all available auxiliary training data, there is a 2 and 8 percentage point performance gap in POS and CCG tagging respectively. This difference in relative performance suggests that bidirectional context information is more important for identifying syntactic structure than for identifying part of speech.
Figure 2 illustrates how the best performing BiLMs and translation models tend to be more robust to decreases in classifier data than models trained on other tasks. Also, when training on less auxiliary task data, POS tagging performance tends to drop less than CCG supertagging performance. For the best model (BiLM trained on 63 million sentences), when using 1% rather than all of the auxiliary task training data, CCG accuracy drops 9 percentage points, while POS accuracy only drops 2 points. Further examinations of the effect of classifier data volume are displayed in Figure 3.
Skip-Thought Although skip-thought encoders consistently underperform both BiLMs and translation encoders in all data regimes we examine, skip-thought models improve the most when increasing the amount of pretraining data, and are the only models whose performance does not seem to have plateaued by 63 million training sentences. Since we train our language models on ordered sentences, as we do for skip-thought, our language models can be interpreted as a regularized versions of skip-thought, in which the weights of the encoder and decoder are shared. The increased model capacity of skip-thought, compared to language models, could explain the difference in learned representation quality--especially when these models are trained on smaller amounts of data.
Random Initialization For our randomly initialized, untrained LSTM encoders, we use the default weight initialization technique in OpenNMT-py, a uniform distribution between -0.1 and 0.1; the only change we make is to set all biases to zero. We find that this baseline performs quite well when using all auxiliary data, and is only 3 and 8 percentage points behind the BiLM on POS and CCG tagging, respectively. We find that decreasing the amount of classifier data leads to a significantly greater drop in the untrained encoder performance compared to trained models. In the 1% classifier data regime, the performance of untrained encoders on both tasks drops below that of all trained models and below even the word-conditional most-frequent class baseline.
We hypothesize that the randomly initialized baseline is able to perform well on tagging tasks with large amounts of auxiliary task training data, because the classifier can learn the identity of neigh-
6

Under review as a conference paper at ICLR 2019

(a) POS tagging baseline: 89.9%

(b) CCG supertagging baseline: 71.6%

Figure 4: POS and CCG tagging accuracies in terms of percentage points over the word-conditional most frequent class baseline. We display results for the best performing models for each task.

boring words from a given time step's hidden state, and simply memorize word configurations and their associated tags from the training data. We test this hypothesis directly in Section 6 and find that untrained LSTM representations are in fact better at capturing neighboring word identity information than any trained model.
Autoencoder Models trained on autoencoding are the only ones that do not consistently improve with the amount of training data, which is unsurprising as unregularized autoencoders are prone to learning identity mappings (Vincent et al., 2008). When training on 10% and 1% of the auxiliary task data, autoencoders outperform randomly initialized encoders and match the word-conditional most frequent class baseline. When training on all the auxiliary data though, untrained encoders outperform autoencoders. These results suggest that autoencoders learn some useful structure that is useful in the low auxiliary data regime. However, the representations autoencoders learn do not capture syntactically rich features, since random encoders outperform them in the high auxiliary data regime. This conclusion is further supported by the extremely poor performance of the second layer of an autoencoder without attention on POS tagging (almost 10 percentage points below the most frequent class baseline), as seen in Figure 4a.
5 COMPARING LAYERS
Embeddings (Layer 0) We find that randomly initialized embeddings consistently perform as well as the word-conditional most frequent class baseline on POS and CCG tagging, which serves as an upper bound on performance for the embedding layer. As these embeddings are untrained, the auxiliary classifiers are learning to memorize and classify the random vectors. When using all the auxiliary classifier data, there is no significant difference in the performance of trained and untrained embeddings on the tagging tasks. Only for smaller amounts of classifier data do trained embeddings consistently outperform randomly initialized ones.
Upper Layers Belinkov et al. (2017a) find that, for translation models, the first layer consistently outperforms the second on POS tagging. We find that this pattern holds for all our models, except in BiLMs, for which the first and second layers perform equivalently. The pattern holds even for untrained models, suggesting that POS information is stored on the lower layer, not necessarily because the training task encourages this, but because of properties of the deep LSTM architecture.
We also find that for CCG supertagging, the first layer also outperforms the second layer on untrained models. For the trained models though, the second layer performs better than the first in some cases. Which layer performs best appears to be independent of absolute performance on the supertagging task. Our layer analysis results are displayed in Figure 4.
7

Under review as a conference paper at ICLR 2019
Figure 5: Performance of classifiers trained to predict the identity of the word a fixed number of timesteps away. Note, the forward LM has asymmetrical access to this information in its input.
6 WORD IDENTITY PREDICTION
Our results on word identity prediction are summarized in Figure 5 and given in more detail in Appendix A. While trained encoders outperform untrained ones on both POS and CCG tagging, we find that all trained LSTMs underperform untrained ones on word identity prediction. This finding confirms that trained encoders genuinely capture substantial syntactic features, beyond mere word identity, that the auxiliary classifiers can use. We find that for both trained and untrained models, the first layer outperforms the second layer when predicting the identity of the immediate neighbors of a word. However, the second layer tends to outperform the first at predicting the identity of more distant neighboring words. This effect is especially apparent for the randomly initialized encoders. Our finding suggests that, as is the case for convolutional neural networks, depth in recurrent neural networks has the effect of increasing the receptive field and allows the upper layers to have representations that capture a larger context. These results reflect the findings of Blevins et al. (2018) that for trained models, upper levels of LSTMs encode more abstract syntactic information, since more abstract information generally requires larger context information.
7 CONCLUSION
By controlling for the genre and quantity of the training data, we make fair comparisons between several data-rich training tasks in their ability to induce syntactic information. We find that bidirectional language models (BiLMs) do better than translation and skip-thought encoders at extracting useful features for POS tagging and CCG supertagging. Moreover, this improvement holds even when the BiLMs are trained on substantially less data than competing models. Our results suggest that for transfer learning, BiLMs like ELMo (Peters et al., 2018) capture more useful features than translation encoders--and that this holds even on genres for which data is not abundant. We also find that randomly initialized encoders extract usable features for POS and CCG tagging-- at least when the auxiliary POS and CCG classifiers are themselves trained on reasonably large amounts of data. The performance of untrained models drops sharply relative to trained ones when using smaller amounts of the classifier data. We investigate further and find that untrained models outperform trained ones on the task of neighboring word identity prediction, which confirms that trained encoders do not perform well on tagging tasks because the classifiers are simply memorizing word identity information. We also find that both trained and untrained LSTMs store more local neighboring word identity information in lower layers and more distant word identity information in upper layers, which suggests that depth in LSTMs allow them to capture larger context information.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Yossi Adi, Einat Kermany, Yonatan Belinkov, Ofer Lavi, and Yoav Goldberg. Fine-grained Analysis of Sentence Embeddings Using Auxiliary Prediction Tasks. ICLR, 2016. URL http://arxiv. org/abs/1608.04207.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural Machine Translation by Jointly Learning to Align and Translate. ICLR, 2015.
Yonatan Belinkov, Llu´is Ma`rquez, Hassan Sajjad, Nadir Durrani, Fahim Dalvi, and James Glass. Evaluating Layers of Representation in Neural Machine Translation on Part-of-Speech and Semantic Tagging Tasks. IJCNLP, 2017b. URL https://arxiv.org/abs/1801.07772.
Yonatan Belinkov, Nadir Durrani, Fahim Dalvi, Hassan Sajjad, and James R. Glass. What do Neural Machine Translation Models Learn about Morphology? ACL, 2017a. URL http://arxiv. org/abs/1704.03471.
Terra Blevins, Omer Levy, and Luke Zettlemoyer. Deep RNNs Learn Hierarchical Syntax. ACL, 2018.
Ondrej Bojar, Rajen Chatterjee, Christian Federmann, Yvette Graham, Barry Haddow, Matthias Huck, Antonio Jimeno Yepes, Philipp Koehn, Varvara Logacheva, Christof Monz, Matteo Negri, Aurelie Neveol, Mariana Neves, Martin Popel, Matt Post, Raphael Rubino, Carolina Scarton, Lucia Specia, Marco Turchi, Karin Verspoor, and Marcos Zampieri. Findings of the 2016 Conference on Machine Translation (WMT16). ACL, 2016.
Alexis Conneau, Douwe Kiela, Holger Schwenk, Loic Barrault, and Antoine Bordes. Supervised Learning of Universal Sentence Representations from Natural Language Inference Data. ACL, 2017.
Alexis Conneau, Germa`n Kruszewski, Guillaume Lample, Lo¨i Barrault, and Marco Baroni. What you can cram into a single $&!#* vector: Probing sentence embeddings for linguistic properties. ACL, 2018.
Joel Hestness, Sharan Narang, Newsha Ardalani, Gregory F. Diamos, Heewoo Jun, Hassan Kianinejad, Md. Mostofa Ali Patwary, Yang Yang, and Yanqi Zhou. Deep Learning Scaling is Predictable, Empirically. arXiv preprint 1712.00409, 2017. URL http://arxiv.org/abs/ 1712.00409.
Sepp Hochreiter and Ju¨ergen Schmidhuber. Long Short-Term Memory. Neural Computation, 9(8): 1735­1780, 1997.
Julia Hockenmaier and Mark Steedman. CCGbank: A Corpus of CCG Derivations and Dependency Structures Extracted from the Penn Treebank. Computational Linguistics, 2007. URL http: //www.aclweb.org/anthology/J07-3004.
Jeremy Howard and Sebastian Ruder. Universal Language Model Fine-tuning for Text Classification. ACL, 2018. URL http://arxiv.org/abs/1801.06146.
Ryan Kiros, Yukun Zhu, Ruslan Salakhutdinov, Richard S. Zemel, Antonio Torralba, Raquel Urtasun, and Sanja Fidler. Skip-Thought Vectors. NIPS, 2015. URL http://arxiv.org/abs/ 1506.06726.
Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart, and Alexander M. Rush. OpenNMT: Open-Source Toolkit for Neural Machine Translation. ACL, 2017. doi: 10.18653/v1/P17-4012. URL https://doi.org/10.18653/v1/P17-4012.
Philip Koehn and Rebecca Knowles. Six Challenges for Neural Machine Translation. ACL, 2017.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra Constantin, and Evan Herbst. Moses: Open Source Toolkit for Statistical Machine Translation. ACL, 2007. URL http://www.statmt.org/moses/.
9

Under review as a conference paper at ICLR 2019
Mantas Lukosevicius and Herbert Jaeger. Reservoir computing approaches to recurrent neural network training. In Computer Science Review, volume 3, pp. 127­149, 2009.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a Large Annotated Corpus of English: The Penn Treebank. Computational Linguistics, 1993. URL http://dl. acm.org/citation.cfm?id=972470.972475.
Bryan McCann, James Bradbury, Caiming Xiong, and Richard Socher. Learned in Translation: Contextualized Word Vectors. NIPS, 2017.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a Method for Automatic Evaluation of Machine Translation. ACL, 2002. URL http://www.aclweb.org/ anthology/P02-1040.pdf.
Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. Deep contextualized word representations. NAACL, 2018. URL http: //arxiv.org/abs/1802.05365.
Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving Language Understanding by Generative Pre-Training. 2018. URL http://openai-assets.s3. amazonaws.com/research-covers/language-unsupervised/language_ understanding_paper.pdf.
Xing Shi, Inkit Padhi, and Kevin Knight. Does String-Based Neural MT Learn Source Syntax? EMNLP, 2016. URL https://www.isi.edu/natural-language/mt/ emnlp16-nmt-grammar.pdf.
Xiaochuan Sun, Tao Li, Qun Li, Yue Huang, and Yingqi Li. Deep belief echo-state network and its application to time series prediction. Knowl.-Based Syst., 130:17­29, 2017.
Matthew H. Tong, Adam D. Bickett, Eric M. Christiansen, and Garrison W. Cottrell. Learning grammatical structure with echo state networks. Neural Networks, 20(3):424­432, 2007. doi: 10. 1016/j.neunet.2007.04.013. URL https://doi.org/10.1016/j.neunet.2007.04. 013.
Dmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky. Deep Image Prior. NIPS, 2017. David Verstraeten, Benjamin Schrauwen, and Dirk Stroobandt. Reservoir-based techniques for
speech recognition. In The 2006 IEEE International Joint Conference on Neural Network Proceedings, pp. 1050­1053, July 2006. doi: 10.1109/IJCNN.2006.246804. Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol. Extracting and Composing Robust Features with Denoising Autoencoders. In Machine Learning, Proceedings of the Twenty-Fifth International Conference (ICML 2008), Helsinki, Finland, June 5-9, 2008, pp. 1096­1103, 2008. Alex Wang, Amapreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman. GLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding. 2018. URL https://arxiv.org/abs/1804.07461.
10

Under review as a conference paper at ICLR 2019
A RANDOMLY INITIALIZED ENCODERS
Figure 6: Here we display results for the word identity prediction task with randomly initialized LSTM encoders with up to 4 layers. Lower layers have a more peaked shape and upper layers a more flat shape, meaning that the lower layers encode relatively more nearby neighboring word information, while upper layers encode relatively more distant neighboring word information.
11

Under review as a conference paper at ICLR 2019

B POS AND CCG EVALUATION FULL RESULTS
B.1 TRAINING CLASSIFIERS ON ALL DATA

Training task
Random Init 1 Random Init 2
Translation Translation LM (Bidir) LM (Forward) Skip-thought Skip-thought Autoencoder Autoencoder
Translation Translation LM (Bidir) LM (Forward) Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM (Forward) Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM (Forward) Skip-thought Skip-thought Autoencoder Autoencoder

Data
None None
1M 1M 1M 1M 1M 1M 1M 1M
5M 5M 5M 5M 5M 5M 5M 5M
15M 15M 15M 15M 15M 15M
63M 63M 63M 63M 63M 63M

Attention
N/A N/A
Yes No No No Yes No Yes No
Yes No No No Yes No Yes No
No No Yes No Yes No
No No Yes No Yes No

POS L2
90.5 90.3
95.6 92.5 96.4 94.3 44.3 78.1 80.8 79.8
96.0 92.9 96.6 94.6 76.4 86.1 88.1 70.7
97.0 95.3 82.3 90.1 91.9 71.6
96.9 95.3 90.6 91.6 89.4 70.2

POS L1
93.7 93.8
95.7 95.0 96.1 94.5 88.6 90.8 92.4 90.8
95.9 95.8 96.2 94.7 92.2 94.3 91.8 92.1
96.8 95.3 93.8 95.1 93.1 92.0
96.7 95.4 95.5 95.6 91.8 91.7

POS L0
90.2 90.1
90.0 90.0 90.2 90.1 89.9 89.9 89.6 89.9
90.2 90.2 90.3 90.2 90.0 90.0 89.6 89.8
90.6 90.6 90.2 90.3 90.1 89.8
90.6 90.6 90.3 90.3 89.6 89.9

CCG L2
83.5 83.3
91.4 88.2 92.5 83.5 45.3 74.5 73.6 79.2
92.2 89.6 92.6 84.0 68.4 81.2 76.5 72.7
93.1 84.9 70.4 85.8 82.6 71.0
93.1 84.9 80.9 86.8 78.4 70.5

CCG L1
85.4 85.3
91.2 90.1 92.0 83.1 81.0 84.4 83.7 84.0
91.6 91.2 92.4 83.5 86.4 88.6 82.5 83.7
92.9 84.5 87.6 89.8 84.5 83.7
93.0 84.5 90.1 90.3 83.2 83.1

CCG L0
71.6 71.5
71.5 71.3 71.6 71.5 71.1 71.1 71.2 71.1
71.5 71.5 71.6 71.5 71.1 71.2 70.8 71.0
72.0 72.0 71.6 71.5 71.4 71.2
72.0 72.0 71.6 71.6 71.2 71.3

Table 2: Here we display results for training on all of auxiliary task data. Word-conditional most frequent class baselines for this amount of training data are 89.9% for POS tagging and 71.6% for CCG supertagging. For each task, we underline the best performance for each training dataset size and bold the best overall performance.

12

Under review as a conference paper at ICLR 2019

B.2 TRAINING CLASSIFIERS ON 10% OF DATA

Training task
Random Init 1 Random Init 2
Translation Translation LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
Translation Translation LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder

Data
None None
1M 1M 1M 1M 1M 1M 1M 1M
5M 5M 5M 5M 5M 5M 5M 5M
15M 15M 15M 15M 15M 15M
63M 63M 63M 63M 63M 63M

Attention
N/A N/A
Yes No No No Yes No Yes No
Yes No No No Yes No Yes No
No No Yes No Yes No
No No Yes No Yes No

POS L2
85.0 84.9
93.4 89.9 95.5 93.2 34.3 71.3 77.9 71.2
94.1 89.2 95.7 93.3 66.8 81.2 84.9 65.6
96.1 94.1 72.8 84.6 88.3 68.5
96.1 94.3 85.0 88.0 82.8 67.2

POS L1
90.5 90.6
94.3 93.4 95.2 93.5 84.1 86.9 89.6 87.9
94.8 94.4 95.3 93.7 89.6 92.1 89.0 89.6
95.9 94.5 91.4 93.2 90.3 89.2
96.0 94.4 94.0 94.0 88.9 89.5

POS L0
88.3 88.3
89.1 89.0 89.7 89.5 88.2 88.2 87.7 88.6
89.5 89.5 89.8 89.7 88.7 88.7 87.6 88.4
90.2 90.1 89.0 89.0 88.4 88.3
90.2 90.2 89.2 89.3 87.4 88.5

CCG L2
71.8 72.7
88.4 82.9 89.4 80.8 36.7 64.9 71.5 71.8
88.9 85.4 89.6 81.4 60.8 73.4 71.8 65.8
89.7 82.1 63.2 79.8 76.6 68.6
90.0 82.3 73.9 81.6 72.7 66.1

CCG L1
77.0 77.0
87.6 86.0 88.6 80.2 74.0 78.0 77.4 78.1
88.2 87.6 88.9 80.6 81.0 83.7 76.1 77.9
89.9 81.8 82.6 85.5 78.9 78.1
90.1 81.8 86.0 86.1 77.3 77.2

CCG L0
68.3 68.3
69.5 69.5 70.1 69.9 68.3 68.1 68.3 68.8
69.8 69.9 70.2 70.1 68.7 68.7 67.9 68.3
70.6 70.6 68.9 69.1 68.7 68.6
70.7 70.6 69.4 69.3 68.4 68.5

Table 3: Here we display results for training on 10% of auxiliary task data. Word-conditional most frequent class baselines for this amount of training data are 88.6% for POS tagging and 68.3% for CCG supertagging. For each task, we underline the best performance for each training dataset size and bold the best overall performance.

13

Under review as a conference paper at ICLR 2019

B.3 TRAINING CLASSIFIERS ON 1% OF DATA

Training task
Random Init 1 Random Init 2
Translation Translation LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
Translation Translation LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder
LM (Bidir) LM Forward Skip-thought Skip-thought Autoencoder Autoencoder

Data
None None
1M 1M 1M 1M 1M 1M 1M 1M
5M 5M 5M 5M 5M 5M 5M 5M
15M 15M 15M 15M 15M 15M
63M 63M 63M 63M 63M 63M

Attn.
N/A N/A
Yes No No No Yes No Yes No
Yes No No No Yes No Yes No
No No Yes No Yes No
No No Yes No Yes No

POS L2
68.7 68.8
90.8 82.5 93.5 90.8 27.2 57.8 71.2 62.2
92.1 82.7 93.7 90.7 55.3 69.6 67.6 60.7
94.4 91.7 50.7 75.2 77.9 61.2
94.3 92.1 69.8 77.9 72.1 60.6

POS L1
74.5 74.5
91.7 89.9 93.8 91.8 73.2 77.5 81.4 78.7
92.9 91.7 94.0 92.1 83.4 86.0 79.5 81.1
94.7 93.1 85.4 88.1 82.3 80.4
94.8 93.3 90.2 89.6 80.1 80.6

POS L0
79.1 79.5
87.2 86.9 89.0 88.5 81.4 81.3 81.8 84.2
88.2 88.0 89.1 88.8 84.8 84.4 80.8 82.6
89.6 89.3 84.9 84.9 81.9 82.3
89.7 89.4 86.3 86.1 81.5 82.3

CCG L2
54.4 55.5
79.1 69.0 82.8 74.3 28.7 47.4 59.0 60.2
77.3 73.5 83.0 74.3 44.5 53.5 58.8 56.0
82.8 74.8 29.6 63.5 66.9 56.6
82.9 74.9 55.4 64.8 58.7 55.7

CCG L1
60.9 62.0
81.0 78.3 81.6 74.1 63.3 67.9 67.4 69.4
81.2 80.7 82.4 74.3 72.4 75.1 64.6 68.7
83.7 75.8 73.8 77.4 68.7 69.8
83.9 76.2 78.1 78.4 66.8 68.6

CCG L0
59.3 58.8
65.4 65.0 67.1 66.5 60.7 61.0 61.9 63.5
65.7 65.9 67.1 66.7 63.0 62.7 61.0 61.8
67.5 67.3 63.5 63.7 62.6 62.0
67.5 67.6 64.4 64.0 61.3 61.7

Table 4: Here we display results for training on 1% of auxiliary task data. Word-conditional most frequent class baselines for this amount of training data are 81.8% for POS tagging and 62.3% for CCG supertagging. For each task, we underline the best performance for each training dataset size and bold the best overall performance.

14

