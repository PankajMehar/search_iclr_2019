Under review as a conference paper at ICLR 2019
FROM HARD TO SOFT: UNDERSTANDING DEEP NETWORK NONLINEARITIES VIA VECTOR QUANTIZATION AND STATISTICAL INFERENCE
Anonymous authors Paper under double-blind review
ABSTRACT
Nonlinearity is crucial to the performance of a deep (neural) network (DN). To date there has been little progress understanding the menagerie of available nonlinearities, but recently progress has been made on understanding the ro^le played by piecewise affine and convex nonlinearities like the ReLU and absolute value activation functions and max-pooling. In particular, DN layers constructed from these operations can be interpreted as max-affine spline operators (MASOs) that have an elegant link to vector quantization (VQ) and K-means. While this is good theoretical progress, the entire MASO approach is predicated on the requirement that the nonlinearities be piecewise affine and convex, which precludes important activation functions like the sigmoid, hyperbolic tangent, and softmax. This paper extends the MASO framework to these and an infinitely large class of new nonlinearities by linking deterministic MASOs with probabilistic Gaussian Mixture Models (GMMs). We show that, under a GMM, piecewise affine, convex nonlinearities like ReLU, absolute value, and max-pooling can be interpreted as solutions to certain natural "hard" VQ inference problems, while sigmoid, hyperbolic tangent, and softmax can be interpreted as solutions to corresponding "soft" VQ inference problems. We further extend the framework by hybridizing the hard and soft VQ optimizations to create a -VQ inference that interpolates between hard, soft, and linear VQ inference. A prime example of a -VQ DN nonlinearity is the swish nonlinearity, which offers state-of-the-art performance in a range of computer vision tasks but was developed ad hoc by experimentation. Finally, we validate with experiments an important assertion of our theory, namely that DN performance can be significantly improved by enforcing orthogonality in its linear filters.
1 INTRODUCTION
Deep (neural) networks (DNs) have recently come to the fore in a wide range of machine learning tasks, from regression to classification and beyond. A DN is typically constructed by composing a large number of linear/affine transformations interspersed with up/down-sampling operations and simple scalar nonlinearities such as the ReLU, absolute value, sigmoid, hyperbolic tangent, etc. Goodfellow et al. (2016). Scalar nonlinearities are crucial to a DN's performance. Indeed, without nonlinearity, the entire network would collapse to a simple affine transformation. But to date there has been little progress understanding and unifying the menagerie of nonlinearities, with few reasons to choose one over another other than intuition or experimentation.
Recently, progress has been made on understanding the ro^le played by piecewise affine and convex nonlinearities like the ReLU, leaky ReLU, and absolute value activations and downsampling operations like max-, average-, and channel-pooling Balestriero & Baraniuk (2018b;a). In particular, these operations can be interpreted as max-affine spline operators (MASOs) Magnani & Boyd (2009); Hannah & Dunson (2013) that enable a DN to find a locally optimized piecewise affine approximation to the prediction operator given training data. A spline-based prediction is made in two steps. First, given an input signal x, we determine which region of the spline's partition of the domain (the input signal space) it falls into. Second, we apply to x the fixed (in this case affine) function that is assigned to that partition region to obtain the prediction y = f (x).
1

Under review as a conference paper at ICLR 2019
The key result of Balestriero & Baraniuk (2018b;a) is any DN layer constructed from a combination of linear and piecewise affine and convex is a MASO, and hence the entire DN is merely a composition of MASOs.
MASOs have the attractive property that their partition of the signal space (the collection of multidimensional "knots") is completely determined by their affine parameters (slopes and offsets). This provides an elegant link to vector quantization (VQ) and K-means clustering. That is, during learning, a DN implicitly constructs a hierarchical VQ of the training data that is then used for splinebased prediction.
This is good progress for DNs based on ReLU, absolute value, and max-pooling, but what about DNs based on classical, high-performing nonlinearities that are neither piecewise affine nor convex like the sigmoid, hyperbolic tangent, and softmax or fresh nonlinearities like the swish Ramachandran et al. (2017) that has been shown to outperform others on a range of tasks?
Contributions. In this paper, we address this gap in the DN theory by developing a new framework that unifies a wide range of DN nonlinearities and inspires and supports the development of new ones. The key idea is to leverage the yinyang relationship between deterministic VQ/K-means and probabilistic Gaussian Mixture Models (GMMs) Biernacki et al. (2000). Under a GMM, piecewise affine, convex nonlinearities like ReLU and absolute value can be interpreted as solutions to certain natural hard inference problems, while sigmoid and hyperbolic tangent can be interpreted as solutions to corresponding soft inference problems. We summarize our primary contributions as follows:
Contribution 1: We leverage the well-understood relationship between VQ, K-means, and GMMs to propose the Soft MASO (SMASO) model, a probabilistic GMM that extends the concept of a deterministic MASO DN layer. Under the SMASO model, hard maximum a posteriori (MAP) inference of the VQ parameters corresponds to conventional deterministic MASO DN operations that involve piecewise affine and convex functions, such as fully connected and convolution matrix multiplication; ReLU, leaky-ReLU, and absolute value activation; and max-, average-, and channelpooling. These operations assign the layer's input signal (feature map) to the VQ partition region corresponding to the closest centroid in terms of the Euclidean distance,
Contribution 2: A hard VQ inference contains no information regarding the confidence of the VQ region selection, which is related to the distance from the input signal to the region boundary. In response, we develop a method for soft MAP inference of the VQ parameters based on the probability that the layer input belongs to a given VQ region. Switching from hard to soft VQ inference recovers several classical and powerful nonlinearities and provides an avenue to derive completely new ones. We illustrate by showing that the soft versions of ReLU and max-pooling are the sigmoid gated linear unit and softmax pooling, respectively. We also find a home for the sigmoid, hyperbolic tangent, and softmax in the framework as a new kind of DN layer where the MASO output is the VQ probability.
Contribution 3: We generalize hard and soft VQ to what we call -VQ inference, where   (0, 1) is a free and learnable parameter. This parameter interpolates the VQ from linear (  0), to probabilistic SMASO ( = 0.5), to deterministic MASO (  1). We show that the -VQ version of the hard ReLU activation is the swish nonlinearity, which offers state-of-the-art performance in a range of computer vision tasks but was developed ad hoc through experimentation Ramachandran et al. (2017).
Contribution 4: Seen through the MASO lens, current DNs solve a simplistic per-unit (per-neuron), independent VQ optimization problem at each layer. In response, we extend the SMASO GMM to a factorial GMM that that supports jointly optimal VQ optimization across all units in a layer. Since the factorial aspect of the new model would make na¨ive VQ inference exponentially computationally complex, we develop a simple sufficient condition under which a we can achieve efficient, tractable, jointly optimal VQ inference. The condition is that the linear "filters" feeding into any nonlinearity should be orthogonal. We propose two simple strategies to learn approximately and truly orthogonal weights and show on three different datasets that both offer significant improvements in classification performance. Since orthogonalization can be applied to an arbitrary DN, this result and our theoretical understanding are of independent interest.
This paper is organized as follows. After reviewing the theory of MASOs and VQ for DNs in Section 2, we formulate the GMM-based extension to SMASOs in Section 3. Section 4 develops the
2

Under review as a conference paper at ICLR 2019

hybrid -VQ inference with a special case study on the swish nonlinearity. Section 5 extends the SMASO to a factorial GMM and shows the power of DN orthogonalization. We wrap up in Section 6 with directions for future research. Proofs of the various results appear in several appendices in the Supplementary Material.

2 BACKGROUND ON MAX-AFFINE SPLINES AND DEEP NETWORKS

We first briefly review max-affine spline operators (MASOs) in the context of understanding the inner workings of DNs Balestriero & Baraniuk (2018b;a). A MASO is an operator S[A, B] : RD  RK that maps an input vector of length D into an output vector of length K by leveraging K
independent max-affine splines Magnani & Boyd (2009); Hannah & Dunson (2013), each with R
regions, which are piecewise affine and convex mappings. The MASO parameters consist of the "slopes" A  RK×R×D and the "offsets/biases" B  RK×R. See Appendix A for the precise definition. Given the input z( -1)  RD( -1) (i.e., D = D( -1)) and parameters A( ), B( ), a MASO produces the output z( )  RD( ) (i.e., K = D( -1)) via

[z( )]k = S[A( ), B( )](z( -1)) = max

[A( )]k,r,., z( -1) + [B( )]k,r ,

k r=1,...,R( )

(1)

where [z( )]k denotes the kth dimension of z( ) and R( ) is the number of regions in the splines'

partition

of

the

input

space

RD(

-1)
.

An important consequence of (1) is that a MASO is completely determined by its slope and offset
parameters without needing to specify the partition of the input space (the "knots" when D = 1). Indeed, solving (1) automatically computes an optimized partition of the input space RD that is
equivalent to a vector quantization (VQ) Nasrabadi & King (1988); Gersho & Gray (2012). We
can make the VQ aspect explicit by rewriting (1) in terms of the Hard-VQ (HVQ) matrix TH( )  RD( )×R( ) . This VQ-matrix contains D( ) stacked one-hot row vectors, each with the one-hot position at index [t( )]k  {1, . . . , R} corresponding to the arg max over r = 1, . . . , R( ) of (1)

R( )
[z( )]k = [TH( )]k,r
r=1

[A( )]k,r,., z( -1) + [B( )]k,r .

(2)

We retrieve (1) from (2) by noting that [t( )]k, = arg maxr=1,...,R( ) ( [A( )]k,r,., z( -1) + [B( )]k,r).

The key background result for this paper is that the layers of very large class of DN are MASOs. Hence, such a DN is a composition of MASOs.

Theorem 1. Any DN layer comprising a linear operator (e.g., fully connected or convolution) composed with a convex and piecewise affine operator (such as a ReLU, leaky-ReLU, or absolute value activation; max/average/channel-pooling; maxout; all with or without skip connections) is a MASO Balestriero & Baraniuk (2018b;a).

Appendix A provides the parameters A( ), B( ) for the MASO corresponding to the th layer of any
DN constructed from linear plus piecewise affine and convex components. Given this connection, we will identify z( -1) above as the input (feature map) to the MASO DN layer and z( ) as the output (feature map). We also identify [z( )]k in (1) and (2) as the output of the kth unit (aka neuron) of the th layer. MASOs for higher-dimensional tensor inputs/outputs are easily developed by flattening.

3 MAX-AFFINE SPLINES MEET GAUSSIAN MIXTURE MODELS
The MASO/HVQ connection provides deep insights into how a DN clusters and organizes signals layer by layer in a hierarchical fashion Balestriero & Baraniuk (2018b;a). However, the entire approach requires that the nonlinearities be piecewise affine and convex, which precludes important activation functions like the sigmoid, hyperbolic tangent, and softmax. The goal of this paper is to extend the MASO analysis framework of Section 2 to these and an infinitely large class of other nonlinearities by linking deterministic MASOs with probabilistic Gaussian Mixture Models (GMMs).

3

Under review as a conference paper at ICLR 2019

3.1 FROM MASO TO GMM VIA K-MEANS

For now, we focus on a single unit k from layer of a MASO DN, which contains both linear and
nonlinear operators; we generalize below in Section 5. The key to the MASO mechanism lies in the VQ variables [t( )]k k, since they fully determine the output via (2). For a special choice of bias, the VQ variable computation is equivalent to the K-means algorithm Balestriero & Baraniuk
(2018b;a).

Proposition 1.

Given

-

1 2

A( ) k,r,. 2 = B( ) k,r, the MASO VQ partition corresponds to a K-

means clustering1 with centroids A( ) k,r,. computed via [t( )]k = arg min A( ) k,r,. - z( -1) 2 . r=1,...,R

For example, consider a layer using a ReLU activation function. Unit k of that layer partitions its input space using a K-means model with R( ) = 2 centroids: the origin of the input space and the unit layer parameter [A( )]k,1,·. The input is mapped to the partition region corresponding to the closest centroid in terms of the Euclidean distance, and the corresponding affine mapping for that
region is used to project the input and produce the layer output as in (2).

We now leverage the well-known relationship between K-means and Gaussian Mixture Models
(GMMs) Bishop (2006) to GMM-ize the deterministic VQ process of max-affine splines. As we will see, the constraint on the value of B( ) k,r in Proposition 1 will be relaxed thanks to the GMM's ability to work with a nonuniform prior over the regions (in contrast to K-means).

To move from a deterministic MASO model to a probabilistic GMM, we reformulate the HVQ
selection variable [t( )]k as an unobserved categorical variable [t( )]k  Cat([( )]k,·) with param-
eter [( )]k,·  R( ) and R( ) the simplex of dimension R( ). Armed with this, we define the following generative model for the layer input z( -1) as a mixture of R( ) Gaussians with mean [A( )]k,r,.  RD( -1) and identical isotropic covariance with parameter 2

R( )
z( -1) = 1
r=1

t( ) k = r

A( ) k,r,· + ,

(3)

with  N(0, I2). Note that this GMM generates an independent vector input z( -1) for every unit k = 1, . . . , D( ) in layer . For reasons that will become clear below in Section 3.3, we will refer to the GMM model (3) as the Soft MASO (SMASO) model. We develop a joint, factorial model for the entire MASO layer (and not just one unit) in Section 5.

3.2 HARD VQ INFERENCE

Given the GMM (3) and an input z( -1), we can compute a hard inference of the optimal VQ selection variable [t( )]k via the maximum a posteriori (MAP) principle

[t( )]k = arg max p(t|z( -1)).
t=1,...,R( )

(4)

The following result is proved in Appendix E.1.

Theorem 2. The hard, MAP inference of the latent selection variable [t( )]k given in (4) can be computed via the MASO HVQ (1)

[t( )]k = arg max [A( )]k,t,·, z( -1) + [B( )]k,t A( ) B( )
r=1,...,R( )

(5)

with 2 = 1 and [( )]k,t =

, texp([B(

)

]k,r

+

1 2

[A( )]k,r,·

2)

r

exp([B(

)

]k,r

+

1 2

[A( )]k,r,·

2)

=

1, . . . , R( ).

The optimal HVQ

selection matrix is given by [TH( )]k,r = 1 r = [t( )]k .

1It would be more accurate to call this R( )-means clustering in this case.

4

Under review as a conference paper at ICLR 2019

Note in Theorem 2 that the bias constraint of Proposition 1 (which can be interpreted as imposing a uniform prior [( )]k,·) is completely relaxed.
HVQ inference of the selection matrix sheds light on some of the drawbacks that affect any DN employing piecewise affine, convex activation functions. First, during gradient-based learning, the gradient will propagate back only through the activated VQ regions that correspond to the few 1-hot entries in TH( ). The parameters of other regions will not be updated; this is known as the "dying neurons phenomenon" Trottier et al. (2017); Agarap (2018). Second, the overall MASO mapping is continuous but not differentiable, which leads to unexpected gradient jumps during learning. Third, the HVQ inference contains no information regarding the confidence of the VQ region selection, which is related to the distance of the query point to the region boundary. As we will now see, this extra information can be very useful and gives rise to a range of classical and new activation functions.

3.3 SOFT VQ INFERENCE

We can overcome many of the limitations of HVQ inference in DNs by replacing the 1-hot entries of the HVQ selection matrix with the probability that the layer input belongs to a given VQ region

[TS( )]k,r = p [t( )]k = r | z( -1)

=

exp [A( )]k,r,·, z( -1) + [B( )]k,r,· r exp [A( )]k,r,·, z( -1) + [B( )]k,r

,

(6)

which follows from the simple structure of the GMM. This corresponds to a soft inference of the categorical variable [t( )]k. Note that TS( )  TH( ) as the noise variance in (3)  0. Given the SVQ selection matrix, the MASO output is still computed via (2). The SVQ matrix can be computed indirectly from an entropy-penalized MASO optimization; the following is proved in Appendix E.2.

Proposition 2. The entries of the SVQ selection matrix [TS( )]k,· from (6) solve the following entropypenalized maximization, where H(·) is the Shannon entropy2

Rk( )
[TS( )]k,· = arg max [t]r
t Rk( ) r=1

[A( )]k,r,·, z( -1) + [B( )]k,r + H(t).

(7)

3.4 SOFT VQ MASO NONLINEARITIES
Remarkably, switching from HVQ to SVQ MASO inference recovers several classical and powerful nonlinearities and provides an avenue to derive completely new ones. Given a set of MASO parameters A( ), B( ) for calculating the layer- output of a DN via (1), we can derive two distinctly different DNs: one based on the HVQ inference of (5) and one based on the SVQ inference of (6). The following results are proved in Appendix E.5.
Proposition 3. The MASO parameters A( ), B( ) that induce the ReLU activation under HVQ induce the sigmoid gated linear unit Elfwing et al. (2018) under SVQ.
Proposition 4. The MASO parameters A( ), B( ) that induce the max-pooling nonlinearity under HVQ induce softmax-pooling Boureau et al. (2010) under SVQ.

Appendix C discusses how the GMM and SVQ formulations shed new light on the impact of parameter initialization in DC learning plus how these formulations can be extended further.

3.5 ADDITIONAL NONLINEARITIES AS SOFT DN LAYERS
Changing viewpoint slightly, we can also derive classical nonlinearities like the sigmoid, tanh, and softmax Goodfellow et al. (2016) from the soft inference perspective. Consider a new soft DN layer whose unit output [z( )]k is not the piecewise affine spline of (2) but rather the probability [z( )]k = p([t( )]k = 1|z( -1)) that the input z( ) falls into each VQ region. The following propositions are proved in Appendix E.6.
2The observant reader will recognize this as the E-step of the GMM's EM learning algorithm.

5

Under review as a conference paper at ICLR 2019

VQ Type Hard VQ (HVQ) Soft VQ (SVQ) -VQ,   [0, 1]

Value for [T ( )]k

arg maxt

P(t)
Rk( )

arg maxt

P(t) + H(t)
Rk( )

arg maxt

P(t) + (1 - )H(t)
Rk( )

Examples ReLU, max-pooling SiGLU, softmax-pooling swish, -softmax-pooling

Table 1: Impact of different VQ strategies for a MASO layer with P(t)

Rk( ) r=1

[t]r

[A( )]k,r,., z( -1) + [B( )]k,r .

:=

Figure 1: For the MASO parameters A( ), B( ) for which HVQ yields the ReLU, absolute value,

and an arbitrary convex activation function, we explore how changing  in the -VQ alters the

induced activation function.

Solid

black:

HVQ

(

=

1),

Dashed

black:

SVQ

(

=

1 2

),

Red:

-VQ

(  [0.1, 0.9]). Interestingly, note how some of the -VQ are nonconvex.

Proposition 5. The MASO parameters A( ), B( ) that induce the ReLU activation under HVQ induce the sigmoid activation in the corresponding soft DN layer.3
A similar train of thought recovers the softmax nonlinearity typically used at the DN output for classification problems.
Proposition 6. The MASO parameters A( ), B( ) that induce a fully-connected-pooling layer under HVQ (with output dimension D(L) equal to the number of classes C) induce the softmax nonlinearity in the corresponding soft DN layer.

4 HYBRID HARD/SOFT INFERENCE VIA ENTROPY REGULARIZATION

Combining (5) and (6) yields a hybrid optimization for a new -VQ that recovers hard, soft, and linear VQ inference as special cases

Rk( )

[T( )]k = arg max [( )]k [t]r

t Rk( )

r=1

[A( )]k,r,., z( -1) + [B]k,r + 1 - [( )]k H(t).

The new hyper-parameter [( )]k  (0, 1). The following is proved in Appendix E.3. Theorem 3. The unique global optimum of (8) is given by

(8)

[T( )]k,r =

exp

[( )]k 1-[( )]k

[A( )]k,r, z( -1) + [B( )]k,r

R( ) j=1

exp

[( )]k 1-[( )]k

[A( )]k,j,., z( -1) + [B( )]k,j

.

(9)

The -VQ covers all of the theory developed above as special cases:



=

1 yields HVQ, 

=

1 2

yields SVQ, and 

=

0 yields a linear MASO with [T0(

)]k,r

=

1 R(

)

.

See Figure 1 for examples

of how the  parameter interacts with three example activation functions. Note also the attractive

property that (9) is differentiable with respect to [( )]k.

3The tanh activation is obtained similarly by reparametrizing A( ) and B( ); see Appendix E.6.

6

Under review as a conference paper at ICLR 2019

The -VQ supports the development of new, high-performance DN nonlinearities. For example, the
swish activation swish(u) = sig([( )]ku)u extends the sigmoid gated linear unit Elfwing et al.
(2018) with the learnable parameter [( )]k Ramachandran et al. (2017). Numerous experimental studies have shown that DNs equipped with a learned swish activation significantly outperform those with more classical activations like ReLU and sigmoid.4

Proposition 7. The MASO A( ), B( ) parameters that induce the ReLU nonlinearity under HVQ

induce

the

swish

nonlinearity

under

-VQ,

with

[(

)]k

=

.[( )]k
1-[( )]k

Table 1 summarizes some of the many nonlinearities that are within reach of the -VQ.

5 OPTIMAL JOINT VQ INFERENCE VIA ORTHOGONALIZATION

The GMM (3) models the impact of only a single layer unit on the layer- input z( -1). We can easily extend this model to a factorial model for z( -1) that enables all D( ) units at layer to
combine their syntheses:

D( ) R( )

z( -1) =

1

k=1 r=1

[t( )]k = r

[A( )]k,r,· + ,

(10)

with  N(0, I2). This new model is a mixture of R( ) Gaussians with means [A( )]k,r,·  RD( -1) and identical isotropic covariances with variance 2. The factorial aspect of the model means that the number of possible combinations of the t( ) values grow exponentially with the
number of units. Hence, inferring the latent variables t( ) quickly becomes intractable.

However, we can break this combinatorial barrier and achieve efficient, tractable VQ inference by constraining the MASO slope parameters A( ) to be orthogonal

[A( )]k,r,., [A( )]k ,r ,. = 0 k = k r, r .

(11)

Orthogonality is achieved in a fully connected layer (multiplication by the dense matrix W ( ) composed with activation or pooling) when the rows of W ( ) are orthogonal. Orthogonality is achieved in a convolution layer (multiplication by the convolution matrix C( ) composed with activation or pooling) when the rows of C( ) are either non-overlapping or properly apodized; see Appendix E.4
for the details plus the proof of the following result.

Theorem 4. If the slope parameters A( ) of a MASO are orthogonal in the sense of (11), then

the random variables [t( )]1|z( -1), . . . , [t( )]1|z( -1) of the model (10) are independent and hence

p [t( )]1, . . . , [t( )]D( ) |z( -1) =

D( ) k=1

p

[t( )]k|z( -1)

.

Per-unit orthogonality brings the benefit of "uncorrelated unit firing," which has been shown to provide many practical advantages in DNs Srivastava et al. (2014). Orthogonality also renders the joint MAP inference of the factorial model's VQs tractable. The following result is proved in Appendix E.4.
Corollary 1. When the conditions of Theorem 4 are fulfilled, the joint MAP estimate for the VQs of the factorial model (10)

tf( ) =

arg max

p t|z( -1) = [t( )]1, . . . , [t( )]D( )

t{1,...,R( )}×···×{1,...,R( )}

and thus can be computed with linear complexity in the number of units.

(12)

The advantages of orthogonal or near-orthogonal filters have been explored empirically in various settings, from GANs Brock et al. (2016) to RNNs Huang et al. (2017), typically demonstrating improved performance. Table 2 tabulates the results of a simple confirmation experiment with the largeCNN architecture described in Appendix D. We added to the standard cross-entropy loss a term
4Best performance was usually achieved with [( )]k  (0, 1) Ramachandran et al. (2017).

7

Under review as a conference paper at ICLR 2019

Setting SVHN (baseline) SVHN Ortho CIFAR10 (baseline) CIFAR10 Ortho CIFAR100 (baseline) CIFAR100 Ortho

LR = 0.001
94.3 ± 0.1 94.6 ± 0.2 80.3 ± 0.4 84.0 ± 0.3 43.6 ± 0.2 46.1 ± 0.2

LR = 0.0005
94.4 ± 0.1 95.0 ± 0.2 80.2 ± 0.2 82.3 ± 0.1 44.1 ± 0.4 46.3 ± 0.2

LR = 0.0001
93.4 ± 0.0 93.8 ± 0.1 76.2 ± 0.3 79.1 ± 0.2 37.5 ± 0.5 42.1 ± 0.3

Table 2: Classification experiment to demonstrate the utility of orthogonal DN layers. For three datasets and the same largeCNN architecture (detailed in Appendix D), we tabulate the classification accuracy (larger is better) and its standard deviation averaged over 5 runs with different Adam learning rates. In each case, orthogonal fully-connected and convolution matrices improve the classification accuracy over the baseline.

 k k =k r,r [A( )]k,r,·, [A( )]k ,r ,· 2 that penalizes non-orthogonality (recall (11)). We did not cross-validate the penalty coefficient  but instead set it equal to 1. The tabulated results show clearly that favoring orthogonal filters improves accuracy across both different datasets and different learning settings.
Since the orthogonality penalty does not guarantee true orthogonality but simply favors it, we performed one additional experiment where we reparametrized the fully-connected and convolution matrices using the Gram-Schmidt (GS) process Daniel et al. (1976) so that they were truly orthogonal. Thanks to the differentiability of all of the operations involved in the GS process, we could backpropagates the loss onto the orthogonalized filters in order to update them in learning. We also used the swish activation, which we showed to be a -VQ nonlinearity in Section 4. Since the GS process adds significant computational overhead to the learning algorithm, we conducted only one experiment on the largest dataset (CIFAR100). The exactly orthogonalized largeCNN achieved a classification accuracy of 61.2%, which is a major improvement over all of the results in the bottom (CIFAR100) cell of Table 2. This indicates that there are good reasons to try to improve the simple orthogonality-penalty-based approach.
6 FUTURE WORK
Our development of the SMASO model opens the door to several new research questions. First, we have merely scratched the surface in the exploration of new nonlinear activation functions and pooling operators based on the SVQ and -VQ. For example, the soft- or -VQ versions of leakyReLU, absolute value, and other piecewise affine and convex nonlinearities could outperform the new swish nonlinearity. Second, replacing the entropy penalty in the (7) and (8) with a different penalty will create entirely new classes of nonlinearities that inherit the rich analytical properties of MASO DNs. Third, orthogonal DN filters will enable new analysis techniques and DN probing methods, since from a signal processing point of view problems such as denoising, reconstruction, compression have been extensively studied in terms of orthogonal filters. Fourth, the Gram-Schmidt exact orthogonalization routine for orthogonal filters is quite intense for very deep and wide DNs. We plan to explore methods based on recursion and parallelism for speeding up the computations.

REFERENCES
A. F. Agarap. Deep learning using rectified linear units (ReLU). arXiv preprint arXiv:1803.08375, 2018.
R. Balestriero and R. Baraniuk. Mad max: Affine spline insights into deep learning. arXiv preprint arXiv:1805.06576, 2018a.
R. Balestriero and R. G. Baraniuk. A spline theory of deep networks. In Proc. Int. Conf. Mach. Learn., volume 80, pp. 374­383, Jul. 2018b.
C. Biernacki, G. Celeux, and G. Govaert. Assessing a mixture model for clustering with the integrated completed likelihood. IEEE Trans. Pattern Anal. Mach. Intell., 22(7):719­725, 2000.
C. M. Bishop. Pattern Recognition and Machine Learning, volume 4. Springer-Verlag New York, 2006.
8

Under review as a conference paper at ICLR 2019
Y. Boureau, J. Ponce, and Y. LeCun. A theoretical analysis of feature pooling in visual recognition. In Proc. Int. Conf. Mach. Learn., pp. 111­118, 2010.
A. Brock, T. Lim, J. M. Ritchie, and N. Weston. Neural photo editing with introspective adversarial networks. arXiv preprint arXiv:1609.07093, 2016.
J. W. Daniel, W. B. Gragg, L. Kaufman, and G. W. Stewart. Reorthogonalization and stable algorithms for updating the Gram-Schmidt QR factorization. Math. Comput., 30(136):772­795, 1976.
S. Elfwing, E. Uchibe, and K. Doya. Sigmoid-weighted linear units for neural network function approximation in reinforcement learning. Neural Netw., 2018.
A. Gersho and R. M. Gray. Vector Quantization and Signal Compression, volume 159. Springer US, 2012. X. Glorot and Y. Bengio. Understanding the difficulty of training deep feedforward neural networks. In Proc.
13th Int. Conf. AI Statist., volume 9, pp. 249­256, 2010. I. Goodfellow, Y. Bengio, and A. Courville. Deep Learning, volume 1. MIT Press, 2016. http://www.
deeplearningbook.org. L. A. Hannah and D. B. Dunson. Multivariate convex regression with adaptive partitioning. J. Mach. Learn.
Res., 14(1):3261­3294, 2013. L. Huang, X. Liu, B. Lang, A. W. Yu, Y. Wang, and B. Li. Orthogonal weight normalization: Solu-
tion to optimization over multiple dependent stiefel manifolds in deep neural networks. arXiv preprint arXiv:1709.06079, 2017. A. Magnani and S. P. Boyd. Convex piecewise-linear fitting. Optim. Eng., 10(1):1­17, 2009. N. M. Nasrabadi and R. A. King. Image coding using vector quantization: A review. IEEE Trans. Commun., 36(8):957­971, 1988. P. Ramachandran, B. Zoph, and Q. Le. Searching for activation functions. ArXiv e-prints, Oct. 2017. R. K. Srivastava, J. Masci, F. Gomez, and J. Schmidhuber. Understanding locally competitive networks. arXiv preprint arXiv:1410.1165, 2014. L. Trottier, P. Gigu, and B. Chaib-draa. Parametric exponential linear unit for deep convolutional neural networks. In 16th IEEE Int. Conf. Mach. Learn. Appl., pp. 207­214. IEEE, 2017. E. W. Weisstein. CRC Concise Encyclopedia of Mathematics. CRC press, 2002.
9

Under review as a conference paper at ICLR 2019

SUPPLEMENTARY MATERIALS

A BACKGROUND

A DN is an operator f : RD  RC that maps an input signal x  RD to an output prediction y  RC . All current DNs can be written as a composition of L intermediate mappings called layers

f(x) =

f (L) (L)



···



f (1) (1)

(x),

(13)

where  = (1), . . . , (L) is the collection of the network's parameters from each layer. The DN layer

at level

is

an

operator

f((

) )

that

takes

as

input

the

vector-valued

signal

z(

-1)(x)



D(
R

-1)

and

produces

the vector-valued output z( )(x)  RD( ) with D(L) = C. The signals z( )(x), > 1 are typically called

feature maps an the input is denoted as z(0)(x) = x. For concreteness, we will focus here on processing multi-

channel images x but adjusting the appropriate dimensionalities can be used to adapt our results. We will use

two equivalent representations for the signal and feature maps, one based on tensors and one based on flattened

vectors. In the tensor representation, z( ) contains C( ) channels of size I( ) × J( ) pixels. In the vector

representation, [z( )(x)]k represents the entry of the kth dimension of the flattened, vector version z( )(x) of z( )(x). Hence, D( ) = C( )I( )J ( ), C(L) = C, I(L) = 1, and J (L) = 1. For conciseness we will often

denote z( )(x) as z( ). When using nonlinearities and pooling which are piecewise affine and convex, the

layers and whole DN fall under the analysis of max-affine spline operators (MASOs) developed in Balestriero

& Baraniuk (2018a). In this framework, a max-affine spline operator with parameters A( )  RD( )×R×D( -1)

and

B(

)



D(
R

) ×R

is

defined

as

 maxr=1,...,R [A( )]1,r,., z( -1)

z( ) = S A( ), B( ) (z( -1)) =  

...

maxr=1,...,R [A( )]K,r,., z( -1)

+ [B( )]1,r  . 
+ [B( )]K,r

(14)

Any DN layer made of convex and piecewise affine nonlinearities or pooling can be rewritten exactly as a MASO. Hence, such operators take place of the layer mappings of Eq. 13. We first proceed by modifying Eq. 14 to highlight the internal inference problem. We first introduce the VQ-matrix T ( )  RD( )×R which will be used to make the mapping region specific, as in

( A( )[T ( )] = 
 (

Rr=1[T ( )]1,r[A( )]1,r,.)T 

(

...

 , B( )[T ( )] =  

R r=1

[T

(

) ]K,r [A(

) ]K,r,. )T

(

rR=1[T ( )]1,r[B( )]1,r,.)T 

...

, 

R r=1

[T

(

) ]K,r [B (

) ]K,r,. )T

(15)

effectively making A( )[T ( )] a matrix of shape (D( ), D( -1)) and B( )[T ( )] a vector of length D( ). Hence the VQ-matrix is used to combined the per region parameters. In a standard MASO, each row of T ( ) is a onehot vector at position corresponding to the region in which the input falls into. Due to the one-hot encoding present in T ( ) we refer to this inference as a hard-VQ.

Proposition 8. For a MASO, the VQ-matrix is denoted as TH( ) and is obtained via the internal maximization process of Eq. 14. It corresponds to the (hard-)VQ of the input. Once computed the output is a simple affine
transform of the input as

z( ) = A( )[TH( )]z( -1) + B( )[TH( )].

(16)

1with [TH( )]k,r = .{r=arg maxr=1,...,R [A( )]k,r,.,z( -1) +[B( )]k,r }

The VQ matrix TH( ) always belongs to the set of all matrices with different one-hot positions (from 1 to R) for each of the output dimensions k = 1, . . . , D( ). We denote this VQ-matrix space as TH( ) = {[a1, . . . , aD( ) ]T , ak  {e1, . . . , eR}} with er = r, dim(er) = R.

B DISCUSSIONS ON ORTHOGONAL FILTERS

The developed results on orthogonality induce orthogonality of the case of fully-connected layers. For the case on convolutional layer it implies orthogonality as well as non overlapping patches. This is not practical as it considerably reduces the spatial dimensions making very deep network unsuitable. As such we now

10

Under review as a conference paper at ICLR 2019

propose a brief approximation result. Due to the specificity of the convolution operator we are able to provide
a tractable inference coupled with an apodization scheme. To demonstrate this, we first highlight that any input
can be represented as a direct sum of its apodized patches. Then, we see that filtering apodized patches with a
filter is equivalent to convolving the input with apodized filters. We first need to introduce the patch notation. We define a patch P[z( -1)](pi, pj)  {1, . . . , I( )} × {1, . . . , J( )} as the slice of the input with indices c = 1, . . . , K( ), i = (all channels) and (i, j)  {pi, . . . , pi + IC( )} × {pi, . . . , pi + JC( )}, hence a patch starting at position (pi, pj) and of same shape as the filters.

Apodizing a signal in general corresponds to applying an apodization function (or windowing func-
tion)Weisstein (2002) h onto it via an Hadamard product. Let define the 2D apodized functions h :
(IC( ), JC( ))  R+ with (IC( ), JC( )) = {1, . . . , IC( )}×{1, . . . , JC( )} and where we remind that (IC( ), JC( )) is the spatial shape of the convolutional filters. Given a function h such that u(IC( ),JC( )) h(u) = 1 one can represent an input by summing the apodized patches as in

[z( )]k,i,j =

P[z( -1)](pi, pj )

(pi,pj ){i-IC( ),...,i}×{j-JC( ),...,j}

h.

(17)

The above highlights the ability to treat an input via its collection of patches with the condition to apply the defined apodization function. With the above, we can demonstrate how minimizing the per patch reconstruction loss leads to minimizing the overall input modeling

0  (h P[z( )](i, j) - [W ( )]t( )(i,j)) 2  h P[z( )](i, j) - [W ( )]t( )(i,j) 2,
i,j i,j

(18)

which represents the internal modeling of the factorial model applied across filters and patches. As a result, when performing the per position minimization one minimizes an upper bound which ultimately reaches the global minimum as

P[z( -1)](pi, pj ) - P[z^( -1)](pi, pj ) 2  0 = z( -1) -

P[z( -1)](pi, pj ) 2 = 0.

(pi,pj )

(19)

C INTERPRETATION: INITIALIZATION AND INPUT SPACE PARTITIONING

The GMM formulation and related inference also allows interpretation of the internal layer parameters. First we demonstrate how the region prior ( ) is affected by the layer parameters especially at initialization. Then we highlight how our result allows to generalize the input space partitioning results from Balestriero & Baraniuk (2018b;a).

Region Prior. The region prior of the GMM-MASO model [( )]k,. (recall Thm. 2) depends on the bias

and norm of the layer weight as [( )]k,.



e[B(

)

]k,r

+

1 2

[A( )]k,r,.

2
.

We can study how this region prior

looks like at initialization. At initialization, common practice uses [B( )]k,r = 0, k, r and [A( )]k,r,d 

N(0, (v( ))2). This bias initialization leads to a cluster prior probability proportional to the norm of the weights.

For example, the case of absolute value leads to E( [A( )]k,1,. 2) = E( [A( )]k,2,. 2) and thus uniform prior as E([( )]k,.) = (0.5, 0.5)T for any initialization standard deviation v( ). On the other hand, ReLU has

always [A( )]k,2,. 2 = 0 and E [A( )]k,r,. 2 = D( )(v( ))2. If one uses Xavier initialization Glorot &

Bengio (2010) then D( )(v( ))2 = 1 and we thus have as prior probability [( )]k,.  (0.62, 0.38)T . THe latter slightly favors the inactive state of the ReLU and thus sparser activations. In general, the smaller v( ) is, the more the region prior will favor inactive state of the ReLU.

Input Space Partitioning. We now generalize the ability to study the input space partitioning which was

before limited to the special case of [B( )]k,r

=

-

1 2

[A( )]k,r,.

2 (recall Prop. 1).

Studying the input space

partition is crucial as the MASO property implies that for each input region, an observation is transformed

via a simple linear transformation. However, deriving insights on that is the actual partition is cumbersome as

analytical formula are impractical and one thus has to probe the input space and record the observed VQ for

each point to estimate the input space partitioning. We are now able to derive some clear links between the

MASO partition and standard models which will allows much more efficient computation of the input space

partitions.

Corollary 2. A MASO with arbitrary parameters [A( )]k,r,., [B( )]k,r has an input space partitioning being the same as a GMM with parameters from Thm. 2.

This augments previous study of the MASO input space partitioning only related to k-mean (recall Prop. 1) which required specific bias values.

11

Under review as a conference paper at ICLR 2019

D DEEP NETWORK TOPOLOGIES AND DATASETS
We first present the topologies used in the experiments except for the notation ResNetD-W which is the standard wide ResNet based topology with depth D and width W . We thus have the following network architectures for smallCNN and largeCNN:
largeCNN
Conv2DLayer(layers[-1],96,3,pad='same') Conv2DLayer(layers[-1],96,3,pad='same') Conv2DLayer(layers[-1],96,3,pad='same',stride=2) Conv2DLayer(layers[-1],192,3,pad='same') Conv2DLayer(layers[-1],192,3,pad='same') Conv2DLayer(layers[-1],192,3,pad='same',stride=2) Conv2DLayer(layers[-1],192,3,pad='valid') Conv2DLayer(layers[-1],192,1) Conv2DLayer(layers[-1],10,1) GlobalPoolLayer(layers[-1],2)
where the Conv2DLayer(layers[-1],192,3,pad='valid') denotes a standard 2D convolution with 192 filters of spatial size (3, 3) and with valid padding (no padding).

E PROOFS

E.1 THEOREM 2 Proof. The log-probability of the model corresponds to

[t( )]k = arg max [A( )]k,r,., z( -1) + [B( )]k,r
r

= arg max [A( )]k,r,., z( -1)
r

+

[B(

)]k,r

+

1 2

[A( )]k,r,.

2- 1 2

[A( )]k,r,.

2

= arg max [A( )]k,r,., z( -1)
r

+

[B(

)]k,r

+

1 2

[A( )]k,r,.

2

- log

e[B(

)

]k,r

+

1 2

[A( )]k,r,.

2

r

-1 2

[A( )]k,r,.

2

= arg max [A( )]k,r,., z( -1)

+ log

e[B(

)

]k,r

+

1 2

[A( )]k,r,.

2

r

- log

e[B(

)

]k,r

+

1 2

[A( )]k,r,.

2

r

-1 2

[A( )]k,r,.

2

= arg max [A( )]k,r,., z( -1) + log
r

e[B(

)

]k,r

+

1 2

[A( )]k,r,.

2

er

[B(

)

]k,r

+

1 2

[A( )]k,r,.

2

= arg max log (p(x|r)p(r)) - 1 z( -1) 2 r2

= arg max p(x|r)p(r)
r

-1 2

[A( )]k,r,.

2

We also remind that arg maxr p(z( -1)|r)p(r) = arg maxr log(p(z( -1)|r)p(r)). Based on the above it is straightforward to derive Eq. 5 from the above.

12

Under review as a conference paper at ICLR 2019

E.2 ENTROPY REGULARIZED OPTIMIZATION

Proof. We are interested into the following optimization problem:

[t( )]k = arg max F (q[ , k], ) = arg max Eq[log(p(z( -1)|[t( )]k)p([t( )]k))] + H([t( )]k)

q[ ,k]

q[ ,k]

= arg max
u( ) R

[u(

)]k,r

[

-1 22

z( -1) - µr

2 + log(r)] -

[u( )]k,r log([u( )]k,r) .

rr

We now use the KKT and Lagrange multiplier to optimize the new loss function (per k) including the equality constraint

L(u) =

-1 [u]r[ 22

z( -1) - µr

2 + log(r)] -

[u]r log([u( )]r) + ( [u]r - 1)

r rr

Due to the strong duality we can directly optimize the primal and dual problems and solve jointly

all

the

partial

derivatives

to

0.

We

thus

obtain

by

denoting

Ar

:=

[

-1 22

z( -1) - µr

2 + log(r)]

L [u]p

=

Ap

- log([u]p) - 1 + , p

L =


[u]r - 1

r

we can now set the derivatives to 0 and see that this leads to [u]p = eAp-1+, p. We can now sum over p to obtain

[u]p = eAp-1+, p = [u]p = eAp-1+
pp

= 1 = eAp-1+

p

= 1 = e eAp-1

p

= 0 =  + log( eAp-1)

p

which leads to  = - log( p eAp-1). Plugging this back into the above equation we obtain

[u]p =eAp-1+ = eAp
= p eAp

eAp-1 p eAp-1

E.3 THEOREM 3
For the proof of THEOREM 3 please refer to the proof in E.2 by applying the convex combination with coefficients .

E.4 THEOREM 4

Proof. The proof to demonstrate this inference and VQ equality is essentially the same as the one of GMM-MASO with addition of the following first step:

D( )
z( -1) - [W ( )]k,r,. 2 =
k=1

D( ) R( )

D( )

z( -1) 2 - 2

[W ( )]k,[rk],. +

k=1 r=1

k=1

[W ( )]k,[rk],. 2

for

any

configuration

r



{1,

.

.

.

,

R(

)}D(

)
.

Using

the

same

results

we

can

re-write

the

independent

joint optimization as multiple independent optimization problems.

13

Under review as a conference paper at ICLR 2019

E.5 PROPOSITIONS 3 AND 4
For PROPOSITION 4 using the developed formula one can extend the following proof for maxpooling.

Proof.

[z(

)(x)]k

=

eA( )[k,2],z( -1)(x) +B( )[k,2] 1 + e A( )[k,2],z( -1)(x) +B( )[k,2]

× ( A( )[k, 2], z( -1)(x) + B( )[k, 2])

=sigmoid( A( )[k, 2], z( -1)(x) + B( )[k, 2]) ( A( )[k, 2], z( -1)(x) + B( )[k, 2])

=sigmoid( [C( )]k,., z( -1)(x) + [bC( )]k) × ( [C( )]k,., z( -1)(x) + [bC( )]k)

(20)

with 1 for the first region exponential as e A( )[k,2],z( -1)(x) +B( )[k,1] = e0 = 1 and the last line demonstrating the case where ReLU activation and convolution was the internal layer configuration for illustrative purposes.

E.6 PROPOSITIONS 5 AND 6

Proof.

p([t(

)]k

=

1|z(

-1))

=

p(z(

-1)|[t(

)]k = 1)p([t( p(z( -1))

)]k

=

1)

=

p(z(

-1)|[t(

)]k

=

p(z( -1)|[t( )]k = 1)p([t( )]k = 1) 0)p([t( )]k = 0) + p(z( -1)|[t( )]k =

1)p([t(

)]k

=

1)

= e(-

z( -1) 2

2

)

1+e(

1 2

e(- )z( -1)-[C( )]k,. 2

e(

1 2

[C( )]k,.

2+[B( )]k,1)

2

1+e(

1 2

[C( )]k,.

2+[B( )]k,1)

+ e(- )1
[C( )]k,. 2+[B( )]k,1)

z( -1)-[C( )]k,. 2

e(

1 2

[C( )]k,.

2+[B( )]k,1)

2

1+e(

1 2

[C( )]k,.

2+[B( )]k,1)

=

e(-

e(-

)e(z( -1)-[C( )]k,. 2
2

1 2

[C( )]k,.

2 + [B( )]k,1)

z( -1) 2

2 ) + e(-

z( -1)-[C( )]k,. 2

2

)e(

1 2

[C( )]k,.

2 + [B( )]k,1)

=

e( z( -1), [C( )]k,. + [B( )]k,1) 1 + e( z( -1), [C( )]k,. + [B( )]k,1)

= sigmoid([u( )]k).

While this is direct for sigmoid DNs, the use of hyperbolic tangent requires to reparametrize the current and following layer weights and biases to represent the shifting scaling as in C( ) := 2C( ) and C( +1) := 2C( +1), b(C+1) := b(C+1) - 1 with C replaced by W for fully connected operators.

14

