Under review as a conference paper at ICLR 2019

GENERATING LIQUID SIMULATIONS DEFORMATION-AWARE NEURAL NETWORKS
Anonymous authors Paper under double-blind review

WITH

ABSTRACT
We propose a novel approach for deformation-aware neural networks that learn the weighting and synthesis of dense volumetric deformation fields. Our method specifically targets the space-time representation of physical surfaces from liquid simulations. Liquids exhibit highly complex, non-linear behavior under changing simulation conditions such as different initial conditions. Our algorithm captures these complex phenomena in two stages: a first neural network computes a weighting function for a set of pre-computed deformations, while a second network directly generates a deformation field for refining the surface. Key for successful training runs in this setting is a suitable loss function that encodes the effect of the deformations, and a robust calculation of the corresponding gradients. To demonstrate the effectiveness of our approach, we showcase our method with several complex examples of flowing liquids with topology changes. Our representation makes it possible to rapidly generate the desired implicit surfaces. We have implemented a mobile application to demonstrate that real-time interactions with complex liquid effects are possible with our approach.
1 INTRODUCTION
Learning physical functions is an area of growing interest within the research community, with applications ranging from physical priors for computer vision problems (21), over robotic control (36), to fast approximations for numerical solvers (39). While the underlying model equations for many physics problems are known, finding solutions is often prohibitively expensive for phenomena on human scales. At the same time, the availability of model equations allows for the creation of reliable ground truth data for training, if enough computational resources can be allocated.
Water, and liquids in general, are ubiquitous in our world. At the same time, they represent an especially tough class of physics problems, as the constantly changing boundary conditions at the liquid-gas interface result in a complex space of surface motions and configurations. In this work we present a novel approach to capture parametrized spaces of liquid behavior that is based on space-time deformations. We represent a single 3D input surface over time as a four-dimensional signed-distance function (SDF), which we deform in both space and time with learned deformations to recover the desired physical behavior. To calculate and represent these deformations efficiently, we take a two-stage approach: First, we span the sides of the original parameter region with precomputed deformations, and infer a suitable weighting function. In a second step, we synthesize a dense deformation field for refinement. As both the parameter weighting problem and the deformation synthesis are highly non-linear problems, we demonstrate that neural networks are a particularly suitable solver to robustly find solutions.
We will demonstrate that it is possible to incorporate the non-linear effects of weighted deformations into the loss functions of neural networks. In particular, we put emphasis on incorporating the influence of deformation alignment into the loss gradients. This alignment step is necessary to ensure the correct application of multiple consecutive deformations fields. The second stage of our algorithm is a generative model for deformation fields, for which we rely on a known parametrization of the inputs. Thus, in contrast to other generative models which learn to represent unknown parametrization of data sets (32), our models are trained with a known range and dimensionality to parameter range, which serves as input.
1

Under review as a conference paper at ICLR 2019
Once trained, the models can be evaluated very efficiently to synthesize new implicit surface configurations. To demonstrate its performance, we have implemented a proof-of-concept version for mobile devices, and a demo app is available for Android devices in the Google Play store. Our approach generates liquid animations several orders of magnitude faster than a traditional simulator, and achieves effective speed up factors of more than 2000, as we will outline in Sec. 5. The central contributions of our work are:
· A novel deformation-aware neural network approach to very efficiently represent large collections of space-time surfaces with complex behavior.
· We show how to compute suitable loss gradient approximations for the sub-problems of parameter and deformation inference.
· In addition we showcase the high performance of our approach with a mobile device implementation that generates liquid simulations interactively.
2 RELATED WORK
Capturing physical behavior with learning has a long history in the field of learning. Early examples targeted minimization problems to determine physical trajectories or contact forces (4; 7), or plausible physics for interacting objects (21; 22). Since initial experiments with physically-based animation and neural networks (17), a variety of new deep learning based works have been proposed to learn physical models from videos (3; 8; 41). Others have targeted this goal in specific settings such as robotic interactions (14), sliding and colliding objects (43; 42), billiard (15), or trajectories in height fields (12). The prediction of forces to infer image-space motions has likewise been targeted (30; 31), while other researchers demonstrated that the stability of stacked objects can be determined from single images (25; 26). In addition, the unsupervised inference of physical functions poses interesting problems (37). While these methods have achieved impressive results, an important difference to our method is that we omit the projection to images. I.e., we directly work with three-dimensional data sets over time.
In the context of robotic control, physics play a particularly important role, and learning object properties from poking motions (1), or interactions with liquids (36) were targeted in previous work. Learning physical principles was also demonstrated for automated experiments with reinforcement learning (10). Recently, first works have also addressed replacing numerical solvers with trained models for more generic PDEs (13; 27). In our work we target a more narrow case: that of surfaces deforming based on physical principles. However, thanks to this narrow scope and our specialized loss functions we can generate very complex physical effects in 3D plus time.
Our method can be seen as a generative approach representing samples from a chaotic process. In this context, the learned latent-space representation of regular generative models (28; 35; 16; 32; 19) is replaced by the chosen parametrization of a numerical solver. Our model shares the goal to learn flow physics based on examples with other methods (23; 39; 9), but in contrast to these we focus on 4D volumes of physics data, instead of localized windows at single instances of time. Alternative methods have been proposed to work with 4D simulation data (34; 38), however, without being able to capture larger spaces of physical behavior. Due to its focus on deformations, our work also shares similarities with methods for optical flow inference and image correspondences (2; 11; 33; 18). A difference to these approaches is that we learn deformations and their weighting in an unsupervised manner, without explicit ground truth data. Thus, our method shares similarities with spatial transformer networks (STNs) (20), and unsupervised approaches for optical flow (29). However, instead of aligning two data sets, our method aims for representing larger, parametrized spaces of deformations.
3 LEARNING DEFORMATIONS
We first explain our formulation of the simulation parameter space, which replaces the latent space of other generative models such as autoencoders (28), GANs (32), or auto-regressive models (40). Given a Navier-Stokes boundary value problem with a liquid-gas interface, we treat the interface over time as a single space-time surface. We work with a set of these space-time surfaces, defined over a chosen region of the N-dimensional simulation parameters . We assume the parameters to
2

Under review as a conference paper at ICLR 2019

Initialization
Chosen point  Initial surface 0 Pre-comp. deformations ui

Parameter network

~
Apply weighted deformations

w
Deformation network

final
Apply deformation

Slice & Display

Figure 2: This illustration gives an overview of our algorithm. It works in two stages, a weighting and refinement stage, each of which employs a neural network to infer a weighting function and a dense deformation field, respectively.

be normalized, i.e.   [0, 1]N . In practice,  could contain any set of parameters of the simulation,
e.g. initial positions, or even physical parameters such as viscosity. We choose implicit functions ()  R4  R to represent specific instances, such that () = x  R4; (, x) = 0 is the space of surfaces parametrized by  that our generative model should capture. In the following,  and  will denote four-dimensional signed distance functions. We will typically abbreviate () with  to indicate that  represents a set of constant reference surfaces. While we will later on discretize all functions and operators on regular Cartesian grids, we will first show the continuous
formulation in the following.

Deforming Implicit Surfaces Representing the whole set  is very challenging. Due to bifurcations and discretization artifacts  represents a process that exhibits noisy and chaotic behavior, an example for which can
be found in Fig. 1. Despite the complex changes in the
data, our goal is to find a manageable and reduced representation. Thus, we generate an approximation of  by deforming a single initial surface in space and time. We apply space-time deformations u : R4  R4 to the initial surface 0(x). As a single deformation is limited in terms of its representative power to produce different shapes, we make use of N sequential, pre-computed deformations, thus ui with i  [1 · · · N ], each of which is scaled by a scalar weight parameter i, whose values are normally between 0 and 1. This gives us the freedom to
choose how much of ui to apply. The initial surface deformed by, e.g., u1 is given by 0(x - 1u1).

a) b) c)
Figure 1: Three liquid surfaces after 60 time steps differing only by ± in initial conditions. Even this initially very small difference can lead to large differences in surface position, e.g., the sheet in b) strongly curving downward.

The sequence of deformed surfaces by sequentially applying all pre-computed ui is given by i(x, ) = i-1(x - iui). It is crucial to align such sequences of Eulerian deformations with

each other. Here we employ the alignment from previous work (38), which we briefly summarize

in the following, as it influences the gradient calculation below. Each deformation i relies on a cer-

tain spatial configuration for the input surface from deformation i - 1. Thus, when applying ui-1

with a weight i-1 < 1, we have to align ui correspondingly. Given the combined deformation

vsum(x, ) =

N i=1

iui(x),

with

intermediate

deformation

fields

ui-1(x)

=

ui-1(x

-

ui(x)),

we compute an inversely weighted offset field as vinv(x, ) = -

N i=1

(1

-

i)ui(x).

This

offset field is used to align the accumulated deformations to compute the final deformation as

vfin(x + vinv(x, ), ) = vsum(x, ). vfin now represents all weighted deformations iui merged

into a single vector field. Intuitively, this process moves all deformation vectors to the right location

for the initial surface 0, such that they can be weighted and accumulated.

To achieve the goal of representing the full set of target implicit surfaces  our goal is to compute two functions: the first one aims for an optimal weighting for each of the deformations in the sequence, i.e. , while the second function computes a final refinement deformation w after the
weighted sequence has been applied. We will employ two neural networks to approximate the two functions, which we will denote as fp, and fd below. Both functions depend only on the simulation parameters space , i.e., fp() = , and fd() = w.

Splitting the problem into fp and fd is important, as each of the pre-computed deformations weighted by fp only covers a single trajectory in the space of deformed surfaces. In the follow-
ing, we employ an optical flow solve from previous work to pre-compute deformations between the

3

Under review as a conference paper at ICLR 2019

inputs (38), which deform the input for the extrema of each original parameter dimension i. E.g., for a two-dimensional parameter space this yields two deformations along the sides of the unit cube. This first step robustly covers rough, large scale deformations. As a second step, we employ fd, which is realized as a generative CNN, to infer a deformation for refining the solution. Below we
will explain the resulting equations for training. The full equations for applying the deformations,
and a full derivation of our loss functions can be found in the supplemental materials. To shorten the notation, we introduce the helper function D(xi, ), which yields a deformed set of coordinates in R4 depending on  that incorporates the deformation sequence weighted by fp(), and a refinement deformation from fd().

We express the overall goal in terms of minimizing the L2 distance between the deformed and the target implicit surfaces for all possible values in the parameter space , using  and w as degrees

of freedom:

argmin L, L =
,w

0(D(xi, )) - 

2 2

d .

(1)

Our work addresses the problem of how to compute weighting of the deformations and on synthe-
sizing the refinement field. The main difficulty lies in the non-linearity of the deformations, which is why we propose a novel method to robustly approximate both functions with NNs: fp will be represented by the parameter network to compute , and we make use of a deformation network that to generate w. We employ relatively simple neural networks for both functions. Key for training
them is encoding the effect of deformations in the loss functions to make the training process aware
of their influence. Hence, we will focus on describing the loss functions for both networks and the
corresponding discretized gradients in the following.

Learning Deformation Weights For training the NNs we propose the following objective func-

tion, which measures the similarity of a known reference surface  and the corresponding, ap-
proximated result 0(x, ) for a parameter value . We introduce the numerical equivalent of the continuous L2 loss from Eq. (1) as

L

=

1 2

(0(D(xi, )) - (xi))2 xi ,

i

(2)

which approximates the spatial integral via the sum over all sample points i with corresponding evaluation positions xi  R4, where xi = xi - xi-1 is constant in our case. This corresponds to a regular grid structure, where the loss is accumulated per cell. The central challenge here is

to compute reliable gradients for D, which encapsulates a series of highly non-linear deformation

steps. We first focus on inferring , with w = 0.

The gradient of Eq. (2) with respect to one component of the deformation parameters j is then given by

d dj

L

=

i

-

 j

vfin(xi

+ vinv(xi, ), ) ·

0(xi

- vfin(xi, ))

(0(xi, ) - (xi)) ,

(3)

where the first term on the sum over i in parentheses represents the gradient of the deformed initial

surface. Here we compute the derivative of the full deformation as

 j

vfin(xi

+

vinv(xi,

),

)

=

ui(xi). The offset by vinv on the left hand side indicates that we perform a forward-advection step

for this term. Details of this step, and for the full derivation of the gradient are given in Appendix B.1.

A trained NN with this loss functions yields an instance of fp, with which we can infer adjusted

deformation weights fp() = .

Learning to Generate Deformations Based on , we apply the deformation sequence ui. The goal of our second network, the deformation network fd, is to compute the refinement deformation w. In contrast to the pre-computed ui, fd() = w now directly depends on , and can thus capture the interior of the parameter space. Given the initial surface 0 deformed by the set of iui, which we will denote as ~ below, the refinement deformation is applied with a final deformation step as (x) = ~ (x - w(x, )).
In order to compute the gradient of the deformation loss, we introduce the indicator function j(x) for a single deformation vector wj of w. We found it useful to use a fine discretization for the

4

Under review as a conference paper at ICLR 2019

Initial surface 0

+ Parameter network

Reference surface 

Figure 3: An example of our parameter learning approach. F.l.t.r.: the initial undeformed surface, the surface deformed by the weighting from the trained parameter network, and the reference surface only. The reference surface is shown again in the middle in light brown for comparison. The weighted deformations especially match the left liquid arm well, while there are not enough degrees of freedom in the pre-computed deformations to independently raise the surface on the right side.

implicit surfaces, such as , and lower resolutions for w. Hence, each discrete entry wj can act on multiple cells of , which we enumerate with the help of j. Now the derivative of Eq. (1) for a fixed Awfteitrhparreasmpeetecrtnteotwaorskingle deformati+onDevfoercmtaotironwnjetwoofrwk wis given by Reference surface 

d L=- dwj

i

j(xi) ~(xi - w(xi, ))

~(xi, ) - (xi) .

(4)

The full derivation of this gradient is given in Appendix B.2. Our approach for deformation learning can be regarded as an extension of STNs (20) for dense, weighted fields, and semi-Lagrangian

advection methods. The parameter network corresponds to an STN which learns to combine and weight known deformation fields. The deformation network, on the other hand, resembles the thin

plate spline STNs, where a network generates an offset for each cell center, which is then used to sample a deformed image or grid. Note that in our case, this sampling process corresponds to the semi-Lagrangian advection of a fluid simulation.

Training Details For fp we use a simple structure with two fully connected layers, while fd likewise contains two fully connected layers, followed by two or more four-dimensonal de-convolution
layers. All layers use ReLU activation functions. Details can be found in App. B, Fig. 12.

In practice, we also found that a small amount of weight decay and L2 regularization of the generated deformations can help to ensure smoothness. Thus, the loss function of the deformation network, with regularization parameters 1 and 2 is

Lt = L + 1||||2 + 2||w||2 ,

(5)

where  denotes the network weights. In addition, regular SDFs can lead to overly large loss values far away from the surface due to linearly increasing distances. Thus, we apply the tanh() function

to the SDF values, in order to put more emphasis on the surface region.

Special care is required for boundary conditions, i.e, the sides of our domain. Assuming constant values outside of the discretized domain, i.e. (x)/n = 0 for all x at the domain sides leads to vanishing gradients (x) = 0 in App. B, Eq. (22). We found this causes artificial minima and
maxima in the loss function impeding the training process. Hence, we extrapolate the SDF values with (x)/n = ±1 in order to retrieve non zero gradients at the domain sides.

To train both networks we use stochastic gradient descent with an ADAM optimizer and a learning rate of 10-3. Training is performed separately for both networks, with typically 1000 steps for fd, and another ca. 9000 steps for fd. Full parameters can be found in App. B, Table 2. As training data we generate sets of implicit surfaces from liquid simulations with the FLIP method (6). For our 2D
inputs, we use single time steps, while our 4D data concatenates 3D surfaces over time to assemble
a space-time surface. Working in conjunction, our two networks capture highly complex behavior of the fluid space-time surface  over the whole parameter domain. We will evaluate the influence of the networks in isolation and combination in the following.

4 EVALUATION
In order to evaluate our method, we first use a two-dimensional parameter space with two dimensional implicit surfaces from a liquid simulation. An overview of the space of 2156 training samples

5

Under review as a conference paper at ICLR 2019

Initial

+Parameters +Deformation

Liquid 2D

0.0876

0.0521

0.0234

Flat

0.0403

-

0.0121

Drop

0.0431

0.024

0.0096

Stairs

0.0953

0.0537

0.0299

Loss (numeric)

Initial 0.1 0.075 0.05 0.025
0 Liquid 2D

+ Parameters

+ Deformation

Flat Drop
Loss (absolute)

Stairs

Initial 1 0.75 0.5 0.25 0
Liquid 2D

+ Parameters

+ Deformation

Flat Drop
Loss (normalized)

Stairs

Figure 4: Averaged loss measurements for a test data set of the different data sets discussed in the text. Left: nInuitmialesruircfavcealu0es, again as a grap+hP(acreanmteeterr),neatnwdorka graph of the loss vRaelfuereesncneosrumrfaacleized w.r.t. initial surface loss on the right. Our method achieves very significant and consistent reductions across the very different data sets.

After parameter network

+ Deformation network w

Reference surface 

Figure 5: An example of our deformation learning approach. F. l. t. r.: the result after applying weighted deformations, and with an additional deformation from a trained deformation network. Both show the reference surface in light brown in the background, which is shown again for comparison on the right. The inferred deformation manages to reconstruct large parts of the two central arms which can not be recovered by any weighting of the pre-computed deformations (left).

of size 1002 can be found in the supplemental materials. For our training and synthesis runs, we typically downsample the SDF data, and use a correspondingly smaller resolution for the output of the deformation network, see Appendix C.2, Table 2. The effect of our trained networks in terms of loss reductions is shown on the left side of Fig. 4 under Liquid 2D. As baseline we show the loss for the undeformed surface w.r.t. the test data samples. For this 2D data set, employing the trained parameter network reduces the loss to 59.4% of the initial value. Fig. 3 shows the surface of an exemplary result. Although our result does not exactly match the target due to the constraints of the pre-computed deformations, the learned deformation weights lead to a clear improvement in terms of approximating the target.
The inferred deformation of our deformation network further reduces the surface loss to 26.6% of its initial value, as shown in Fig. 4. This is equivalent to a reduction to 44.8% compared the result after applying the weighted deformations. An example surface can be found in Fig. 5. This figure compares the surface after applying weighted and inferred deformations, i.e. our full method (right), with a surface deformed by only by deformations weighted by the parameter network (left). The NN deformation manages to reconstruct the two arm in the center of the surface, which the pre-computed deformations fail to capture. It is also apparent that despite the improvement, this surface does not reach the tip of the arms. This is caused by regularization over the varying set of target surfaces, leading to an averaged solution for the deformation. Additional examples for this two dimensional setup can be found in the supplemental video.
4D Surface Data Next we consider complete space-time data sets in four dimensions. with a three dimensional parameter space . The three parameter dimensions are x- and y-coordinates of the initial drop position, as well as its size. We use a total of 1764 reference SDFs with an initial resolution of 1004, which are down-sampled to a resolution of 404. To illustrate the capabilities of the deformation network, we start with a completely flat initial surface as 0, and train the deformation network to recover the targets. As no pre-computed deformations are used for this case, we do not train a parameter network. The flat initial 1surface represents an especially tough case, as the network can not rely on any small scale details in the reference to match with the features of the targets. Despite this difficulty, the surface loss is reduced to 30% of the initial loss purely based on
6

Under review as a conference paper at ICLR 2019
Figure 6: Eight examples of the learned deformations for a flat initial surface. For each pair the reference surfaces are depicted in yellow and the deformed results in blue. The trained model learns to recover a significant portion of the large-scale surface motion over the whole parameters space.
a) b) c)
Figure 7: Each pair shows the reference surface in transparent brown, and in purple on the left the deformed surface after applying the precomputed deformations. These surfaces often significantly deviate from the brown target, i.e. the visible purple regions indicates misalignments. In cyan on the right, our final surfaces based on the inferred deformation field. These deformed surface match the target surface closely, and even recover thin features such as the central peak in (c).
the deformation network. A set of visual examples can be seen in Fig. 6.droDp_ruese070t0o00_t0h25e00r0e_0d66u66c6:ed resolution of the inferred deformation w.r.t. the SDF surface, not all small scfraamlees 2f,1e0a,25tures of the targets are matched. However, the NN manages to reconstruct impact location and size very well across the full parameter space. Additional 2D and 4D results can be found in the supplemental materials. Once we introduce a regular initial surface for 0, in this case the zero parameter configuration with the drop in one corner of the domain with the largest size, our networks perform even better than for the 2D data discussed above. The weighted deformations lead to a loss reduction to 55.6% of the initial value, and the learned deformation reduce the loss further to 22.2% of the baseline loss (Fig. 4). An example is shown in Fig. 7. In contrast to the flat surface test, the network deformation can now shift and warp parts of 0, such as the rim of the splash of Fig. 7 to match the targets.
5 ADDITIONAL RESULTS WITH IMPLICIT SURFACES IN 4D
Our method yields highly reduced representations which can be used to very efficiently synthesize simulation results. To demonstrate the representational capabilities and the performance of our method, we have integrated the evaluation pipeline for our trained networks into an Android application. As our method yields an implicit surface as 4D array, visualizing the resulting animation is very efficient. We render slices of 3D data as implicit surfaces, and the availability of a full 3D representations makes it possible to add curvature-based shading and secondary particle effects on the fly. In this context, please also consider the supplemental materials, which contain these sequences in motion. They are available at: http://goo.gl/aRXgHm.
Performance One of the setup available in this app is the liquid drop setup with 3D parameter space described above. With this setup a user can release drops of liquid at varying positions and of varying size. An example reference and generated result can be found in Fig. 8. For this liquid drop setup, evaluating the network takes 69ms on average, and assembling the final deformation field another 21.5ms. We use double buffering, and hence both tasks are evaluated in a background thread. Rendering the implicit surface takes an average of 21ms, with an average frame rate of 50 fps. The original simulation for the drop setup of Fig. 8 took 530 seconds on average with a parallel implementation to generate a single 4D surface data point.Assuming a best-case slowdown of only 4x for the mobile device, it would require more than 32 minutes to run the original simulation there.
7

Under review as a conference paper at ICLR 2019
a) b)
Figure 8: a) Liquid drop data set example: several 3D surfaces of a single simulation data point in . b) An example splash generated by our method, visualized interactively.
a) b)
Figure 9: a) Three example configurations from our stairs data set. b) The interactive version of the stair setup shown in the demo app. Notice how the flow around the central wall obstacle changes. As the wall is shifted right, the flow increases corresonpondingly.
Our app generates and renders a full liquid animation in less than one second in total. Thus, our algorithm generates the result roughly 2000 times faster than the regular simulation. Our approach also represents the space of more than 1700 input simulations, i.e., more than 17GB, with less than 30MB of storage.
Stairs A next setup, shown in Fig. 9, captures a continuous flow around a set of obstacles. Liquid is generated in one corner of the simulation domain, and then flows in a U-shaped path around a wall, down several steps. In the interactive visualization, green arrows highlight in- and outflow regions. The three dimensional parametrization of this setup captures a range of positions for the wall and two steps leading to very different flow behaviors for the liquid. In this case the data set consists of 1331 SDFs, and our app uses an output resolution of 504. The corresponding loss measurements can be found in the right graphs of Fig. 4. As with the two previously discussed data sets, our approach leads to very significant reductions of the surface loss across the full parameter space, with a final residual loss of 31.3% after applying the learned deformation. Due to larger size of the implicit surfaces and the inferred deformation field, the performance reduces to a frame rate of 30 fps on average, which, however, still allows for responsive user interactions.
Discussion Our approach in its current form has several limitations that are worth mentioning. E.g., we assume that the space of target surfaces have a certain degree of similarity, such that a single surface can be selected as initial surface 0. In addition, our method currently does not make use of the fact that the inputs are generated by a physical process. E.g., it would be highly interesting for future work to incorporate additional constraints such as conservation laws.
6 CONCLUSIONS
We have presented a novel method to generate space-time surfaces with deformation-aware neural networks. In particular, we have demonstrated the successful inference of weighting sequences of aligned deformations, and the generation of dense deformation fields across a range of varied inputs. Our method exhibits significant improvements in terms surface reconstruction accuracy across the full parameter range. In this way, our networks can capture spaces of complex surface behavior, and allow for real-time interactions with physics effects that are orders of magnitudes slower to compute with traditional solvers. Beyond liquid surfaces, our deformation networks could also find application for other types of surface data, such as those from object collections or potentially also moving characters. Likewise, it could be interesting to extend our method in order to infer deformations for input sets without an existing parametrization.
8

Under review as a conference paper at ICLR 2019
REFERENCES
[1] P. Agrawal, A. V. Nair, P. Abbeel, J. Malik, and S. Levine. Learning to poke by poking: Experiential learning of intuitive physics. In Advances in Neural Information Processing Systems, pages 5074­5082, 2016.
[2] C. Bailer, K. Varanasi, and D. Stricker. Cnn-based patch matching for optical flow with thresholded hinge loss. arXiv preprint: 1607.08064, 2016.
[3] P. Battaglia, R. Pascanu, M. Lai, D. J. Rezende, et al. Interaction networks for learning about objects, relations and physics. In Advances in Neural Information Processing Systems, pages 4502­4510, 2016.
[4] K. S. Bhat, S. M. Seitz, J. Popovic´, and P. K. Khosla. Computing the physical parameters of rigid-body motion from video. In European Conference on Computer Vision, pages 551­565. Springer, 2002.
[5] C. M. Bishop. Pattern Recognition and Machine Learning (Information Science and Statistics). SpringerVerlag New York, Inc., Secaucus, NJ, USA, 2006.
[6] R. Bridson. Fluid Simulation for Computer Graphics. CRC Press, 2015.
[7] M. A. Brubaker, L. Sigal, and D. J. Fleet. Estimating contact dynamics. In Computer Vision, 2009 IEEE 12th International Conference on, pages 2389­2396. IEEE, 2009.
[8] M. B. Chang, T. Ullman, A. Torralba, and J. B. Tenenbaum. A compositional object-based approach to learning physical dynamics. arXiv:1612.00341, 2016.
[9] M. Chu and N. Thuerey. Data-driven synthesis of smoke flows with CNN-based feature descriptors. ACM Trans. Graph., 36(4)(69), 2017.
[10] M. Denil, P. Agrawal, T. D. Kulkarni, T. Erez, P. Battaglia, and N. de Freitas. Learning to perform physics experiments via deep reinforcement learning. arXiv preprint arXiv:1611.01843, 2016.
[11] A. Dosovitskiy, P. Fischery, E. Ilg, C. Hazirbas, V. Golkov, P. van der Smagt, D. Cremers, T. Brox, et al. Flownet: Learning optical flow with convolutional networks. In International Conference on Computer Vision (ICCV), pages 2758­2766. IEEE, 2015.
[12] S. Ehrhardt, A. Monszpart, N. J. Mitra, and A. Vedaldi. Learning a physical long-term predictor. arXiv:1703.00247, 2017.
[13] A. B. Farimani, J. Gomes, and V. S. Pande. Deep learning the physics of transport phenomena. arXiv:1709.02432, 2017.
[14] C. Finn, I. Goodfellow, and S. Levine. Unsupervised learning for physical interaction through video prediction. In Advances in neural information processing systems, pages 64­72, 2016.
[15] K. Fragkiadaki, P. Agrawal, S. Levine, and J. Malik. Learning visual predictive models of physics for playing billiards. arXiv preprint arXiv:1511.07404, 2015.
[16] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Generative adversarial nets. In Advances in neural information processing systems, pages 2672­2680, 2014.
[17] R. Grzeszczuk, D. Terzopoulos, and G. Hinton. Neuroanimator: Fast neural network emulation and control of physics-based models. In Proceedings of the 25th annual conference on Computer graphics and interactive techniques, pages 9­20. ACM, 1998.
[18] E. Ilg, N. Mayer, T. Saikia, M. Keuper, A. Dosovitskiy, and T. Brox. Flownet 2.0: Evolution of optical flow estimation with deep networks. arXiv preprint: 1612.01925, 2016.
[19] P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros. Image-to-image translation with conditional adversarial networks. CVPR, 2017.
[20] M. Jaderberg, K. Simonyan, A. Zisserman, et al. Spatial transformer networks. In Advances in neural information processing systems, pages 2017­2025, 2015.
[21] N. Kyriazis and A. Argyros. Physically plausible 3d scene tracking: The single actor hypothesis. In Computer Vision and Pattern Recognition (CVPR), 2013 IEEE Conference on, pages 9­16. IEEE, 2013.
[22] N. Kyriazis and A. Argyros. Scalable 3d tracking of multiple interacting objects. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 3430­3437. IEEE, 2014.
9

Under review as a conference paper at ICLR 2019
[23] L. Ladicky, S. Jeong, B. Solenthaler, M. Pollefeys, and M. Gross. Data-driven fluid simulations using regression forests. ACM Trans. Graph., 34(6):199, 2015.
[24] M. Lentine, M. Aanjaneya, and R. Fedkiw. Mass and momentum conservation for fluid simulation. In Symposium on Computer Animation, pages 91­100. ACM, 2011.
[25] A. Lerer, S. Gross, and R. Fergus. Learning physical intuition of block towers by example. In International Conference on Machine Learning, pages 430­438, 2016.
[26] W. Li, S. Azimi, A. Leonardis, and M. Fritz. To fall or not to fall: A visual approach to physical stability prediction. arXiv preprint arXiv:1604.00066, 2016.
[27] Z. Long, Y. Lu, X. Ma, and B. Dong. Pde-net: Learning pdes from data. arXiv:1710.09668, 2017. [28] J. Masci, U. Meier, D. Cires¸an, and J. Schmidhuber. Stacked convolutional auto-encoders for hierarchical
feature extraction. Artificial Neural Networks and Machine Learning­ICANN 2011, pages 52­59, 2011. [29] S. Meister, J. Hur, and S. Roth. Unflow: Unsupervised learning of optical flow with a bidirectional census
loss. arXiv preprint arXiv:1711.07837, 2017. [30] R. Mottaghi, H. Bagherinezhad, M. Rastegari, and A. Farhadi. Newtonian scene understanding: Unfold-
ing the dynamics of objects in static images. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3521­3529, 2016. [31] R. Mottaghi, M. Rastegari, A. Gupta, and A. Farhadi. "what happens if..." learning to predict the effect of forces in images. In European Conference on Computer Vision, pages 269­285. Springer, 2016. [32] A. Radford, L. Metz, and S. Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. Proc. ICLR, 2016. [33] A. Ranjan and M. J. Black. Optical flow estimation using a spatial pyramid network. CoRR, abs/1611.00850, 2016. [34] K. Raveendran, N. Thuerey, C. Wojtan, and G. Turk. Blending Liquids. ACM Trans. Graph., 33 (4):10, August 2014. [35] D. J. Rezende, S. Mohamed, and D. Wierstra. Stochastic backpropagation and approximate inference in deep generative models. In Proc. ICML, Vol. 32, pages II­1278­II­1286, 2014. [36] C. Schenck and D. Fox. Reasoning about liquids via closed-loop simulation. arXiv:1703.01656, 2017. [37] R. Stewart and S. Ermon. Label-free supervision of neural networks with physics and domain knowledge. In AAAI, pages 2576­2582, 2017. [38] N. Thuerey. Interpolations of Smoke and Liquid Simulations. ACM Trans. Graph., 36(1):15, July 2017. [39] J. Tompson, K. Schlachter, P. Sprechmann, and K. Perlin. Accelerating eulerian fluid simulation with convolutional networks. In International Conference on Machine Learning, pages 3424­3433, 2017. [40] A. Van Oord, N. Kalchbrenner, and K. Kavukcuoglu. Pixel recurrent neural networks. In International Conference on Machine Learning, pages 1747­1756, 2016. [41] N. Watters, D. Zoran, T. Weber, P. Battaglia, R. Pascanu, and A. Tacchetti. Visual interaction networks: Learning a physics simulator from video. In Advances in Neural Information Processing Systems, pages 4542­4550, 2017. [42] J. Wu, J. J. Lim, H. Zhang, J. B. Tenenbaum, and W. T. Freeman. Physics 101: Learning physical object properties from unlabeled videos. In BMVC, volume 2:6, page 7, 2016. [43] J. Wu, I. Yildirim, J. J. Lim, B. Freeman, and J. Tenenbaum. Galileo: Perceiving physical object properties by integrating a physics engine with deep learning. In Advances in neural information processing systems, pages 127­135, 2015.
10

Under review as a conference paper at ICLR 2019

Appendix: Generating Liquid Simulations with Deformation-aware Neural Networks

This supplemental document will first detail the necessary steps to align multiple, weighted deformation fields. Afterwards, we will derive the gradients presented in the paper for the parameter and deformation networks, and then present additional results.

A DEFORMATION ALIGNMENT

As before,  denotes the reference signed distance functions (SDFs) of our input parameter space,
while  denotes instances of a single input surface, typically deformed by our algorithm. We will
denote the single initial surface without any deformations applied with 0. Here, we typically use the zero point of our parameter space, i.e., 0 = 0 , with 0 = 0. Hence, we aim for deforming 0 such that it matches all instances of  as closely as possible.

For the pre-computed, end-point deformations, it is our goal to only use a single deformation for
each dimension of the parameter space . Thus u1 will correspond to 1 and be weighted by 1, and we can apply 1u1 to compute a deformation for an intermediate point along this dimension. Given the sequence of pre-computed deformations {u1, u2, . . . , uN } and a point in parameter space {1, . . . , N } a straight-forward approach is to apply each deformation sequentially

1(x, ) = 0(x - 1u1) 2(x, ) = 1(x - 2u2)
... N (x, ) = N-1(x - N uN ).

(6)

However, there are two disadvantages to this approach. The main problem is that the deformations ui are only meaningful if applied with i = 1.

Thus, if a previous deformation wasn't applied fully with a weight of 1, each subsequent deformation will lead to an accumulation of deformation errors. The second disadvantage of this simple method

Setup

Solutions

u1 u2 Previous work for 1 = 0.5, 2 = 1

Reference solution 1 = 0.5, 2 = 1

1u1

2u2

Undesirable shape

Improved alignment for 1 = 0.5, 2 = 1

v V Aligned result (ours) Figure 10: Illustration of our deformation alignment procedure.
11

Under review as a conference paper at ICLR 2019

is the fact that many advection steps have to be applied in order to arrive at the final deformed
SDF. This also affects performance as each advection step introduces additional computations, and
scattered memory accesses. This is best illustrated with the an example, shown in Fig. 10. In row
1) the first two figures in red show two pre-computed end-point deformations (red arrows). The first
one (u1) moves a drop to the right, while u2 changes its size once it has reached its final position. Images with deformations show the source in dark blue, and the deformed surface in light blue. In
this example, the two deformations should be combined such that the horizontal position and the drop size can be independently controlled by changing 1 and 2. E.g., on the top right, a correct solution for 1 = 0.5, 2 = 1 is shown. Row 2) of Fig. 10 shows how these deformations are applied in previous work: The second deformation acts on wrong parts of the surface, as the drop has not reached its left-most position for 1 = 0.5. The undesirable result in this case is a partially deformed drop, shown again in the middle row on the right.

We present an alternative approach which aligns the deformation fields to the final position of the deformation sequence. Then, all aligned deformation fields can simply be accumulated by addition, and applied to the input in a single step. To do this, we introduce the intermediate deformation fields:

uN (x) = uN (x), uN-1(x) = uN-1(x - uN (x)),
uN-2(x) = uN-2(x - uN (x) - uN -1(x)),

... u1(x) = u1(x - uN (x) - uN -1(x) . . . - u2(x)).

(7)

Each ui is moved by all subsequent deformations uj , j  [i + 1 · · · N ], such that it acts on the correct target position under the assumption that i = 1 (we will address the case of i = 1

below). The Eulerian representation we are using means that advection steps look backward to

gather data, which in our context means that we start with the last deformation uN to align previous deformations. Using the aligned deformation fields u we can include  and assemble the weighted

intermediate fields

N

vsum(x, ) = iui(x)

(8)

i=1

and an inversely weighted correction field

N
vinv(x, ) = - (1 - i)ui (x).
i=1

(9)

The first deformation field vsum represents the weighted sum of all aligned deformations, weighted with the correct amount of deformation specified by the deformation weights i. The second deformation vinv intuitively represents the offset of the deformation field vsum from its destination caused by the  weights. Therefore, we correct the position of vsum by this offset with the help of an
additional forward-advection step calculated as:

vfin(x + vinv(x, ), ) = vsum(x, ),

(10)

This gives us the final deformation field vfin(x, ). It is important to note that the deformation vsum for a position x is assembled at a location x that is not known a-priori. It has to be transported to x with the help of vinv, as illustrated in Fig. 11.
This correction is not a regular advection step, as the deformation is being 'pushed' from x + vinv(x, ) to x. In order to solve this advection equation we use an inverse semi-Lagrangian step, inspired by algorithms such as the one by Lentine et al. (24), pushing values forward with linear interpolation. As multiple values can end up in a single location, we normalize their contribution. Afterwards, we perform several iterations of a "fill-in" step to make sure all cells in the target deformation grid receive a contribution (we simply extend and average deformation values from all initialized cells into uninitialized regions).

The deformed SDF is then calculated with a regular advection step applying the final, aligned defor-

mation with

(x, ) = 0(x - vfin(x, )).

(11)

12

Under review as a conference paper at ICLR 2019

(a) (b)

x vinv(x )
x

vsum(x )

x x vfinal(x)

Figure 11: This figure illustrates the forward advection process: Both deformation vsum and the correction vinv are initially located at x in (a). vinv is applied to yield the correct deformation at location x, as shown in (b).

Based on our correction step from Eq. (10) this method now respects the case of partially applied deformations. As the deformations u(x) are already aligned and don't depend on , we can precompute them. To retrieve the final result it is now sufficient to sum up all deformations in vsum and vinv, then apply one forward-advection step to compute vfin, and finally deform the input SDF by applying semi-Lagrangian advection. While our method is identical with alignment from previous work (38) for i = 1, it is important for practical deformations with weights i = 1.
Our method is illustrated in row 3) of Fig. 10. In the bottom left we see the deformation field vsum from previous work. It is also the starting point of our improved alignment, but never applied directly. Our method corrects vsum by transforming it into vfin, bottom center, which acts on the correct spatial locations. In this example, it means that the expanding velocities from u2 are shifted left to correctly expand the drop based on its initial position. Our method successfully computes the intended result, as shown in the bottom right image.
This algorithm for aligning deformations will be our starting point for learning the weights . After applying the weighted deformations, we adjust the resulting surface we an additional deformation field generated by a trained model. In the following, we will derive gradients for learning the weighting as well as the refinement deformation.

B LEARNING DEFORMATIONS

As outlined in the main document, we aim for minimizing the L2 loss between the final deformed surface and the set of reference surfaces , i.e.:

L

=

1 2

(0(D(xi, )) - (xi))2 ,

i

(12)

where D(xi, ) denotes the joint application of all weighted and generated deformation fields.

B.1 LEARNING DEFORMATION WEIGHTING

We will first focus on the parameter network to infer the weighting of the pre-computed deformation fields based on the input parameters . Thus, the NN has the goal to compute ()  RN =

(1(), . . . , N ()) in order to minimize Eq. (12). The application of the deformations weighted by  includes our alignment step from Sec. A, and hence the neural networks needs to be aware of

its influence. To train the parameter network, we need to specify gradients of Eq. (12) with respect

to the network weights i. With the chain rule we obtain

Ld
dilj

=

d dilj

dL d

.

Since the derivative

of the network output i with respect to a specific network weight ilj is easily calculated with

backpropagation (5), it is sufficient for us to specify the second term. The gradient of Eq. (12) with

respect to the deformation parameter i is given by

d di

L

=

j

d di

(xj

,

)

[(xj

,

)

-

(xj

)]

,

(13)

13

Under review as a conference paper at ICLR 2019

where we have inserted Eq. (11). While the second term in the sum is easily computed, we need to calculate the first term by differentiating Eq. (11) with respect to i, which yields

d di

(x,

)

=

-

d di

vfin

(x,

)

·

0(x - vfin(x, )).

(14)

As the gradient of 0 is straight forward to compute,

d di

vfin(x,

)

is

crucial

in

order

to

compute

a reliable derivative. It is important to note that even for the case of small corrections vinv(x, ),

Eq. (10) cannot be handled as another backward-advection step such as vfin(x, ) = vsum(x -

vinv(x, ), ). While it might be tempting to assume that differentiating this advection equation

will produce reasonable outcomes, it can lead to noticeable errors in the gradient. These in turn

quickly lead to diverging results in the learning process, due to the non-linearity of the problem.

The correct way of deriving the change in vfin(x, ) is by taking the total derivative of vsum(x, ) = vfin(x + vinv(x, ), ) with respect to i:

d di

vsum

(x,

)

=

 i

vfin(x

+

vinv(x,

),

)

+

JV

(x

+

vinv(x, ),

)

 i

vinv(x,

),

(15)

where, JV (x + vinv(x, ), ) denotes the Jacobian of vfin with respect to x, evaluated at x + vinv(x, ). Rearranging Eq. (15) and inserting vsum and vinv yields

 i

vfin

(x

+

vinv

(x,

),

)

=

d di

vsum(x,

)

-

JV

(x

+

vinv(x,

),

)

 i

vinv(x,

)

=

d di

N i=1

iui (x) +

JV (x +

vinv(x, ), )

 i

N
(1 -
i=1

i) ui (x)

= [1 - JV (x + vinv(x, ), )] ui(x).

(16) (17)

We note that the Jacobian in the equation above has small entries due to the smooth nature of the
deformations vfin. Thus, compared to the unit matrix it is small in magnitude. Note that this relationship is not yet visible in Eq. (15). We have verified in experiments that JV does not improve the gradient significantly, and we thus set this Jacobian to zero, arriving at

 i

vfin(x

+

vinv(x,

),

)



ui (x),

(18)

where the u are the deformation fields aligned for the target configuration from Eq. (7). We use Eq. (18) to estimate the change in the final deformation fields for changes of the i-th deformation

parameter. We see that this equation has the same structure as Eq. (10). On the left-hand side, we

have

 i

vfin

,

evaluated

at

x

+

vinv(x, ),

whereas

ui

on

the

right-hand

side

is

evaluated

at

x.

To

calculate

d di

vfin(x,

)

then,

we

can

use

the

same

forward-advection

algorithm,

which

is

applied

to

the correction in Eq. (10). With this, we have all the necessary components to assemble the gradient

from Eq. (13) for training the parameter network with back-propagation.

B.2 LEARNING TO GENERATE DEFORMATIONS
Our efforts so far have been centered around producing a good approximation of , with a set of given end-point deformations {u0, . . . , un}. The performance of this method is therefore inherently constrained by the amount of variation we can produce with the deformation inputs. To allow for more variation, we propose to generate an additional space-time deformation field w(), that changes with the simulation parameters . Once again, we model this function with a neural network, effectively giving the network more expressive capabilities to directly influence the final deformed surface.
For this network we choose a structure with a set of four-dimensional deconvolution layers that generate a dense space-time deformation field. We apply the trained deformation with an additional

14

Under review as a conference paper at ICLR 2019

Parameter network:

in out 88

Deformation network:

reshape


in
16

24
34 32

2592

44
54 16

w
104 out 4

Figure 12: Overview of our two neural networks. While the parameter network (left) is simple, consisting of two fully connected layers, its cost functions allows it to learn how to apply multiple long-range, non-linear deformation fields. The deformation network (right), which makes use of several de-convolutional layers, instead learns to generate dense deformation fields to refine the final surface.

advection step after applying the deformations weighted by the parameter network:
~(x) = 0 (x - vfin(x, ())) , (x) = ~ (x - w(x, )) .

(19) (20)

Thus, the deformation network only has to learn to refine the surface ~ after applying the weighted deformations, in order to accommodate the nonlinear behavior of .
As input, we supply the deformation network with the simulation parameters  = (i, . . . , N ) as a vector. The output of the network are four-component vectors, with the resolution Rx×Ry×Rz×Rt. Note that in general the SDF resolution and the deformation resolution do not need to be identical. Given a fixed SDF resolution, we can use a smaller resolution for the deformation, which reduces the number of weights and computations required for training. Thus in practice, each four-dimensional vector of the deformation acts on a region of the SDF, for which we assume the deformation to be constant. Therefore, we write the deformation field as

w(x, ) = j(x) wj(),
j

(21)

where j(x) is the indicator function of the j-th region on which the four-dimensional deformation vector wj() acts. This vector is the j-th output of the deformation network.
For training, we need to calculate the gradient of the loss-function Eq. (12) with respect to the network weights. Just like in the previous section, it is sufficient to specify the gradient with respect to the network outputs wi(). Deriving Eq. (12) yields

dL dwi

=
j

d dwi

(x)

((x)

-

(x))

=
j

d ~ (x - w(x, )) dwi

((x) - (x))

= - Xi(xj) ~(xj - w(xj, )) ((xj, ) - (xj)) .

j

(22)

Thus, we can calculate the derivative by summation over the region that is affected by the network output wi. The gradient term is first calculated by evaluating a finite difference stencil on ~(xj) and then advecting it with the corresponding deformation vector w(xj, ). The other terms in Eq. (22) are readily available. Alg. 1 summarizes our algorithm for training the deformation network. In
particular, it is important to deform the input SDF gradients with the inferred deformation field, in
order to calculate the loss gradients in the correct spatial location for backpropagation.

15

Under review as a conference paper at ICLR 2019

ALGORITHM 1: Training the deformation network

Data: training samples from 

Result: trained deformation network weights 

for each training sample {~ , ~} do

evaluate neural network to compute (~ )

load reference SDF ~, initial SDF 0

calculate vfin(xi, (~ ))
~ = advect 0 with vfin calculate ~

evaluate neural network to compute wi(~ )

assemble w(xi) from wi(~ , ) according to Eq. (21) advect ~ with w

advect ~ with w

for each wi do

calculate the gradient

d dwi

L

according

to

Eq.

(22)

end

backpropagate

d dwi

Lt

from

Eq.

(5)

to

adjust



end

Initial Conditions

Input Data at t=30

Parameter Dimension 1: Drop Position X

Parameter Dimension 2: Drop Size
Figure 13: The left image illustrates the initial conditions of our two dimensional parameter space setup. It consists of a set of two-dimensional liquid simulations, which vary the position of the liquid drop along x as 1, and its size as 2. The right half shows the data used for training at t = 30. Note the significant amount of variance in positions of small scale features such as the thin sheets. Both images show only a subset of the whole data.
C ADDITIONAL EVALUATION
C.1 2D DATA SET
In the following, we explain additional details of the evaluation examples. For the two dimensional data set, we use the SDFs extracted from 2D simulations of a drop falling into a basin. As simulation parameters we choose 1 to be the size of the drop, and 2 to be its initial x-position, as shown in Fig. 13. From this simulation we extract a single frame at t = 30, which gives us a two-dimensional parameter-space  = (1, 2), where each instance of  has a corresponding two-dimensional SDF. In order to train the networks described in section 3, we sample the parameter domain with a regular 44 × 49 grid, which gives us 2156 training samples, of which we used 100 as a validation set.
Fig. 14 shows the validation loss and the training loss over the iterations both for parameter learning and for deformation learning. We observe that in both cases the learning process reduces the loss, and finally converges to a stable solution. This value is lower in the case of deformation training, which can be easily explained with the increased expressive capabilities of the deformation network.
16

Under review as a conference paper at ICLR 2019

55

validation loss

validation loss

4

training loss

4

training loss

33

Loss Loss

22

11

0

0

10000

20000

30000

Training Iterations

(a) Parameter Learning

0 40000 0

10000

20000

30000

Training Iterations

(b) Deformation learning

40000

Figure 14: Loss during training both for parameter learning and deformation learning. In yellow we show the loss for the current sample, while the dark line displays the loss evaluated on the validation set.

5

4

Loss

3 naive gradient 2 corrected gradient

1

0

0

10000

20000

30000

Training Iterations

Figure 15: Training with different gradient approximations: validation loss with a simplified advection (red), and the correct gradient from forward advection (green). The simplified version does not converge.

We verified that the solution converged by continuing training for another 36000 steps, during which the change of the solution was negligible.
As mentioned above, it might seem attractive to use a simpler approximation for the forward advection in Eq. (13), i.e., using a simpler, regular advection step. However, due to the strong non-linearity of our setting, this prevents the network from converging, as shown in Fig. 15.
The effect of our deformation network approach is illustrated in Fig. 5. This figure compares our full method (on the right) with several other algorithms. A different, but popular approach for non-linear dimensionality reduction, which can be considered as an alternative to our method, is to construct a reduced basis with PCA. Using the mean surface with four eigenvectors yields a similar reduction to our method in terms of memory footprint. We additionally re-project the different reference surfaces into the reduced basis to improve the reconstruction quality of the PCA version. However, despite this the result is a very smooth surface that fails to capture any details of the behavior of the parameter space, as can be seen in the left column of Fig. 5.
The next column of this figure (in pink) shows the surfaces obtained with the learned deformation weights with our parameter network (Fig. 12 top), but without an additional deformation network. As this case is based on end-point deformations, it cannot adapt to larger changes of surface structure in the middle of the domain. In contrast, using our full pipeline with the deformation network yields surfaces that adapt to the varying behavior in the interior of the parameter space, as shown on the right side of Fig. 5. However, it is also apparent that the deformations generated by our approach do not capture every detail of the references. The solution we retrieve is regularized by the varying reference surfaces in small neighborhoods of , and the networks learns an averaged behavior from the inputs.
17

Under review as a conference paper at ICLR 2019

Previous work [Thuerey'16]

PCA reconstruction

NN, End-point defo. only

Reference only

With NN deformation

Figure 16: Different example surfaces from the 2D parameter space of Fig. 13. From left to right: surfaces reconstructed with PCA (purple), weighted deformations using a trained parameter network (pink), the reference surfaces (brown), and on the far right the output of our full method with a deformation network (teal). Note that none of the other methods is able to reconstruct both arms of liquid in the firstdebug note: frames 7, 19, 31 row, as well as the left sheet in the bottom row. The reference surfaces are shown in light brown in the background for each version.

Table 1: Performance and setup details of our 4D data sets in the Android app measured on a Samsung S8 device. The "defo. align" step contains alignment and rescaling of the deformations.

Drop Staris

SDF res.
404 504

Defo. res.
204 254

NN eval.
69ms 410ms

Defo. align
21.5ms 70ms

Rendering
21ms 35ms

C.2 4D DATA SETS
Below we give additional details for our results for the 4D data sets and experiments presented in the main document.
Liquid Drop As our first 4D test case, we chose a drop of liquid falling into a basin. As our simulation parameters we chose the x- and y-coordinates of the initial drop position, as well as the size of the drop. We typically assume that the z-axis points upwards. To generate the training data, we sample the parameter space on a regular grid, and run simulations, each with a spatial resolution of 1003 to generate a total of 1764 reference SDFs. Here, 0 contains a 4D SDF of a large drop falling into the upper right corner of the basin. In Fig. 17 we show additional examples how the introduction of the deformation network helps to represent the target surface across the full parameter range.
The advantages of our approach also become apparent when comparing our method with a direct interpolation of SDF data-sets, i.e., without any deformation. Our algorithms requires a single fullresolution SDF, three half resolution deformations, and the neural network weights (ca. 53.5k). While a single 404 SDF requires ca. 2.5m scalar values, all deformations and network weights require ca. 2m scalars in total. Thus our representation encodes the full behavior with less storage than two full SDFs. To illustrate this point, we show the result of a direct SDF interpolation in Fig. 18. Here we sample the parameter space with 8 SDFs in total (at all corners of the 3D parameter space). Hence, this version requires more than 4x the storage our approach requires. Despite the additional memory, the direct interpolations of SDFs lead to very obvious, and undesirable artifacts. The results shown on the right side of Fig. 18 neither represent the initial drop in (a), nor the resulting splash in (b). Rather, the SDF interpolation leads to strong ghosting artifacts, and an overall loss of detail. Instead of the single drop and splash that our method produces, it leads to four smoothed, and repeated copies. Both the PCA example above, and this direct SDF interpolation illustrate the usefulness of representing the target surface in terms of a learned deformation.
18

Under review as a conference paper at ICLR 2019
Figure 17: Additional examples of the influence of the deformation network for three different time steps (t = 1, 4, 8 from top to bottom). Each pair shows the reference surface in transparent brown, and in purple on the left the deformed surface after applying the precomputed deformations. These surfaces often significantly deviate from the brown target, i.e. the visible purple regions indicates misalignments. In cyan on the right, our final surfaces based on the inferred deformation field. These deformed surface often match the target surface much more closely. Stairs Our second test setup illustrates a different parameter space that captures a variety of obstacle boundary conditions parametrized with . Our first two simulation parameters are the heights of two stair-like steps, while the third parameter is controlling the position of a middle divider obstacle, as illustrated in Fig. 19. The liquid flows in a U-shaped manner around the divider, down the steps. For this setup, we use a higher overall resolution for both space-time SDFs, as well as for the output of the deformation network. Performance details can be found in Table 1. Fig. 20 depicts still frames captured from our mobile application for this setup. With this setup the user can adjust stair heights and wall width dynamically, while deformations are computed in the background. While this setup has more temporal coherence in its motion than the drop setup, the changing obstacle boundary conditions lead to strongly differing streams over the steps of the obstacle geometry. E.g., changing the position of the divider changes the flow from a narrow, fast stream to a slow, broad front.
19

Under review as a conference paper at ICLR 2019

a) b)

a) b)

Our approach

Direct SDF Interpolation

Figure 18: Two frames generated with our approach (left) and with a direct SDF interpolation using a similar amount of overall memory (right). The latter looses the inital drop shape (a), and removes all splash detail (b). In addition, the direct SDF interpolation leads to strong ghosting artifacts with four repeated patterns.

Table 2: Overview of our 2D and 4D simulation and machine learning setups. Timings were mea-
sured on a Xeon E5-1630 with 3.7GHz. Res, SDF and Defo denote resolutions for simulation, train-
ing, and the NN deformation, respectively; Sim and Train denote simulation and training runtimes. sp, sd, 1, 2 denote training steps for parameters, training steps for deformation, and regularization parameters, respectively.

Setup

Res. SDF Defo. Sim. Train sp sd

2D setup, Fig. 13

1002

1002

252

- 186s 40k 10k

Drop, Fig. 8

1003 · 100

404

104 8.8m

22m

12k

2k

Stairs, Fig. 20

1103 · 110

504

154

9.7m

186m

9k

1k

Parameter 1 - raise corner

Parameter 2 - lower platform

Parameter 3 - wall width

Figure 19: The geometric setup of the three deformations of our stairs setup from 20 are illustrated in this figure.

Figure 20: These screens illustrate our stairs setup running in our mobile application. From left to right, the middle divider is pulled back, leading to an increased flow over the step in the back. In the right-most image, the left corner starts to move up, leading to a new stream of liquid pouring down into the outflow region in the right corner of the simulation domain.
20

