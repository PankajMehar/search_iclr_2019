Under review as a conference paper at ICLR 2019

P

DN

N

T

LP

Anonymous authors Paper under double-blind review

A
Deep Learning has received significant attention due to its impressive performance in many state-of-the-art learning tasks. Unfortunately, while very powerful, Deep Learning is not well understood theoretically and in particular only recently results for the complexity of training deep neural networks have been obtained. In this work we show that large classes of deep neural networks with various architectures (e.g., DNNs, CNNs, Binary Neural Networks, and ResNets), activation functions (e.g., ReLUs and leaky ReLUs), and loss functions (e.g., Hinge loss, Euclidean loss, etc) can be trained to near optimality with desired target accuracy using linear programming in time that is exponential in the size of the architecture and polynomial in the size of the data set; this is the best one can hope for due to the NP-Hardness of the problem and in line with previous work. In particular, we obtain polynomial time algorithms for training for a given fixed network architecture. Our work applies more broadly to empirical risk minimization problems which allows us to generalize various previous results and obtain new complexity results for previously unstudied architectures in the proper learning setting.

1I

Deep Learning is a powerful tool for modeling complex learning tasks. Its versatility allows for nuanced architectures that capture various setups of interest and has demonstrated a nearly unrivaled performance on state-of-the-art learning tasks across many domains. At the same time, the fundamental behavior of Deep Learning methods is not well understood. One particular aspect that recently gained significant interest is the computational complexity of training such networks. The basic training problem is usually formulated as an empirical risk minimization problem (ERM) that can be phrased as

min 1 D ( f (x^i, ), y^i),   D i=1

(1)

where is some loss function, (x^i, y^i)iD=1 is an i.i.d. sample from some data distribution D, and f is a neural network architecture parameterized by    with  being the parameter space of the considered architecture (e.g., network weights). The empirical risk minimization problem is solved in lieu of the general risk minimization problem (GRM) min E(x,y)D [ ( f (x, ), y)] which is usually impossible to solve due to the inaccessibility of D. Several works have studied the training problem for specific architectures, both in the proper and improper learning setup, and basically establish trainability in time that is exponential in the network parameters but polynomial in the amount of data. In this work we complement and significantly extend previous work by providing a principled method to convert the empirical risk minimization problem in (1) associated with the learning problem for various architectures into a linear programming problem (LP) in the proper learning setting. The obtained linear programming formulations are of size roughly exponential in

1

Under review as a conference paper at ICLR 2019
the size of the architecture and the desired accuracy and linear in the size of the data. This is in line with previous work (see e.g., Goel et al. (2017); Zhang et al. (2016); Arora et al. (2018)) that include an architecture depended constant (that is exponential in the size of the architecture) and are polynomial in the size of the data; here and below size refers to the bit complexity as customary.
RW
Our work is most closely related to Goel et al. (2017), Zhang et al. (2016), and Arora et al. (2018). In Zhang et al. (2016) the authors show that 1-regularized networks can be learned improperly in polynomial time in the size of the data (with a possibly exponential architecture dependent constant) for networks with ReLU-like activations (but not actual ReLUs) and an arbitrary number of layers k. These results were then generalized in Goel et al. (2017) to actual ReLU activations. In both cases the improper learning setup is considered, i.e., the learned predictor is not a neural network itself and the learning problem is solved approximately for a given target accuracy. In contrast to these works, Arora et al. (2018) considered proper and exact learning however only for k = 2 (i.e., one hidden layer).
In relation to these works, we consider the proper learning setup for an arbitrary number of layers k and a wide range of activations, loss functions, and architectures. As previous works, except for Arora et al. (2018), we consider the approximate learning setup as we are solving the empirical risk minimization problem and we also establish generalization of our so-trained models. Our approach makes use of Bienstock and Muñoz (2018) that allows for reformulating non-convex optimization problems with small treewidth and discrete as well as continuous decision variables as an approximate linear programming formulations.
C
We first establish a general framework that allows us to reformulate (regularized) ERM problems arising in Deep Learning (among others!) into approximate linear programs with explicit bounds on their complexity. The resulting methodology allows for providing complexity upper bounds for specific setups simply by plugging-in complexity measures for the constituting elements such as layer architecture, activation functions, and loss functions. In particular our approach overcomes limitations of previous approaches in terms of handling the accuracy of approximations of non-linearities used in the approximation functions to achieve the overall target accuracy.
Principled Training through LPs. If > 0 is arbitrary, then for any sample size D there exists a dataindependent linear program, i.e., the LP can be written down before seeing the data, with the following properties:
Solving the ERM problem to -optimality. The linear program describes a polyhedron P such that for every realized data set (X^, Y^ ) = (x^i, y^i)iD=1 there is a face FX^,Y^  P such that optimizing certain linear function over FX^,Y^ solves (1) to -optimality returning a feasible parametrization ~   which is part of our hypothesis class (i.e., we consider proper learning). The face FX^,Y^  P is simply obtained from P by fixing certain variables of the linear program using the values of the actual sample; equivalently, by Farkas' lemma, this can be achieved by modifying the objective function to ensure optimization over the face belonging to the data. As such, the linear program has a build-once-solve-many feature. We will also show that a possible data-dependent LP formulation is meaningless (see Appendix B).
Size of the linear program. The size, measured as bit complexity, of the linear program is roughly O((2L/ )N+n+m D) where L is a constant depending on , f , and  that we will introduce later, n, m are the dimensions of the data points, i.e., x^i  Rn and y^i  Rm for all i  [D], and N is the dimension of the parameter space . The overall learning algorithm is obtained then by formulating and solving the linear program, e.g., with the ellipsoid method whose running time is polynomial in the size of the input
2

Under review as a conference paper at ICLR 2019

Grötschel et al. (2012). Even sharper size bounds can be obtained for specific architectures assuming network structure (see Appendix F) and our approach immediately extends to regularized ERMs (see Appendix E). It is important to mention that the constant L measures a certain Lipschitzness of the ERM training problem. While not exactly requiring Lipschitz continuity in the same way, Lipschitz constants have been used before for measuring complexity in the improper learning framework (see Goel et al. (2017)) and more recently have been shown to be linked to generalization in Gouk et al. (2018).
Generalization. Finally, we establish that the solutions obtained for the ERM problem via our linear programming approach generalize, utilizing techniques from stochastic optimization (see Section 5).
Throughout this work we assume both data and parameters to be well-scaled, which is a common assumption and mainly serves to simplify the representation of our results; the main assumption is the reasonable boundedness, which can be assumed without significant loss of generality as actual computations assume boundedness in any case (see also Liao et al. (2018) for arguments advocating the use of normalized coefficients in neural networks). More specifically, we assume   [-1, 1]N as well as (x, y)  D satisfies (x, y)  [-1, 1]n × [-1, 1]m. We point out three important features of our results. First, we provide a solution method that has provable optimality guarantees for the ERM problem, ensures generalization, and linear dependency on the data (in terms of the complexity of the LP) without assuming convexity of the optimization problem. To the best of our knowledge, the only result presenting optimality guarantees in a proper learning, non-convex setting is that of Arora et al. (2018). Second, the linear program that we construct for a given sample size D is data-independent in the sense that it can be written down before seeing the actual data realization and as such it encodes reasonable approximations of all possible data sets that can be given as an input to the ERM problem. This in particular shows that our linear programs are not simply discretizing space: if one considers a discretization of data contained in [-1, 1]n × [-1, 1]m, the total number of possible data sets of size D is exponential in D, which makes the linear dependence on D of the size of our LPs a remarkable feature. Finally, our approach can be directly extended to handle commonly used regularizers as we show in Appendix E; for ease of presentation though we omit regularizers throughout our main discussions.

Complexity results for various network architectures. We apply our methodology to various well-known neural network architectures and either generalize previous results or provide completely new results. We provide an overview of our results in Table 1, where k is the number of layers, w is width of the network, n/m are the input/output dimensions and N is the total number of parameters. We use G to denote the directed graph defining the neural network and  the maximum vertex in-degree in G. In all results the node computations are linear with bias term and normalized coefficients, and activation functions with Lipschitz constant at most 1 and with 0 as a fixed point; these include ReLU, Leaky ReLU, eLU, Tanh, among others.

Type Fully connected DNN Fully connected DNN Convolutional NN ResNet ResNet

Loss Function Absolute/Quadratic/Hinge Cross-Entropy + Soft-Max Absolute/Quadratic/Hinge Absolute/Quadratic/Hinge Cross-Entropy + Soft-Max

Size of LP

O

mwO(k2)/

n+m+N
D

O

m log(m)wO(k2)/

n+m+N
D

O

mwO(k2)/

n+m+N
D

O

mO(k2)/

n+m+ N
D

O

m log(m)O(k2)/

n+m+ N
D

Remarks N = |E(G)| N = |E(G)| N |E(G)|

Table 1: Summary of results for various architectures

3

Under review as a conference paper at ICLR 2019

We would like to point out that certain improvements in the results in Table 1 can be obtained by further specifying if the ERM problem corresponds to regression or classification. For example, the choice of loss functions and the nature of the output data y (discrete or continuous) typically rely on this. We can exploit such features in the construction of the LPs (see the proof of Theorem 3.1) and provide a sharper bound on the LP size. Nonetheless, these improvements are not especially significant and in the interest of clarity and brevity we prefer to provide a unified discussion on ERM. Missing proofs have been relegated to the appendix due to space limitations.

2P

In the following let [n] {1, . . . , n} and [n]0 {0, . . . , n}. Given a graph H, we will use V(H) and E(H) to denote the vertex-set and edge-set of H, respectively, and H (u) will be the set of edges incident to vertex u. We will need: Definition 2.1. For a function g : K  Rn  R, we denote its Lipschitz constant with respect to the p-norm over K as Lp(g), satisfying |g(x) - g(y)|  Lp(g) x - y p for all x, y  K (whenever it exists).
Moreover, in the following let E [·] and V [·] denote the expectation and variance with respect to the random variable   , respectively.

2.1 E

RM

The basic ERM problem is typically of the form (1), where is some loss function, (x^i, y^i)iD=1 is an i.i.d. sample from some data distribution D that we have reasonable sampling access to, and f is a model that is parametrized by   . We consider the proper learning setting here, where the computed solution to the ERM problem has to belong to the hypothesis class induced by ; for a detailed discussion see Appendix A.2. We next define the Lipschitz constant of an ERM problem with respect to the infinity norm.

Definition 2.2. Consider the ERM problem (1) with parameters D, , , f . We define the Architecture Lipschitz Constant L(D, , , f ) as

L(D, , , f ) L( ( f (·, ·), ·)) over the domain K = [-1, 1]n ×  × [-1, 1]m.

(2)

We emphasize that in (2) we are considering the data-dependent entries as variables as well, and not only the parameters  as it is usually done in the literature. This is because we will construct data-independent LPs, a subtlety that will become clear later.

2.2 N

N

A neural network can be understood as a function f defined over a directed graph that maps inputs x  Rn to f (x)  Rm. The directed graph G = (V, E), which represents the network architecture, often naturally decomposes into layers V = i[k]0 Vi with Vi  V, where V0 is referred to as the input layer and Vk as the output layer. To all other layers we refer to as hidden layers. These graphs do neither have to be acyclic (as in the case of recurrent neural networks) nor does the layer decomposition imply that arcs are only allowed between adjacent layers (as in the case of ResNets). In feed-forward networks, however, the graph is assumed to be acyclic. For the unfamiliar reader we provide a more formal definition in Appendix A.3.

2.3 B

O

We will introduce the key concepts that we need to formulate and solve binary optimization problems with small treewidth, which will be the main workhorse behind our results. The treewidth of a graph is a parameter

4

Under review as a conference paper at ICLR 2019

used to measure how tree-like a given graph is. Among all its equivalent definitions, the one we will use in this work is the following: Definition 2.3. Let G be an undirected graph. A tree-decomposition (Robertson and Seymour (1986)) of G is a pair (T, Q) where T is a tree and Q = {Qt : t  V(T)} is a family of subsets of V(G) such that
(i) For all v  V(G), the set {t  V(T) : v  Qt } forms a sub-tree Tv of T, and
(ii) For each {u, v}  E(G) there is a t  V(T) such that {u, v}  Qt , i.e., t  Tu  Tv.
The width of the decomposition is defined as max {|Qt | : t  V(T)} - 1. The treewidth of G is the minimum width over all tree-decompositions of G.
We refer to the Qt as bags as customary. An example of a tree-decomposition is given in Figure 2 in Appendix A.1. In addition to width, another important feature of a tree-decomposition (T, Q) we use is the size of the tree-decomposition given by |V(T)|.
Consider a problem of the form
(BO) : min cT x + dT y s.t. fi(x)  0, i  [m] gj (x) = yj, j  [p] x  {0, 1}n, y  Rp,
where the fi and gj are arbitrary functions that we access via a function value oracle, i.e., an oracle that returns the function upon presentation with an input. We will further use the concept of intersection graph. Definition 2.4. The intersection graph [I] for an instance I of BO is the undirected graph which has a vertex for each x variable and an edge for each pair of x variables that appear in any common constraint.
Note that in the above definition we have ignored the y variables which will be of great importance later. The sparsity of a problem is now given by the treewidth of its intersection graph and we obtain: Theorem 2.5. Consider an instance I of problem BO. If [I] has a tree-decomposition (T, Q) of width , there is an exact linear programming reformulation of I with O (2 (|V(T)| + p)) variables and constraints.
Theorem 2.5 is an immediate generalization of a theorem in Bienstock and Muñoz (2018) distinguishing the variables y, which do not need to be binary in nature, but are fully determined by the binary variables x. The proof is omitted as it is almost identical to the proof in Bienstock and Muñoz (2018). For the sake of completeness, we include a proof sketch in Appendix C.1.

3A

ERM

-

LP

We will now show how we can obtain an approximate LP formulation for the ERM problem. A notable feature is that our LP formulation is data-independent in the sense that we can write down the LP, for a given sample size D, before having seen the actual data; the LP is later specialized to a given data set by fixing some of its variables. This subtlety is extremely important as it prevents trivial solutions, where some non-deterministic guess provides a solution to the ERM problem for a given data set and then simply writes down a small LP that outputs the network configuration; such an LP would be of small size (the typical notion of complexity used for LPs) however not efficiently computable. By making the construction independent of the data we circumvent this issue; we provide a short discussion in Appendix B and refer the interested reader to Braun et al. (2016; 2015); Braun and Pokutta (2018+) for an in-depth discussion of this subtlety. Slightly simplifying, we might say for now that in the same way we do not want algorithms to be designed for a fixed data set, we do not want to construct LPs for a specific data set but for a wide range of data sets.

5

Under review as a conference paper at ICLR 2019

As mentioned before, we assume   [-1, 1]N as well as (x, y)  D satisfies (x, y)  [-1, 1]n × [-1, 1]m as normalization to simplify the exposition. Since the BO problem only considers linear objective functions, we begin by reformulating the ERM problem (1) in the following equivalent form:

min
 

1D D d=1 Ld

Ld = ( f (x^d, ), y^d)  d  [D]

(4)

3.1 A

-

Motivated by this reformulation, we study an approximation to the following set:

S(D, , , f ) = (x1, . . . , xD, y1, . . . , yD, , L)  [-1, 1](n+m)D ×  × RD : Ld = ( f (xd, ), yd)

(5)

The variables (xi, yi)iD=1 denote the data variables, that will be assigned values upon a specification of a data set of sample size D.

Let r  R with -1  r  1. Given   (0, 1) we can approximate r as a sum of inverse powers of 2, within additive error proportional to . For N log2 -1 there exist values zh  {0, 1} with h  [N], so that

N N
-1 + 2 · 2-h zh  r  -1 + 2 · 2-h zh + 2  1.
h=1 h=1

(6)

Our strategy is now to approximately represent the x, y,  variables via these binary approximations, i.e., as

-1 + 2 ·

L h=1

2-h zh

where

each

zh

is

a

(new)

binary

variable.

Define

= 2L, where L = L(D, , , f ) is

the architecture Lipschitz constant defined in (2), and consider the following approximation of S(D, , , f ):

S (D, , , f ) (x1, . . . , xD, y1, . . . , yD, , L)  [-1, 1](n+m)D ×  × RD : z  {0, 1}N(N+Dn+Dm)

Ld = ( f (xd, ), yd), d  [D]

N

yid = -1 + 2

2-h

ziy,

d
h

,

d



[D],

i



[m]

h=1

N
i = -1 + 2 2-h zi,h, i  [N]
h=1
N
xid = -1 + 2 2-h zix,hd, d  [D], i  [n] .
h=1

We can readily describe the error of the approximation of S(D, , , f ) by S (D, , , f ) in the ERM problem (1) induced by the discretization:

Lemma 3.1. For any (x1, . . . , xD, y1, . . . , yD, , L)  S(D, , , f ) there is (x^1, . . . , x^D, y^1, . . . , y^D, ^, L^ ) 

S

(D, ,

, f ) such that

1 D

D d=1

Ld

-

1 D

D d=1

L^ d



.

By substituting out the x, y,  by means of the equations of S (D, , , f ), we obtain a feasible region as BO.

3.2 L
So far, we have phrased the ERM problem (1) in terms of a binary optimization problem using a discretization of the continuous variables. This in and of itself is neither insightful nor useful. In this section we will perform the key step, reformulating the convex hull of S (D, , , f ) as a moderate-sized linear program by means of Theorem 2.5 exploiting small treewidth of the ERM problem.

6

Under review as a conference paper at ICLR 2019

x1, y1 N

x2, y2 1
2

xD, yD

4

3 x3, y3

 x1, y1

 x2, y2

···

 xD, yD

(b) Valid Tree-Decomposition

(a) Intersection Graph of S (D, , , f )

Figure 1: Intersection Graph and Tree-Decomposition of S (D, , , f )

After replacing the (x, y, ) variables in S (D, , , f ) using the z variables, we can see that the intersection graph of S (D, , , f ) is given by Figure 1a, where we use (x, y, ) as stand-ins for corresponding the binary variables zx, zy, z. Recall that the intersection graph does not include the L variables. It is not hard to see that a valid tree-decomposition for this graph is given by Figure 1b. This tree-decomposition has size D and width N(n + m + N) - 1 (much less than the N(N + Dn + Dm) binary variables). This yields our main theorem:
Main Theorem 3.1. Let D  N be a given sample size. Then conv(S (D, , , f )) admits a linear programming formulation with the following properties:

(a) The linear program has no more than 4D (2L/ )n+m+N variables and 2D(2 (2L/ )n+m+N +1) constraints. We refer to the resulting polytope as PS .

(b) The linear program can be constructed in time O((2L/ )n+m+N D) plus the time required for O((2L/ )n+m+N ) evaluations of and f .

(c) Fix any data set (X^, Y^ ) = (x^i, y^i)iD=1 of size D, with x^i  [-1, 1]n and y^i  [-1, 1]m. There exists a face FX^,Y^ of PS such that

~  argmin
, L

1D D i=1 Li

(, L)  proj(FX^,Y^ )
, L

satisfies

1 D

D i=1

( f (x^i, ), y^i) - ( f (x^i, ~), y^i)

 2 , where   [-1, 1]N is an optimal solution to

the ERM problem (1) with input data (X^, Y^ ). This means that solving an LP using an appropriate face of

PS solves the ERM problem (1) within an additive error 2 .

(d)

aTphperofaxcime aFtXi^o,Yn^ sazrxi,sezsy

by substituting in actual data for the data-variables and is used to fixed additional variables of the LP.

x, y,

which

determine

the

Proof. The proof of part (a) follows directly from Theorem 2.5 using N = log(2L/ ) along with the tree-decomposition of Figure 1b, which implies |V(T )| + p = 2D in this case. Parts (b), (c) and (d) rely on
the explicit construction for Theorem 2.5 and they are given in Appendix D.

Observe that equivalently, by Farkas' lemma, optimizing over the face can be also achieved by modifying the objective function in a straightforward way. Also note that the number of evaluations of and f is independent of D. We would like to further point out that we can provide an interesting refinement of the theorem from above: if  has an inherent network structure (as in the case of Neural Networks) one can exploit treewidth-based sparsity of the network itself in order to obtain a smaller linear program with the same approximation guarantees as before. This allows us to reduce the exponent in the exponential term of the LP size to an expression that depends on the sparsity of the network, instead of its size. For brevity of exposition, we relegate this discussion to Appendix F.

7

Under review as a conference paper at ICLR 2019

4C

SA

4.1 F -

R LU

We consider a Deep Neural Network f : Rn  Rm with k layers given by f = Tk    · · ·  T2    T1, where  is the ReLU activation function (x) max{0, x} applied component-wise and each Ti : Rwi-1  Rwi is an affine linear function. Here w0 = n is the dimension of the input data and wk = m is the dimension of the output of the network. We write Ti(z) = Ai z + bi for i  [k] and assume Ai   1, bi   1 via normalization. Thus, if v is a node in layer i, the node computation performed in v is of the form a^T z + b^, where a^ is a row of Ai and b^ is a component of bi. Note that in this case the dimension of the parameter space  is exactly the number of edges of the network. Hence, we use N to represent the number of edges as well.
We begin with a short technical Lemma, with which we can immediately establish the following corollary.

Lemma 4.1. For every i  [k - 1]0 define Ui =

i j=0

wj.

If

z   Ui then

Ti+1(z)   Ui+1.

Corollary 4.2. If  is the class of Neural Networks with k layers, N edges, ReLU activations,
and normalized coefficients, then conv(S (D, , , f )) can be formulated via a linear program of size O((2L( )wO(k2)/ )n+m+N D), where w = maxi[k-1]0 wi and L( ) is the Lipschitz constant of (·, ·) over [-Uk, Uk ]m × [-1, 1]m. The linear program can be constructed in time O((2L( )wO(k2)/ )n+m+N D) plus the time required for O((2L( )wO(k2)/ )n+m+N ) evaluations of and f .

Proof. Proving that the architecture Lipschitz constant is L( )wO(k2) suffices. Note that all node computations take the form h(z, a, b) = zT a + b for a  [-1, 1]w and b  [-1, 1]. The only difference is made in the domain

of z, which varies from layer to layer. The 1-norm of the gradient of h is at most z 1 + a 1 + 1  z 1 + w + 1

which, in virtue of Lemma 4.1, implies that a node computation on layer i (where the weights are considered

variables as well) has Lipschitz constant at most

i j=0

w

j

+

w

+

1



i j=0

2w

j

=

2

w i +1 -1 w-1



2wi+1. On

the other hand, for (a, b) - (a , b )    and z  [-Ui, Ui], it holds that |h(z, a, b) - h(z , a , b )|  2wi+1 (z - z , a - a , b - b )   2wi+1 max{ z - z , }, which shows that the Lipschitz constants can be

multiplied layer-by-layer to obtain the overall architecture Lipschitz constant. Since ReLUs have Lipschitz

constant equal to 1, and

k i=1

2wi+1

=

wO(k2),

whenever

w



2,

we

conclude

the

architecture

Lipschitz

constant is L( )wO(k2).

The reader might have noticed that a sharper bound for the Lipschitz constant above could have been used, however we chose simpler bounds for the sake of presentation. It is worthwhile to compare the previous lemma to the following closely related result.
Theorem 4.3. (Arora et al., 2018, Theorem 4.1) Let  be the class of Neural Networks with 1 hidden layer (k = 2), convex loss function , ReLU activations and output dimension m = 1. There exists an algorithm to find a global optimum of the ERM problem in time O(2w Dnw poly(D, n, w)).
Remark 4.4. We point out a few key differences of this result with the algorithm we can obtain from solving the LP in Corollary 4.2: (a) One advantage of our result is the benign dependency on D. An algorithm that solves the training problem using our proposed LP has polynomial dependency on the data-size regardless of the architecture. (b) As we have mentioned before, our approach is able to construct an LP before seeing the data. (c) The dependency on w of our algorithm is also polynomial. To be fair, we are including an extra parameter N--the number of edges of the Neural Network--on which the size of our LP depends exponentially. (d) We are able to handle any output dimension m and any number of layers k. (e) We do not assume convexity of the loss function , which causes the resulting LP size to depend on how well behaved is in terms of its Lipschitzness. (f) The result of Arora et al. (2018) has two advantages over our result: there is no boundedness assumption on the coefficients, and they are able to provide a globally optimal solution instead of an -approximation.

8

Under review as a conference paper at ICLR 2019

4.2 R N , CNN ,
Corollary 4.2 can be directly generalized to handle other architectures as well, as the key features we used before are the acyclic structure of a standard Neural Network and the well behaved Lipschitz constant of the ReLU function. These features are present in many other architectures, and yield the following result.
Lemma 4.5. Let  denote the class of feed-forward Neural Networks with k layers, as defined in Section 2.2, N edges, affine node computations, activation functions ai : R  R with Lipschitz constant at most 1 and such that a(0) = 0, and normalized coefficients. Then conv(S (D, , , f )) can be formulated via a linear program of size O((2L( )O(k2)/ )n+m+N D), where  denotes the maximum vertex in-degree of the network and L( ) is the Lipschitz constant of (·, ·) over [-Uk, Uk]m × [-1, 1]m. The linear program can be constructed in time O((2L( )O(k2)/ )n+m+N D) plus the time required for O((2L( )O(k2)/ )n+m+N ) evaluations of and f .
Corollary 4.6. The ERM problem (1) over Deep Residual Networks (ResNets) with 1-Lipschitz activations can be solved to -optimality in time poly(, 1/ , D) whenever the network size and number of layers are fixed.
Another interesting point can be made with respect to Convolutional Neural Networks (CNN). In these, convolutional layers are included which help to significantly reduce the number of parameters involved in the neural network. From a theoretical perspective, a CNN can be obtained by simply enforcing certain parameters of a fully-connected DNN to be equal. This implies that Lemma 4.5 can also be applied to CNNs, with the key difference residing in parameter N, which is the dimension of the parameter space and does not correspond to the number of edges in a CNN. In Table 1 we provide explicit LP sizes for common architectures. These results can be directly obtained from Lemma 4.5, using the specific Lipschitz constants of the loss functions. We provide explicit computations in Appendix G.

5L

P

-T

G

In this section we will show that the ERM solutions obtained via Linear Programming generalize to the

General Risk Minimization problem. Here we show generalization as customary in stochastic optimization,

exploiting the Lipschitzness of the model to be trained; we refer the interested reader to Ahmed (2017);

Shapiro et al. (2009) for an in-depth discussion. In a first step, we further precise notation as required for

our analysis. To this end, recall that the General Risk Minimization (GRM) is defined as min GRM() min E(x,y)D [ ( f (x, ), y)], where is some loss function, f is a neural network architecture with parameter space , and (x, y)  Rn+m drawn from the distribution D. We solve the finite sum problem,

i.e., the empirical risk minimization problem min ERMX,Y ()

min 

1 D

D i=1

( f (xi, ), yi), instead,

where (X, Y ) = (xi, yi)iD=1 is an i.i.d. sample from data distribution D of size D. We will show in this section,

for any 1 >  > 0, > 0, we can choose a (reasonably small!) sample size D, so that with probability 1 -  it

holds:

GRM(¯)  min GRM() + 6 ,
 

where ¯  max ERMX,Y ()+ is an -approximate solution to ERMX,Y for i.i.d.-sampled data (X, Y )  D. As the size of the linear program that we use for training only linearly depends on the number of data points,

this also implies that we will have a linear program of reasonable size as a function of  and .

Generalization follows via an argument from stochastic optimization (see Proposition I.1) and a straightforward

discretization argument; see Appendix I for details. Let 2 = max V(x,y)D [ ( f (x, ), y)].

Theorem 5.1. [Generalization] Let ¯   be an -approximate solution to min ERMX,Y () with

> 0, i.e., ERMX,Y (¯)  min ERMX,Y () +

. If

D



42
2

log

((2 L )/ 

)N , with L

and 2

as above, then

with probability 1 -  it holds GRM(¯)  min GRM() + 6 , i.e., ¯ is a 6 -approximate solution to

min GRM().

9

Under review as a conference paper at ICLR 2019

We are ready to formulate the following corollary combining Theorem 5.1 and Main Theorem 3.1.
Corollary 5.2 (LP-based Training for General Risk Minimization). Let D be a data distribution as above. Further, let 1 >  > 0 and > 0, then there exists a linear program with the following properties:

(a) The linear program has size O

2L n+m+N

42
2

log

(2 L / 

)N

and can be constructed in time

O (2L/ )n+m+N

42
2

log

((2 L )/ 

)N

and f , where L and 2 as above.

plus the time required for O (2L/ )n+m+N evaluations of

(b) With probability (1 - ) it holds GRM(¯)  min GRM() + 6 , where ¯ is an optimal solution to the

linear

program

obtained

for

the

respective

sample

of

D

of

size

42
2

log

((2 L )/ 

)N

.

Similar corollaries hold, combining Theorem 5.1 with the respective alternative statements from Section 4. Of particular interest for what follows is the LP size in the case of a neural network with k layers with width w, which becomes

O 2L( )wO(k2)/ n+m+N 42/ 2 log((2L( )wO(k2)/ )N /) .

(7)

A closely related result regarding an approximation to the GRM problem for neural networks is provided by Goel et al. (2017) in the improper learning setting. The following corollary to (Goel et al., 2017, Corollary 4.5) can be directly obtained, rephrased to match our notation:

Theorem 5.3 (Goel et al. (2017)). There exists an algorithm that outputs ~ such that with probability 1 - ,

[fo-r2anwy,diswtr]i,bGutRioMn (D~)andmloinss

function which  GRM() + ,

is convex, L-Lipschitz in the first argument and where  is the class of neural networks with k

b bounded on hidden layers,

width w, output dimension m = 1, ReLU activations and normalized weights. The algorithm runs in time at

most

nO(1)2((L+1)wk/2k -1)k log(1/)

(8)

Remark 5.4. Besides the significant difference that we consider the proper learning setting, where we actually obtain a neural network, we point out a few key differences between Theorem 5.3 and the algorithmic version of our result when solving the LP in Corollary 5.2 of size as (7): (a) In (8), the dependency on the input dimension is better than in (7). (b) The dependency on the Lipschitz constant is significantly better in (7), although we have to point out that we are relying on the Lipschitz constant with respect to all inputs of the loss function and in a potentially larger domain. (c) The dependency on is also better in (7). (d) We are not assuming convexity of and we consider general m. (e) The dependency on k in (7) is much more benign than the one in (8), which is doubly exponential.

6C

F

We have presented a novel framework which shows that training a wide variety of neural networks can be done in time which depends polynomially on the data set size, while satisfying a predetermined arbitrary optimality tolerance. Our approach is realized by approaching training through the lens of linear programming. Moreover, we show that training using a particular data set is closely related to the face structure of a data-independent polytope. Our contributions not only improve the best known algorithmic results for neural network training with optimality/approximation guarantees, but also shed new light on (theoretical) neural network training by bringing together concepts of graph theory, polyhedral geometry, and non-convex optimization as a tool for Deep Learning. An interesting future direction is bringing these ideas to practice, by combining the empirical efficiency of classical methods (such as stochastic gradient descent) with our LP-based approach.

10

Under review as a conference paper at ICLR 2019
R
S. Ahmed. A Graduate Course on Stochastic Programming. preprint, 2017.
R. Arora, A. Basu, P. Mianjy, and A. Mukherjee. Understanding deep neural networks with rectified linear units. to appear in Proceedings of ICLR 2018, arXiv preprint arXiv:1611.01491, 2018.
A. Atserias. On digraph coloring problems and treewidth duality. European Journal of Combinatorics, 29(4): 796­820, 2008.
D. Bienstock. On embedding graphs in trees. Journal of Combinatorial Theory, Series B, 49(1):103­136, 1990.
D. Bienstock and G. Muñoz. Lp formulations for polynomial optimization problems. SIAM Journal on Optimization, 28(2):1121­1150, 2018.
A. L. Blum and R. L. Rivest. Training a 3-node neural network is np-complete. Neural Networks, 5 (1):117 ­ 127, 1992. ISSN 0893-6080. doi: https://doi.org/10.1016/S0893-6080(05)80010-3. URL http://www.sciencedirect.com/science/article/pii/S0893608005800103.
G. Braun and S. Pokutta. Extended formulations: survey and introduction. Manuscript, 2018+.
G. Braun, S. Pokutta, and D. Zink. Inapproximability of combinatorial problems via small lps and sdps. In Proceedings of the forty-seventh annual ACM symposium on Theory of computing, pages 107­116. ACM, 2015.
G. Braun, S. Fiorini, and S. Pokutta. Average case polyhedral complexity of the maximum stable set problem. Mathematical Programming, 160(1-2):407­431, 2016.
G. Calinescu, C. G. Fernandes, and B. Reed. Multicuts in unweighted graphs and digraphs with bounded degree and bounded tree-width. In Proceedings of the 6th Conference on Integer Programming and Combinatorial Optimization (IPCO). Citeseer, 1998.
M. Courbariaux, I. Hubara, D. Soudry, R. El-Yaniv, and Y. Bengio. Binarized neural networks: Training deep neural networks with weights and activations constrained to+ 1 or-1. arXiv preprint arXiv:1602.02830, 2016.
S. Goel, V. Kanade, A. Klivans, and J. Thaler. Reliably learning the relu in polynomial time. In Conference on Learning Theory, pages 1004­1042, 2017.
H. Gouk, E. Frank, B. Pfahringer, and M. Cree. Regularisation of neural networks by enforcing lipschitz continuity. arXiv preprint arXiv:1804.04368, 2018.
M. Grötschel, L. Lovász, and A. Schrijver. Geometric algorithms and combinatorial optimization, volume 2. Springer Science & Business Media, 2012.
D. J. Harvey and D. R. Wood. The treewidth of line graphs. Journal of Combinatorial Theory, Series B, 2018.
Q. Liao, B. Miranda, A. Banburski, J. Hidary, and T. Poggio. A surprising linear relationship predicts test performance in deep networks. arXiv preprint arXiv:1807.09659, 2018.
N. Robertson and P. D. Seymour. Graph minors II: Algorithmic aspects of tree-width. Journal of Algorithms, 7:309 ­ 322, 1986.
A. Shapiro, D. Dentcheva, and A. Ruszczyski. Lectures on stochastic programming: modeling and theory. SIAM, 2009.
Y. Zhang, J. D. Lee, and M. I. Jordan. l1-regularized neural networks are improperly learnable in polynomial time. In International Conference on Machine Learning, pages 993­1001, 2016.
11

Under review as a conference paper at ICLR 2019

123

12 24 46 477

45 678

23 25 57 578

(a) Graph G

(b) A tree-decomposition of G of width 2, with the sets Qt indicated inside each node of the tree.

Figure 2: Example of graph and valid tree-decomposition

AF

A.1 C

T

The concept of treewidth is an important concept in the context of solving optimization problems with `sparse' structure. An alternative definition to Definition 2.3 of treewidth that the reader might find useful is the following; recall that a chordal graph is a graph where every induced cycle has length exactly 3.
Definition A.1. An undirected graph G = (V, E) has treewidth   if there exists a chordal graph H = (V, E ) with E  E and clique number   + 1.

H in the definition above is sometimes referred to as a chordal completion of G. In Figure 2 we present an example of a graph and a valid tree-decomposition. The reader can easily verify that the conditions of Definition 2.3 are met in this example. Moreover, using Definition A.1 one can verify that the treewidth of the graph in Figure 2 is exactly 2.
Two important folklore results we use in Section C.1 and Section F are the following.
Lemma A.2. Let G be a graph with a valid tree-decomposition (T, Q) of width . Then there exists a valid tree-decomposition (T , Q ) of width at most  such that |V(T )|  O(|V(G)|).
Lemma A.3. Let G be a graph with a valid tree-decomposition (T, Q) and K  V(G) a clique of G. Then there exists t  T such that K  Qt .

A.2 P

.

An important distinction is the type of solution to the ERM that we allow. In proper learning we require the solution to satisfy   , i.e., the model has to be from the considered model class induced by  and takes the form f (·, ) for some   , with

1 D ( f (x^i, ), y^i)  min 1 D ( f (x^i, ), y^i),

D i=1

  D i=1

and this can be relaxed to -approximate (proper) learning by allowing for an additive error > 0 in the above. In contrast, in improper learning we allow for a model g(·), that cannot be obtained as f (·, ) with   , satisfying

1 D (g(x^i), y^i)  min 1 D ( f (x^i, ), y^i),

D i=1

  D i=1

with a similar approximate version. As we mentioned in the main body, this article considers the proper

learning setup.

12

Under review as a conference paper at ICLR 2019

A.3 N

N

In a Neural Network, the graph G defining the network can be partitioned in layers. This means that

V(G) = associated

k i=0
set

Vi of

for some sets Vi in-nodes denoted

--the layers by +(v)  V

of the network. , so that (w, v) 

Each vertex E for all w 

v  Vi with +(v) and an

i  [k]0 has associated set

an of

out-nodes -(v)  V defined analogously. If i = 0, then +(v) are the inputs (from data) and if i = k, then

-(v) are the outputs of the network. Moreover, each node v  V performs a node computation gi(+(v)), where gi : R|+(v)|  R with i  [k] is typically a smooth function (often these are linear or affine linear functions) and then the node activation is computed as ai(gi(+(v))), where ai : R  R with i  [k] is a

(not necessarily smooth) function (e.g., ReLU activations of the form ai(x) = max{0, x}) and the value on all out-nodes w  -(v) is set to ai(gi(+(v))) for nodes in layer i  [k]. In feed-forward networks, we can further assume that if v  Vi, then +(v)  ij-=10Vj , i.e., all arcs move forward in the layers.

BF

D - . LP
As mentioned before, the assumption that the construction of the LP is independent of the specific data is important and reasonable as it basically prevents us from constructing an LP for a specific data set, which would be akin to designing an algorithm for a specific data set in ERM problem (1). To further illustrate the point, suppose we would do the latter, then a correct algorithm would be a simple print statement of the optimal configuration ¯. Clearly this is nonsensical and we want the algorithm to work for all types of data sets as inputs. We have a similar requirement for the construction of the LP, with the only difference that number of data points D has to be known at time of construction. As such LPs more closely resemble a circuit model of computation (similar to the complexity class P/poly); see Braun et al. (2016; 2015); Braun and Pokutta (2018+) for details.
The curious reader might still wonder how our main result changes if we allow the LPs in Theorem 3.1 to be data-dependent, i.e., if we construct a specific linear program after we have seen the data set:
Remark B.1. To obtain a data-dependent linear program we can follow the same approach as in Section 3 and certainly produce an LP that will provide the same approximation guarantees for a fixed data set. Moreover, since the construction of Theorem 2.5 explained in Appendix C.1 involves an enumeration over a discretization of   [-1, 1]N , one can compute the (approximately) optimal solution in advance and solve this data-dependent ERM problem as a trivial LP with N constraints, each constraint simply fixing a variable to a value; the analog to the print statement from above. The time needed to generate such an LP is O((2L/ )N ) (the number of possible discretized configurations) via at most O((2L/ )N D) evaluations of and f (one per each enumerated configuration and data-point).
This result is not particularly insightful, as it is based on a straight-forward enumeration which takes a significant amount of time, considering that it only serves one data set. On the other hand, our result shows that by including the input data as a variable, we do not induce an exponential term in the size of the data set D and we can keep the number function evaluations to be roughly the same.

S SGD-
Our approach shares some similarities with stochastic gradient descent (SGD) based training: data points are considered separately (or in small batches) and the method (in case of SGD) or the LP (in our case) ensure that the information gained from a single data point is integrated into the overall ERM solution. In the case of SGD this happens through sequential updates of the form xt+1  xt -  fi(xt ), where i is a random function corresponding to a training data point (X^i, Y^i) from the ERM problem. In our case, it is the LP that `glues

13

Under review as a conference paper at ICLR 2019

together' solutions obtained from single training data points by means of leveraging the low treewidth. This is reflected in the linear dependence in D in the problem formulation size.

CM

Proof of Lemma 3.1. Choose binary values z~ so as to attain the approximation for variables x, y,  as in (6) and define x^, y^, ^, L^ from z~ according to the definition of S (D, , , f ). Since

(xd, yd, ) - (x^d, y^d, ^)   2 = L by Lipschitzness we obtain |Ld - L^ d |  . The result then follows.

d  [D]

Proof of Lemma 4.1. The result can be verified directly, since for a  [-1, 1]w and b  [-1, 1] it holds |zT a + b|  w z  + 1.

Proof of Lemma 4.5. The proof follows almost directly from the proof of Corollary 4.2. The two main differences are (1) the input dimension of a node computation, which can be at most  instead of w and (2) the fact that an activation function a with Lipchitz constant 1 and that a(0) = 0 satisfies |a(z)|  |z|, thus the domain of each node computation computed in Lemma 4.1 applies. The layer-by-layer argument can be applied as the network is feed-forward.

C.1 P T 2.5

Let us recall the definition of BO:

(BO) : min cT x + dT y
subject to : fi(x)  0 gj(x) = yj x  {0, 1}n,

i  [m] j  [p]

We sketch the proof of Theorem 2.5. Consider an instance I of problem BO. If [I] has a tree-decomposition (T, Q) of width , there is an exact linear programming reformulation of I with O (2 (|V(T)| + p)) variables and constraints.

Proof. Since the support of each fi induces a clique in the intersection graph, there must exist a bag Q such that supp( fi)  Q (Lemma A.3). The same holds for each gj. We modify the tree-decomposition to include the yj variables the following way:
· For each j  [p], choose a bag Q containing supp(gj) and add a new bag Q ( j) consisting of Q  {yj } and connected to Q.
· We do this for every j  [p], with a different Q ( j) for each different j. This creates a new tree-decomposition (T , Q ) of width at most  + 1, which has each variable yj contained in a single bag Q ( j) which is a leaf.
· The size of the tree-decomposition is |T | = |T | + p.

From here, we proceed as follows:

14

Under review as a conference paper at ICLR 2019

· For each t  T , if Qt yj for some j  [p], then we construct Ft {(x, y)  {0, 1}Qt × R : y = gj (x), fi(x)  0 for supp( fi)  Qt }
otherwise we simply construct Ft {x  {0, 1}Qt : fi(x)  0 for supp( fi)  Qt }.
Note that these sets have size at most 2|Qt |. · We define variables X[Y, N] where Y, N form a partition of Qt1  Qt2 . These are at most 2 |V(T )|. · For each t  T and v  Ft , we create a variable v. These are at most 2 |V(T )|.
We formulate the following linear optimization problem

(LBO) : min cT x + dT y

subject to :

v = 1
v  Ft
X[Y, N] = v vi (1 - vi)
v  Ft i Y i N
v  0

xi = vvi
v  Ft
yj = vgj(v)
v  FQ ( j)

t  T
(Y, N)  Qt, t  T v  Ft, t  T i  Qt  [n], t  T
 j  [p]

Note that the notation in the last constraint is justified since by construction supp(gj)  Q ( j). The proof of the fact that LBO is equivalent to BO follows from the arguments in Bienstock and Muñoz (2018). The key difference justifying the addition of the y variables relies in the fact that they only appear in leaves of the tree decomposition (T , Q ), and thus in no intersection of two bags. The gluing argument using variables X[Y, N] then follows directly, as it is then only needed for the x variables to be binary.

We can substitute out the x and y variables and obtain an LP whose variables are only v and X[Y, N]. This produces an LP with at most 2 · 2 |V(T )| variables and (2 · 2 + 1)|V(T )| constraints. This proves the size of the LP is O(2(|V(T)| + p)) as required.

DD -

FC

T

D.1 C

TT

3.1

In this Section we show how to construct the polytope in Theorem 3.1. We first recall the following definition:
S(D, , , f ) = {(x1, . . . , xD, y1, . . . , yD, , L)  [-1, 1](n+m)×D ×  × RD : Ld = ( f (xd, ), yd)}
and recall that S (D, , , f ) is a discretized version of the set mentioned above. From the tree-decomposition detailed in Section 3.2, we see that data-dependent variables x, y, L are partitioned in different bags for each

15

Under review as a conference paper at ICLR 2019

data d  [D]. Let us index the bags using d. Since all data variables have the same domain, the sets Fd we construct in the proof of Theorem 2.5 will be the same for all d  [D]. Using this observation, we can construct the LP as follows:
1. Fix, say, d = 1 and enumerate all binary vectors corresponding to the discretization of x1, y1, . 2. Compute ( f (x1, ), y1). This will take O((2L/ )n+m+N ) function evaluations of f and . This
defines the set F1. 3. Duplicate this set D times, and associate each copy with a bag indexed by d  [D].
4. For each d  [D], and each v  Fd create a variable v. 5. For each d  [D - 1], create variables X[Y, N] corresponding to the intersection of bags d and
d + 1. This will create O((2L/ )N ) variables, since the only variables in the intersections are the discretized  variables.
6. Formulate LBO.
The only evaluations of and f are performed in the construction of F1. As for the additional computations, the bottleneck lies in creating all  variables, which takes time O((2L/ )n+m+N D).

D.2 D -

-

Consider a fixed data set (X^, Y^ ) = (x^i, y^i)iD=1 and let  be an optimal solution to the ERM problem with input data (X^, Y^ ). Consider now binary variables zx^, zy^ to attain the approximation (6) and define x~, y~ from zx^, zy^ ,

i.e., x~id = -1 + 2

N h=1

2-h

zix^,hd

and

similarly

for

y~.

Define

the

set

S(X~, Y~, , , f ) = {(, L)   × RD : Ld = ( f (x~d, ), y~d)}

and similarly as before define S (X~, Y~, , , f ) to be the discretized version (on variables ). The following Lemma shows the quality of approximation to the ERM problem obtained using S(X~, Y~, , , f ) and subsequently S (X~, Y~, , , f ). Lemma D.1. For any (, L)  S(X~, Y~, , , f ) there exists ( , L )  S (X~, Y~, , , f ) such that

1D

1D

D d=1 Ld - D d=1 Ld 

Additionally, for every   , there exists ( , L )  S (X~, Y~, , , f ) such that

1D D

( f (x^d, ), y^d) - 1 D

D

Ld



d=1 d=1

Proof. The first inequality follows from the same proof as in Lemma 3.1. For the second inequality, let  be the binary approximation to , and L defined by Ld = ( f (x~d,  ), y~d). Since x~, y~,  are approximations to x^, y^, , by Lipschitzness we know that
| ( f (x^d, ), y^d) - Ld | = | ( f (x^d, ), y^d) - ( f (x~d,  ), y~d)|  2L =

16

Under review as a conference paper at ICLR 2019

Corollary D.2. Let (^, L^ ) defined as

(^,

L^ )



argmin
, L

1 D

D d=1

Ld

s.t (, L)  S (X~, Y~, , , f )

Then

1 D ( f (x^d, ), y^d) - 1 D ( f (x^d, ^), y^d)  2

D d=1

D d=1

Proof. Since ^  , and  is a "true" optimal solution to the ERM problem, we immediately have

1 D ( f (x^d, ), y^d)  1 D ( f (x^d, ^), y^d)

D d=1

D d=1

On the other hand, by the previous Lemma we know there exists ( , L )  S (X~, Y~, , , f ) such that

-

1D 
D d=1

( f (x^d,

),

y^ d )

-

1 D

D d=1

Ld

1D 
D d=1

(

f

(x^d,

),

y^ d )

-

1 D

D d=1

L^ d

= 1 D ( f (x^d, ), y^d) - 1 D ( f (x~d, ^), y~d)

D d=1

D d=1

1D 

( f (x^d, ), y^d) - 1

D

( f (x^d, ^), y^d) +

D d=1

D d=1

(optimality of L^ ) (Lipschitzness)

Note that since the objective is linear, the optimization problem in the previous Corollary is equivalent if we replace S (X~, Y~, , , f ) by its convex hull. Therefore the only missing link to the face property of the data-independent polytope is the following: Lemma D.3. conv(S (X~, Y~, , , f )) is a face of conv(S (D, , , f )).
Proof. The proof follows from simply fixing variables in the corresponding LBO that describes conv(S (D, , , f )). For every d  [D] and v  Fd, we simply need to make v = 0 whenever the (x, y) components of v do not correspond to X~, Y~ . We know this is well defined, since X~, Y~ are already discretized, thus there must be some v  Fd corresponding to them.
The structure of the resulting LP is the same as LBO, so the fact that it is exactly conv(S (X~, Y~, , , f )) follows. The fact that it is a face of conv(S (D, , , f )) follows from the fact that the procedure simply fixed some inequalities to be tight.
17

Under review as a conference paper at ICLR 2019

ER

ERM

A common practice to avoid over-fitting is the inclusion of regularizer terms in (1). This leads to problems of

the form

min 1 D ( f (x^i, ), y^i) +  R(),   D i=1

(11)

where R(·) is a function, typically a norm, and  > 0 is a parameter to control the strength of the regularization.

Regularization is generally used to promote generalization and discourage over-fitting of the obtained ERM

solution. The reader might notice that our arguments in Section 3 regarding the epigraph reformulation of the

ERM problem and the tree-decomposition of its intersection graph can be applied as well, since the regularizer

term does not add any extra interaction between the data-dependent variables.

The previous analysis extends immediately to the case with regularizers after appropriate modification of the architecture Lipschitz constant L to include R(·).
Definition E.1. Consider a regularized ERM problem (11) with parameters D, , , f , R, and . We define its Architecture Lipschitz Constant L(D, , , f , R, ) as

L(D, , , f , R, ) L( ( f (·, ·), ·) + R(·)) over the domain K = [-1, 1]n ×  × [-1, 1]m.

(12)

F ERM

N

S

So far we have considered general ERM problems exploiting only the structure of the ERM induced by the finite sum formulations. We will now study ERM under Network Structure, i.e., specifically ERM problems as they arise in the context of Neural Network training. We will see that in the case of Neural Networks, we can exploit the sparsity of the network itself to obtain better LP formulations of conv(S (D, , , f )).
Suppose the network is defined by a graph G, and recall that in this case,   [-1, 1]E(G). By using additional auxiliary variables s representing the node computations and activations, we can describe S(D, , , f ) in the following way:
S(D, , , f ) = (x1, . . . , xD, y1, . . . , yD, , L)  [-1, 1](n+m)D ×  × RD :
Ld = (sk,d, yd)
svi,d = av(gv(si-1,d, (+(v))) v  Vi, i  [k] s0,d = xd .
The only difference with our original description of S(D, , , f ) in (5) is that we explicitly "store" node computations in variables s. These new variables will allow us to better use the structure of G. Assumption F.1. To apply our approach in this context we need to further assume  to be the class of Neural Networks with normalized coefficients and bounded node computations. This means that we restrict to the case when s  [-1, 1]|V(G)|D.
Under Assumption F.1 we can easily derive an analog description of S (D, , , f ) using this node-based representation of S (D, , , f ). In such description we also include a binary representation of the auxiliary variables s. Let  be the intersection graph of such a formulation of S (D, , , f ) and  be the sub-graph of  induced by variables . Using a tree-decomposition (T, Q) of  we can construct a tree-decomposition of  the following way:
1. We duplicate the decomposition D times (Ti, Qi)iD=1, where each (Ti, Qi) is a copy of (T, Q).

18

Under review as a conference paper at ICLR 2019

2. We connect the trees Ti in a way that the resulting graph is a tree (e.g., they can be simply concatenated one after the other).
3. To each bag Qit with t  Ti and i  [D], we add all the data-dependent variables Ld and the binary variables associated with the discretization of xd, s·,d, and yd. This adds N(|V(G)| + n + m) additional variables to each bag, as there is only one variable s per data point per vertex of G.

It is not hard to see that this is a valid tree-decomposition of , of size |T | · D --since the bags were duplicated D times-- and width N(tw() + |V(G)| + n + m).
We now turn to providing a bound to tw(). To this end we observe the following:

1. The architecture variables  are associated to edges of G. Moreover, two variables e, f , with e, f  E appear in a common constraint if and only if there is a vertex v such that e, f  +(v).
2. This implies that  is a sub-graph of the line graph of G. Recall that the line graph of a graph G is obtained by creating a node for each edge of G and connecting two nodes whenever the respective edges share a common endpoint.

The treewidth of a line graph is related to the treewidth of the base graph (see Bienstock (1990); Calinescu et al. (1998); Atserias (2008); Harvey and Wood (2018)). More specifically, tw()  O(tw(G)(G)) where  denotes the maximum vertex degree. Addititionally, using Lemma A.2 we may assume |T |  |E(G)|, since  has at most |E(G)| nodes. Putting everything together we obtain:
Lemma F.2. If there is an underlying network structure G in the ERM problem and the node computations are bounded, then conv(S (D, , , f )) admits a linear programming formulation with no more than

2D(|E(G)| + 1) 2L O(tw(G)(G)+|V (G)|+n+m)

and

D(|E(G)| + 1)

2

2L

O(tw(G)(G)+ |V (G)|+n+m)
+1

variables and constraints, respectively. Moreover, given a tree-decomposition of the network G, the linear program can be constructed in time O D|E(G)| (2L/ )O(tw(G)(G)+|V(G)|+n+m) plus the time required for
O |E(G)| (2L/ )O(tw(G)(G)+|V(G)|+n+m) evaluations of and f .

GE

L

LF

In Section 4 we specified our results --the size of the data-independent LPs-- for feed-forward networks with

1-Lipschitz activation functions. However, we kept as a parameter L( ); the Lipschitz constant of (·, ·) over

[-Uk, Uk ]m × [-1, 1]m, with Uk =

k j=0

wj

a

valid

bound

on

the

output

of

the

node

computations,

as

proved

in Lemma 4.1. Note that Uk  wk+1.

In this Section we compute this Lipschitz constant for various common loss functions. It is important to mention that we are interested in the Lipschitznes of with respect to both the output layer and the data-dependent variables as well --not a usual consideration in the literature. Note that a bound on the Lipschitz constant L( ) is given by supz,y  (z, y) 1.

· Quadratic Loss

(z, y) =

z-y

2 2

.

In this case it is easy to see that

 (z, y) 1 = 4 z - y 1  4m(Uk + 1)  4m(wk+1 + 1)

· Absolute Loss (z, y) = z - y 1. In this case we can directly verify that the Lipschitz constant with respect to the infinity norm is at most 2m.

19

Under review as a conference paper at ICLR 2019

· Cross Entropy Loss with Soft-max Layer. In this case we include the Soft-max computation in the definition of , therefore
m
(z, y) = - yi log(S(z)i)
i=1
where S(z) is the Soft-max function defined as

S(z)i =

ezi

m j=1

ezj

.

A folklore result is



(z, y)  zi

=

S(z)i

-

yi



 (z, y)  zi

2

Additionally,



(z, y)  yi

=

- log(S(z)i)

which in principle cannot be bounded. Nonetheless, since we are interested in the domain [-Uk, Uk] of z, we obtain

S(z)i =

ezi

m j=1

ezj

 1 e-2Uk  m

 (z, y)  yi

= - log(S(z)i)  log(m) + 2Uk

which implies that L( )  2m(log(m) + 2Uk)  2m(log(m) + 2wk+1).
· Hinge Loss (z, y) = max{1 - zT x, 0}. Using a similar argument as for the Quadratic Loss, one can easily see that the Lipschitz constant with respect to the infinity norm is at most m(Uk + 1)  m(wk+1 + 1).

HB

NN

A Binarized activation unit (BiU) is parametrized by p + 1 values b, a1, . . . , ap. Upon a binary input vector z1, z2, . . . , zp the output is binary value y defined by:
y = 1 if aT z > b, and y = 0 otherwise.

Now suppose we form a network using BiUs, possibly using different values for the parameter p. In terms of the training problem we have a family of (binary) vectors x1, . . . , xD in Rn and binary labels and corresponding binary label vectors y1, . . . , yD in Rm, and as before we want to solve the ERM problem (1). Here, the parametrization  refers to a choice for the pair (a, b) at each unit. In the specific case of a network with 2 nodes in the first layer and 1 node in the second layer, and m = 1, Blum and Rivest (1992) showed that it is NP-hard to train the network so as to obtain zero loss, when n = D. Moreover, the authors argued that even if the parameters (a, b) are restricted to be in {-1, 1}, the problem remains NP-Hard. See Courbariaux et al. (2016) for an empirically efficient training algorithm for BiUs.
In this section we apply our techniques to the ERM problem (1) to obtain an exact polynomial-size dataindependent formulation for each fixed network (but arbitrary D) when the parameters (a, b) are restricted to be in {-1, 1}.
We begin by noticing that we can reformulate (1) using an epigraph formulation as in (4). Moreover, since the data points in a BiU are binary, if we keep the data points as variables, the resulting linear-objective optimization problem is a binary optimization problem as BO. This allows us to claim the following:

20

Under review as a conference paper at ICLR 2019

Theorem H.1. Consider a graph G, p  N and D  N. There exists a linear program of size
O(2p |V (G)| D),
such that any BiU ERM problem of the form (1) is equivalent to optimizing a linear function over a face of P, where P is the polytope defined by the linear program. Constructing the linear program takes time O(2p |V(G)| D) plus the time required for O(2p |V(G)|) evaluations of f and .

Proof. The result follows from applying Theorem 2.5 directly to the epigraph formulation of BiU keeping x and y as variables. In this case an approximation is not necessary. The construction time and the data-independence follow along the same arguments used in the approximate setting before.

The following corollary is immediate.
Corollary H.2. The ERM problem (1) over BiUs can be solved in polynomial time for any D, whenever p and the network structure G are fixed.

I P T 5.1

The following proposition summaries the generalization argument used in stochastic programming as presented in Ahmed (2017) (see also Shapiro et al. (2009)):
Proposition I.1. Consider the optimization problem

min E [F(x, ())] ,
x X
where () is a random parameter with    a set of parameters, X  Rn a finite set, and F : X ×   R is a function. Given i.i.d. samples 1, . . . , N of (), consider the finite sum problem

min 1 xX N

F(x, i).

i [N]

(13)

If x¯  X is an

-approximate

solution

to

(13),

i.e.,

1 N

i [N] F(x¯, i)



minx X

1 N

i[N] F(x, i) + and

N



42
2

log

|

X 

|

,

where  > 0 and 2 = maxxX V [F(x, ())], then with probability 1 -  it holds:

E [F(x¯, ())]  min E [F(x, ())] + 2 .
x X

We will now establish generalization by means of Proposition I.1 and a straightforward discretization argument. By assumption from above   [-1, 1]N for some N  N. Let     [-1, 1]N be a -net of , i.e., for all    there exists ¯   with  - ¯   . Furthermore let L the be architecture Lipschitz constant, as defined in (2) (or (12)).

Theorem 5.1. [Generalization] Let ¯   be an -approximate solution to min ERMX,Y () with

> 0, i.e., ERMX,Y (¯)  min ERMX,Y () +

. If

D



42
2

log

((2 L )/ 

)N , with L

and 2

as above, then

with probability 1 -  it holds GRM(¯)  min GRM() + 6 , i.e., ¯ is a 6 -approximate solution to

min GRM().

21

Under review as a conference paper at ICLR 2019

Proof. Let ¯ be as above. With the choice  /L, there exists ~  , so that ~ - ¯    and hence by Lipschitzness,
| ERMX,Y (¯) - ERMX,Y (~)|  ,

so that ERMX,Y (~)



min 

ERMX,Y () + 2

.

As

D



42
2

log

((2 L )/ 

)N , with probability 1 -  we have

GRM(~)  min GRM() + 4 by Proposition I.1. If now ¯G = argmin GRM() and ~G   with

¯G - ~G   , by Lipschitzness we have | GRM(¯G) - GRM(~G)|  . Now

GRM(~)  min GRM() + 4
 
 GRM(~G) + 4  GRM(¯G) + 5

(by optimality) (by Lipschitzness).

Together with | GRM(¯) - GRM(~)|  as ~ - ¯    it follows

GRM(¯)  GRM(¯G) + 6

= min GRM() + 6 ,
 

which completes the proof.

22

