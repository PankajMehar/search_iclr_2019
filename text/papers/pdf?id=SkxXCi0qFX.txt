PROMP: PROXIMAL META-POLICY SEARCH
Anonymous authors Paper under double-blind review
ABSTRACT
Credit assignment in Meta-reinforcement learning (Meta-RL) is still poorly understood. Existing methods either neglect credit assignment to pre-adaptation behavior or implement it naively. This leads to poor sample-efficiency during metatraining as well as ineffective task identification strategies. This paper provides a theoretical analysis of credit assignment in gradient-based Meta-RL. Building on the gained insights we develop a novel meta-learning algorithm that overcomes both the issue of poor credit assignment and previous difficulties in estimating meta-policy gradients. By controlling the statistical distance of both pre-adaptation and adapted policies during meta-policy search, the proposed algorithm endows efficient and stable meta-learning. Our approach leads to superior pre-adaptation policy behavior and consistently outperforms previous Meta-RL algorithms in sample-efficiency, wall-clock time, and asymptotic performance.
1 INTRODUCTION
A remarkable trait of human intelligence is the ability to adapt to new situations in the face of limited experience. In contrast, our most successful artificial agents struggle in such scenarios. While achieving impressive results, they suffer from high sample complexity in learning even a single task, fail to generalize to new situations, and require large amounts of additional data to successfully adapt to new environments. Meta-learning addresses these shortcomings by learning how to learn. Its objective is to learn an algorithm that allows the artificial agent to succeed in an unseen task when only limited experience is available, aiming to achieve the same fast adaptation that humans possess (Schmidhuber, 1987; Thrun & Pratt, 1998).
Despite recent progress, deep reinforcement learning (RL) still relies heavily on hand-crafted features and reward functions as well as engineered problem specific inductive bias. Meta-RL aims to forego such reliance by acquiring inductive bias in a data-driven manner. Recent work proves this approach to be promising, demonstrating that Meta-RL allows agents to obtain a diverse set of skills, attain better exploration strategies, and learn faster through meta-learned dynamics models or synthetic returns (Duan et al., 2016; Xu et al., 2018; Gupta et al., 2018b; Saemundsson et al., 2018).
Meta-RL is a multi-stage process in which the agent, after a few sampled environment interactions, adapts its behavior to the given task. Despite its wide utilization, little work has been done to promote theoretical understanding of this process, leaving Meta-RL grounded on unstable foundations. Although the behavior prior to the adaptation step is instrumental for task identification, the interplay between pre-adaptation sampling and posterior performance of the policy remains poorly understood. In fact, prior work in gradient-based Meta-RL has either entirely neglected credit assignment to the pre-update distribution (Finn et al., 2017) or implemented such credit assignment in a naive way (Al-Shedivat et al., 2018; Stadie et al., 2018).
To our knowledge, we provide the first formal in-depth analysis of credit assignment w.r.t. preadaptation sampling distribution in Meta-RL. Based on our findings, we develop a novel Meta-RL algorithm. First, we analyze two distinct methods for assigning credit to pre-adaptation behavior. We show that the recent formulation introduced by Al-Shedivat et al. (2018) and Stadie et al. (2018) leads to poor credit assignment, while the MAML formulation (Finn et al., 2017) potentially yields superior meta-policy updates. Second, based on insights from our formal analysis, we highlight both the importance and difficulty of proper meta-policy gradient estimates. In light of this, we propose the low variance curvature (LVC) surrogate objective which yields gradient estimates with a favorable bias-variance trade-off. Finally, building upon the LVC estimator we develop Proximal MetaPolicy Search (ProMP), an efficient and stable meta-learning algorithm for RL. In our experiments,
1

we show that ProMP consistently outperforms previous Meta-RL algorithms in sample-efficiency, wall-clock time, and asymptotic performance.
2 RELATED WORK
Meta-Learning concerns the question of "learning to learn", aiming to acquire inductive bias in a data driven manner, so that the learning process in face of unseen data or new problem settings is accelerated (Schmidhuber, 1987; Schmidhuber et al., 1997; Thrun & Pratt, 1998).
This can be achieved in various ways. One category of methods attempts to learn the "learning program" of an universal Turing machine in form of a recurrent / memory-augmented model that ingests datasets and either outputs the parameters of the trained model (Hochreiter et al., 2001; Andrychowicz et al., 2016; Chen et al., 2017; Ravi & Larochelle, 2017) or directly outputs predictions for given test inputs (Duan et al., 2016; Santoro et al., 2016; Mishra et al., 2018). Though very flexible and capable of learning very efficient adaptations, such methods lack performance guarantees and are difficult to train on long sequences that arise in Meta-RL.
Another set of methods embeds the structure of a classical learning algorithm in the meta-learning procedure, and optimizes the parameters of the embedded learner during the meta-training (Hu¨sken & Goerick, 2000; Finn et al., 2017; Nichol et al., 2018; Miconi et al., 2018). A particular instance of the latter that has proven to be particularly successful in the context of RL is gradient-based metalearning (Finn et al., 2017; Al-Shedivat et al., 2018; Stadie et al., 2018). Its objective is to learn an initialization such that after one or few steps of policy gradients the agent attains full performance on a new task. A desirable property of this approach is that even if fast adaptation fails, the agent just falls back on vanilla policy-gradients. However, as we show, previous gradient-based Meta-RL methods either neglect or perform poor credit assignment w.r.t. the pre-update sampling distribution.
A diverse set of methods building on meta-RL, has recently been introduced. This includes: learning exploration strategies (Gupta et al., 2018b), synthetic rewards (Sung et al., 2017; Xu et al., 2018), unsupervised policy acquisition (Gupta et al., 2018a), model-based RL (Clavera et al., 2018; Saemundsson et al., 2018), learning in competitive environments (Al-Shedivat et al., 2018) and meta-learning modular policies (Frans et al., 2018; Alet et al., 2018). Many of the mentioned approaches build on previous gradient-based meta-learning methods that insufficiently account for the pre-update distribution. ProMP overcomes these deficiencies, providing the necessary framework for novel applications of Meta-RL in unsolved problems.
3 BACKGROUND
Reinforcement Learning. A discrete-time finite Markov decision process (MDP), T , is defined by the tuple (S, A, p, p0, r, H). Here, S is the set of states, A the action space, p(st+1|st, at) the transition distribution, p0 represents the initial state distribution, r : S × A  R is a reward function, and H the time horizon. We omit the discount factor  in the following elaborations for notational brevity. However, it is straightforward to include it by substituting the reward by r(st, at) := tr(st, at). We define the return R( ) as the sum of rewards along a trajectory  := (s0, a0, ..., sH-1, aH-1, sH ). The goal of reinforcement learning is to find a policy (a|s) that maximizes the expected return E PT ( |) [R( )].
Meta-Reinforcement Learning goes one step further, aiming to learn a learning algorithm which is able to quickly learn the optimal policy for a task T drawn from a distribution of tasks (T ). Each task T corresponds to a different MDP. Typically, it is assumed that the distribution of tasks share the action and state space, but may differ in their reward function or their dynamics.
Gradient-based meta-learning aims to solve this problem by learning the parameters  of a policy  such that performing a single or few steps of vanilla policy gradient (VPG) with the given task leads to the optimal policy for that task. This meta-learning formulation, also known under the name of MAML, was first introduced by Finn et al. (2017). We refer to it as formulation I which can be expressed as maximizing the objective
J I () = ET (T ) E PT ( | ) [R( )] with  := U (, T ) =  + E PT ( |) [R( )]
In that U denotes the update function which depends on the task T , and performs one VPG step towards maximizing the performance of the policy in T . For national brevity and conciseness we
2

assume a single policy gradient adaptation step. Nonetheless, all presented concepts can easily be extended to multiple adaptation steps.

Later work proposes a slightly different notion of gradient-based meta-RL, also known as E-MAML, that attempts to circumvent issues with the meta-gradient estimation in MAML (Al-Shedivat et al., 2018; Stadie et al., 2018):

J II () = ET (T ) E 1:N PT ( 1:N |) R( )
 PT ( | )

N

with  := U (,  1:N ) =  + 

R( (n))

n=1

Formulation II views U as a deterministic function that depends on N sampled trajectories from a specific task. In contrast to formulation I, the expectation over pre-update trajectories  is applied outside of the update function. Throughout this paper we refer to  as pre-update policy, and  as post-update policy.

4 SAMPLING DISTRIBUTION CREDIT ASSIGNMENT
This section analyzes the two gradient-based Meta-RL formulations introduced in Section 3. Figure 1 illustrates the stochastic computation graphs (Schulman et al., 2015b) of both formulations. The red arrows depict how credit assignment w.r.t the pre-update sampling distribution PT ( |) is propagated. Formulation I (left) propagates the credit assignment through the update step, thereby exploiting the full problem structure. In contrast, formulation II (right) neglects the inherent structure, directly assigning credit from post-update return R to the pre-update policy  which leads to noisier, less effective credit assignment.

Figure 1: Stochastic computation graphs of meta-learning formulation I (left) and formulation II (right). The red arrows illustrate the credit assignment from the post-update returns R to the pre-update policy  through Jpre. (Deterministic nodes: Square; Stochastic nodes: Circle)
Both formulations optimize for the same objective, and are equivalent at the 0th order. However, because of the difference in their formulation and stochastic computation graph, their gradients and the resulting optimization step differs. In the following, we shed light on how and where formulation II loses signal by analyzing the gradients of both formulations, which can be written as (see Appendix A for more details and derivations)

J () = ET (T ) E  PT ( |) Jpost( ,  ) + Jpre( ,  )
 PT ( | )

(1)

The first term Jpost( ,  ) is equal in both formulations, but the second term, Jpre( ,  ), differs between them. In particular, they correspond to

Jpost( ,  ) = I + R( )2 log  ( ))  log ( )R( )

(2)

transformation from  to 
JpIrIe( ,  ) =  log ( )R( )

 J outer

(3)

JpIre( ,  ) =  log ( ) ( log ( )R( )) ( log  ( )R( ))

(4)

 J inner

 J outer

Jpost( ,  ) simply corresponds to a policy gradient step on the post-update policy  w.r.t  , followed by a linear transformation from post- to pre-update parameters. It corresponds to increasing the likelihood of the trajectories  that led to higher returns. However, this term does not optimize for the pre-update sampling distribution, i.e., which trajectories  led to better adaptation steps.

The credit assignment w.r.t. the pre-updated sampling distribution is carried out by the second term. In formulation II, JpIrIe can be viewed as standard reinforcement learning on  with R( ) as

3

reward signal, treating the update function U as part of the unknown dynamics of the system. This shifts the pre-update sampling distribution to better adaptation steps.
Formulation I takes the causal dependence of PT ( | ) on PT ( |) into account. It does so by maximizing the inner product of pre-update and post-update policy gradients (see Eq. 4). This steers the pre-update policy towards 1) larger post-updates returns 2) larger adaptation steps Jinner, 3) better alignment of pre- and post-update policy gradients (Li et al., 2017; Nichol et al., 2018). When combined, these effects directly optimize for adaptation. As a result, we expect the first meta-policy gradient formulation, JI , to yield superior learning properties.

5 LOW VARIANCE CURVATURE ESTIMATOR

In the previous section we show that the formulation introduced by Finn et al. (2017) results in superior meta-gradient updates, which should in principle lead to improved convergence properties. However, obtaining correct and low variance estimates of the respective meta-gradients proves challenging. As discussed by Foerster et al. (2018), and shown in Appendix B.3, the score function surrogate objective approach is ill suited for calculating higher order derivatives via automatic differentiation toolboxes. This important fact was overlooked in the original RL-MAML implementation (Finn et al., 2017) leading to incorrect meta-gradient estimates1. But, even when properly implemented, we show that these gradients exhibit high variance.

Specifically, the estimation of the hessian of the RL-objective, which is inherent in the metagradients, requires special consideration. In this section, we motivate and introduce the low variance curvature estimator (LVC): an improved estimator for the hessian of the RL-objective which promotes better meta-policy gradient updates. As we show in Appendix A.1, we can write the gradient of the meta-learning objective as

J I () = ET (T ) E PT ( | )  log PT ( | )R( )U (, T )

(5)

Since the update function U resembles a policy gradient step, its gradient U (, T ) involves computing the hessian of the reinforcement learning objective, i.e., 2 EPT ( |) [R( )]. Estimating this hessian has been discussed in Baxter & Bartlett (2001) and Furmston et al. (2016). In the infi-
nite horizon MDP case, Baxter & Bartlett (2001) derived a decomposition of the hessian. We extend
their finding to the finite horizon case, showing that the hessian can be decomposed into three matrix
terms (see Appendix B.2 for proof):

U (, T ) = I + 2 E PT ( |) [R( )] = I +  H1 + H2 + H12 + H12 whereby

(6)

H1 = E PT ( |) H2 = E PT ( |) H12 = E PT ( |)

H -1

 log (at, st) log (at, st)

t=0

H -1

H -1

2 log (at, st)

r(st , at )

t=0 t =t

H -1
 log (at, st)Qt  (st, at)

t=0

H -1
r(st , at )
t =t

Here Qt (st, at) = E t+1:H-1PT (·|)

H -1 t =t

r(st

,

at

)|st,

at

denotes the expected state-action

value function under policy  at time t.

Computing the expectation of the RL-objective is in general intractable. Typically, its gradients are computed with a Monte Carlo estimate based on the policy gradient theorem (Eq. 82). In practical implementations, such an estimate is obtained by automatically differentiating a surrogate objective (Schulman et al., 2015b). However, this results in a highly biased hessian estimate which just computes H2, entirely dropping the terms H1 and H12+H12. In the notation of the previous section, it leads to neglecting the Jpre term, ignoring the influence of the pre-update sampling distribution.

1Note that MAML is theoretically sound, but does not attend to correctly estimating the meta-policy gradients. As consequence, the gradients in the corresponding implementation do not comply with the theory.

4

The issue can be overcome using the DiCE formulation, which allows to compute unbiased higherorder Monte Carlos estimates of arbitrary stochastic computation graphs (Foerster et al., 2018). The DiCE-RL objective can be rewritten as follows

H -1
J DiCE( ) =
t=0

t (at |st ) t =0 ((at |st ))

r(st, at)

  PT ( )

E PT ( |) 2J DiCE( ) = H1 + H2 + H12 + H12

(7) (8)

In that,  denotes the "stop gradient" operator, i.e., (f(x))  f(x) but (f(x))  0. The sequential dependence of (at|st) within the trajectory, manifesting itself through the product of importance weights in (7), results in high variance estimates of the hessian 2 E PT ( |) [R( )]. As noted by Furmston et al. (2016), H12 is particularly difficult to estimate, since it involves three nested sums along the trajectory. In section 7.2 we empirically show that the high variance estimates
of the DiCE objective lead to noisy meta-policy gradients and poor learning performance.

To facilitate a sample efficient meta-learning, we introduce the low variance curvature (LVC) estimator:

H -1
J LVC( ) =

 (at |st )

t=0 ((at|st))

H -1
r(st , at )
t =t

E PT ( |) 2J LVC( ) = H1 + H2

  PT ( )

(9) (10)

By removing the sequential dependence of (at|st) within trajectories, the hessian estimate ne-

glects the term H12 + H12 which leads to a variance reduction, but makes the estimate biased. The

choice of this objective function is motivated by findings in Furmston et al. (2016): under certain

conditions the term H12 as   . Hence, the

+ H12 vanishes around local optima bias of the LVC estimator becomes

, i.e., E negligible

[2 J close

LVC]  E [2J to local optima.

DiCE] The

experiments in section 7.2 underpin the theoretical findings, showing that the low variance hessian

estimates obtained through JLVC improve the sample-efficiency of meta-learning by a significant

margin when compared to JDiCE. We refer the interested reader to Appendix B for derivations and a

more detailed discussion.

6 PROMP: PROXIMAL META-POLICY SEARCH

Building on the previous sections, we develop a novel meta-policy search method based on the low variance curvature objective which aims to solve the following optimization problem:

max


ET (T ) E PT ( | ) [R( )]

with  :=  +  E PT ( |) J LVC( ) (11)

Prior work has optimized this objective using either vanilla policy gradient (VPG) or TRPO (Schulman et al., 2015a). TRPO holds the promise to be more data efficient and stable during the learning process when compared to VPG. However, it requires computing the Fisher information matrix (FIM). Estimating the FIM is particularly problematic in the meta-learning set up. The meta-policy gradients already involve second order derivatives; as a result, the time complexity of the FIM estimate is cubic in the number of policy parameters. Typically, the problem is circumvented using finite difference methods, which introduce further approximation errors.

The recently introduced PPO algorithm (Schulman et al., 2017) achieves comparable results to TRPO with the advantage of being a first order method. PPO uses a surrogate clipping objective which allows it to safely take multiple gradient steps without re-sampling trajectories.

JCTLIP() = E PT ( ,o)

H -1 t=0

min

 (at|st) o (at|st)

Ao

(st,

at)

,

clip11+-

 (at|st) o (at|st)

Ao (st, at)

In case of Meta-RL, it does not suffice to just replace the post-update reward objective with JTCLIP. In order to safely perform multiple meta-gradient steps based on the same sampled data from a recent policy o , we also need to 1) account for changes in the pre-update action distribution (at|st), and 2) bound changes in the pre-update state visitation distribution (Kakade & Langford, 2002).
We propose Proximal Meta-Policy Search (ProMP) which incorporates both the benefits of proximal policy optimization and the low variance curvature objective (see Alg. 1.) In order to comply with

5

Algorithm 1 Proximal Meta-Policy Search (ProMP)
Require: Task distribution , step sizes , , KL-penalty coefficient , clipping range
1: Randomly initialize 
2: while  not converged do 3: Sample batch of tasks Ti  (T ) 4: for step n = 0, ..., N - 1 do
5: if n = 0 then 6: Set o   7: for all Ti  (T ) do 8: Sample pre-update trajectories Di = {i} from Ti using  9: Compute adapted parameters o,i   +  JTLiR() with Di = {i} 10: Sample post-update trajectories D i = {i } from Ti using o,i 11: Update    +  Ti JTPiroMP() using each Di = {i }

requirement

1),

ProMP

replaces

the

"stop

gradient"

importance

weight

 (at|st) ( (at|st))

by

the

likelihood

ratio

, (at|st)
o (at|st))

which

results

in

the

following

objective

JTLR() = E PT ( ,o)

H -1 t=0

(at|st) Ao o (at|st)

(st,

at)

(12)

An important feature of this objective is that its derivatives evaluated at o are identical to those of the LVC objective. To satisfy condition 2) we extend the clipped meta-objective with a KL-penalty
term between  and o . This KL-penalty term enforces a soft local "trust region" around o , preventing the shift in state visitation distribution to become large during optimization. This enables
us to take multiple meta-policy gradient steps without re-sampling. Altogether, ProMP optimizes

JTProMP() = JTCLIP( ) - D¯KL(o , ) s.t.  =  +  JTLR() , T  (T ) (13)

ProMP consolidates the insights developed throughout the course of this paper, while at the same time making maximal use of recently developed policy gradients algorithms. First, its meta-learning formulation exploits the full structural knowledge of gradient-based meta-learning. Second, it incorporates a low variance estimate of the RL-objective hessian. Third, ProMP controls the statistical distance of both pre- and post-adaptation policies, promoting efficient and stable meta-learning. All in all, ProMP consistently outperforms previous gradient-based meta-RL algorithms in sample complexity, wall clock time, and asymptotic performance (see Section 7.1).

7 EXPERIMENTS
In order to empirically validate the theoretical arguments outlined above, this section provides a detailed experimental analysis that aims to answer the following questions: (i) How does ProMP perform against previous Meta-RL algorithms? (ii) How do the lower variance but biased LVC gradient estimates compare to the high variance, unbiased DiCE estimates? (iii) Do the different formulations result in different pre-update exploration properties? (iv) How do formulation I and formulation II differ in their meta-gradient estimates and convergence properties?
To answer the posed questions, we evaluate our approach on six continuous control Meta-RL benchmark environments based on OpenAI Gym and the Mujoco simulator (Brockman et al., 2016; Todorov et al., 2012). A description of the experimental setup is found in Appendix D. In all experiments, the reported curves are averaged over at least three random seeds. Returns are estimated based on sampled trajectories from the adapted post-update policies and averaged over sampled tasks. The source code and the experiments data are available on our supplementary website.2
7.1 META-GRADIENT BASED COMPARISON
We compare our method, ProMP, in sample complexity and asymptotic performance to four other gradient-based approaches: TRPO-MAML (Finn et al., 2017), E-MAML-TRPO, E-MAMLVPG (Stadie et al., 2018), and LVC-VPG, an ablated version of our method that uses the LVC
2https://sites.google.com/view/pro-mp

6

objective in the adaptation step and meta-optimizes with vanilla policy gradient. These algorithms are benchmarked on six different locomotion tasks that require adaptation: the ant must learn to run in different directions in the 2D-plane, the half-cheetah and walker must switch between running forward and backward, the walker and hopper have to adapt to different configuration of their dynamics. Finally, we present how these algorithms perform in a high-dimensional environment, where a humanoid has to adapt to run in different directions.

Average return

HalfCheetahFwdBack

300 180

250 160

200 150

140

100 120

50 100

00.00 0.25 T0i.m50este0p.s75 1.00 1e8
WalkerFwdBack

0.0

350 600 300

250 500 200 150 400

100 50

300

0.00 0.25 0.50 0.75 1.00 1e8 0.0

ProMP (ours)

MAML

AntRandDir

300 250 200 150 100 50

1.5 3.0 4.51e7 0.0

HumanoidRandDir

350

300

250

200

150

100

50

0.8 1.6 2.4
E-MAML-TRPO

1e38.2 00.0
LVC-VPG

HopperRandParams

0.4 0.8 1.2 1e18.6
WalkerRandParams

0.4 0.8 1.2
E-MAML-VPG

1e18.6

Figure 2: Meta-learning curves of ProMP and four other gradient-based meta-learning algorithms in six different Mujoco environments. ProMP outperforms previous work in all the the environments.

The results, shown in Figure 2, highlight the strength of ProMP in terms of sample efficiency and asymptotic performance. They also demonstrate the positive effect of the LVC objective: LVC-VPG, even though optimized with vanilla policy gradient, is often able to achieve comparable results to the the prior methods that are optimized with TRPO. When compared to E-MAML-VPG, LVC proves strictly superior in performance which underpins the soundness of the theory developed throughout this paper. Results for four additional environments are displayed in Appendix D along with hyperparameter settings, environment specifications and a wall-clock time comparison of the algorithms.

7.2 ESTIMATOR VARIANCE AND ITS EFFECT ON META-LEARNING

In Section 5 we discussed how the DiCE formulation yields unbiased but high variance estimates of the RL-objective hessian and served as motivation for the low variance curvature (LVC) estimator. Here we investigate the meta-gradient variance of both estimators as well as its implication on the learning performance. Specifically, we report the relative standard deviation of the meta-policy gradients as well as the average return throughout the learning process in the HalfCheetahFwdBack environment. The results, depicted in Figure 3, highlight the advantage of the low variance curvature estimate. The trajectory level dependencies inherent in the DiCE estimator lead to a metagradient standard deviation that is on average two times higher when compared to LVC. As the learning curves indicate, the noisy gradients impede sample efficient meta-learning in case of DiCE. Meta-policy search based on the LVC estimator leads to substantially better learning properties.

Average Return

Relative Std

Gradient Variance
40

20

00.0 1T.5iRmeetustre3np.0s 41.e57

200 100
0 0.0

1T.5ime ste3p.0s 41.e57 LVC DiCE

7.3 COMPARISON OF INITIAL SAMPLING DISTRIBUTIONS
Here we evaluate the effect of the different objectives on the learned pre-update sampling distribution. We compare the low variance curvature (LVC) estimator with TRPO (LVC-TRPO)

Figure 3: Upper: Relative standard deviation of meta-policy gradients. Lower: Return in the HalfCheetahFwdBack environment.

7

against MAML (Finn et al., 2017) and E-MAML-TRPO (Stadie et al., 2018) in a 2D environment on which the exploration behavior can be visualized. Each task of this environment corresponds to reaching a different corner location; however, the 2D agent only experiences reward when it is sufficiently close to the corner (translucent regions of Figure 4). Thus, to successfully identify the task, the agent must explore the different regions. We perform three inner adaptation steps on each task, allowing the agent to fully change its behavior from exploration to exploitation.

LVC
2

MAML
2

E-MAML
2

111 000 111

Pre-update Post-update

2 2 10 1 2

2 2 10 1 2

2 2 10 1 2

Figure 4: Exploration patterns of the pre-update policy and exploitation post-update with different update functions. Through its superior credit assignment, the LVC objective learns a pre-update policy that is able to identify the current task and respectively adapt its policy, successfully reaching the goal (dark green circle).

The different exploration-exploitation strategies are displayed in Figure 4. Since the MAML implementation does not assign credit to the pre-update sampling trajectory, it is unable to learn a sound exploration strategy for task identification and thus fails to accomplish the task. On the other hand, E-MAML, which corresponds to formulation II, learns to explore in long but random paths: because it can only assign credit to batches of pre-update trajectories, there is no notion of which actions in particular facilitate good task adaptation. As consequence the adapted policy slightly misses the task-specific target. The LVC estimator, instead, learns a consistent pattern of exploration, visiting each of the four regions, which it harnesses to fully solve the task.

7.4 GRADIENT UPDATE DIRECTIONS OF THE TWO META-RL FORMULATIONS

To shed more light on the differences of the gradients of formulation I and formulation II, we evaluate the meta-gradient updates and the corresponding convergence to the optimum of both formulations in a simple 1D environment. In this environment, the agent starts in a random position in the real line and has to reach a goal located at the position 1 or -1. In order to visualize the convergence, we parameterize the policy with only two parameters 0 and 1. We employ formulation I by optimizing the DiCE objective with VPG, and formulation II by optimizing its (E-MAML) objective with VPG.

Figure 5 depicts meta-gradient updates of the parameters i for both formulations. Formulation I (red) exploits the internal structure of the adaptation update yielding faster and steadier convergence to the optimum. Due to its inferior credit assignment, formulation II (green) produces noisier gradient estimates leading to worse convergence properties.

Figure 5: Meta-gradient updates of policy parameters 0 and 1 in a 1D environment w.r.t Formulation I (red) and Formulation II (green).

8 CONCLUSION
In this paper we propose a novel Meta-RL algorithm, proximal meta-policy search (ProMP), which fully optimizes for the pre-update sampling distribution leading to effective task identification. Our method is the result of a theoretical analysis of gradient-based Meta-RL formulations, based on which we develop the low variance curvature (LVC) surrogate objective that produces low variance meta-policy gradient estimates. Experimental results demonstrate that our approach surpasses previous meta-reinforcement learning approaches in a diverse set of continuous control tasks. Finally, we underpin our theoretical contributions with illustrative examples which further justify the soundness and effectiveness of our method.

8

REFERENCES
Joshua Achiam, David Held, Aviv Tamar, and Pieter Abbeel. Constrained Policy Optimization. Technical report, 2017. URL https://arxiv.org/pdf/1705.10528.pdf.
Maruan Al-Shedivat, Trapit Bansal, Umass Amherst, Yura Burda, Openai Ilya, Sutskever Openai, Igor Mordatch Openai, and Pieter Abbeel. Continuous Adaptation via Meta-Learning in Nonstationary and Competitive Environments. In ICLR, 2018. URL https://goo.gl/tboqaN.
Ferran Alet, Toms Lozano-Pe´rez, and Leslie P. Kaelbling. Modular meta-learning. Technical report, 6 2018. URL http://arxiv.org/abs/1806.10166.
Marcin Andrychowicz, Misha Denil, Sergio Gmez Colmenarejo, Matthew W Hoffman, David Pfau, Tom Schaul, Brendan Shillingford, and Nando De Freitas. Learning to learn by gradient descent by gradient descent. Technical report, 2016. URL https://arxiv.org/pdf/1606. 04474.pdf.
Jonathan Baxter and Peter L Bartlett. Infinite-Horizon Policy-Gradient Estimation. Technical report, 2001. URL https://arxiv.org/pdf/1106.0665.pdf.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and Wojciech Zaremba. OpenAI Gym. Technical report, 6 2016. URL http://arxiv.org/ abs/1606.01540.
Yutian Chen, Matthew W Hoffman, Sergio Gmez Colmenarejo, Misha Denil, Timothy P Lillicrap, Matt Botvinick, and Nando De Freitas. Learning to Learn without Gradient Descent by Gradient Descent. In ICML, 2017.
Ignasi Clavera, Jonas Rothfuss, John Schulman, Yasuhiro Fujita, Tamim Asfour, and Pieter Abbeel. Model-Based Reinforcement Learning via Meta-Policy Optimization. In CoRL, 2018. URL http://arxiv.org/abs/1809.05214.
Yan Duan, John Schulman, Xi Chen, Peter L. Bartlett, Ilya Sutskever, and Pieter Abbeel. RL$^2$: Fast Reinforcement Learning via Slow Reinforcement Learning. CoRR, abs/1611.0:1­14, 2016. ISSN 0004-6361. doi: 10.1051/0004-6361/201527329. URL http://arxiv.org/abs/ 1611.02779.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In ICML, 2017.
Jakob Foerster, Gregory Farquhar, Maruan Al-Shedivat, Tim Rockta¨schel, Eric P Xing, and Shimon Whiteson. DiCE: The Infinitely Differentiable Monte Carlo Estimator. In ICML, 2018. URL https://goo.gl/xkkGxN.
Kevin Frans, Jonathan Ho, Xi Chen, Pieter Abbeel, and John Schulman. Meta Learning Shared Hierarchies. In ICLR, 10 2018. URL http://arxiv.org/abs/1710.09767.
Thomas Furmston, Guy Lever, David Barber, and Joelle Pineau. Approximate Newton Methods for Policy Search in Markov Decision Processes. Technical report, 2016. URL http://jmlr. org/papers/volume17/15-414/15-414.pdf.
Abhishek Gupta, Benjamin Eysenbach, Chelsea Finn, and Sergey Levine. Unsupervised MetaLearning for Reinforcement Learning. In ICML, 2018a.
Abhishek Gupta, Russell Mendonca, Yuxuan Liu, Pieter Abbeel, and Sergey Levine. MetaReinforcement Learning of Structured Exploration Strategies. In ICML, 2018b. URL https: //arxiv.org/pdf/1802.07245.pdf.
Sepp Hochreiter, A. Steven Younger, and Peter R. Conwell. Learning To Learn Using Gradient Descent. In ICANN, pp. 87­94, 2001. URL http://citeseerx.ist.psu.edu/viewdoc/ summary?doi=10.1.1.5.323.
9

Michael Hu¨sken and Christian Goerick. Fast learning for problem classes using knowledge based network initialization. In IJCNN. IEEE Computer Society Press, 2000. URL http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.31. 9720&rep=rep1&type=pdf.
Sham Kakade and John Langford. Approximately Optimal Approximate Reinforcement Learning. In ICML, 2002. URL https://people.eecs.berkeley.edu/~pabbeel/ cs287-fa09/readings/KakadeLangford-icml2002.pdf.
Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M Hospedales. Learning to Generalize: MetaLearning for Domain Generalization. In AAAI, 2017. URL www.aaai.org.
Thomas Miconi, Jeff Clune, and Kenneth O. Stanley. Differentiable plasticity: training plastic neural networks with backpropagation. In ICML, 4 2018. URL https://arxiv.org/abs/1804. 02464.
Nikhil Mishra, Mostafa Rohaninejad, Xi Chen, and Pieter Abbeel. A Simple Neural Attentive MetaLearner. In ICLR, 7 2018. URL http://arxiv.org/abs/1707.03141.
Alex Nichol, Joshua Achiam, and John Schulman. On First-Order Meta-Learning Algorithms. Technical report, 2018. URL http://arxiv.org/abs/1803.02999.
Jan Peters and Stefan Schaal. Policy Gradient Methods for Robotics. In 2006 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 2219­2225. IEEE, 10 2006. ISBN 1-4244-0258-1. doi: 10.1109/IROS.2006.282564. URL http://ieeexplore.ieee.org/ document/4058714/.
Sachin Ravi and Hugo Larochelle. Optimization as a Model for Few-Shot Learning. In ICLR, 11 2017. URL https://openreview.net/forum?id=rJY0-Kcll.
Steindr Saemundsson, Katja Hofmann, and Marc Peter Deisenroth. Meta Reinforcement Learning with Latent Variable Gaussian Processes. In UAI, 2018. URL https://arxiv.org/pdf/ 1803.07551.pdf.
Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, Timothy Lillicrap, and Google Deepmind. Meta-Learning with Memory-Augmented Neural Networks. In ICML, 2016. URL http://proceedings.mlr.press/v48/santoro16.pdf.
Juergen Schmidhuber. Evolutionary principles in self-referential learning. On learning how to learn: The meta-meta-... hook. PhD thesis, Technische Universitaet Munchen, 1987. URL http: //people.idsia.ch/~juergen/diploma.html.
Jrgen Schmidhuber, Jieyu Zhao, and Marco Wiering. Shifting Inductive Bias with Success-Story Algorithm, Adaptive Levin Search, and Incremental Self-Improvement. Machine Learning, 28 (1):105­130, 1997. ISSN 08856125. doi: 10.1023/A:1007383707642. URL http://link. springer.com/10.1023/A:1007383707642.
John Schulman, Nicolas Heess, Theophane Weber, and Pieter Abbeel. Gradient Estimation Using Stochastic Computation Graphs. In NIPS, 2015a. URL https://arxiv.org/pdf/1506. 05254.pdf.
John Schulman, Sergey Levine, Philipp Moritz, Michael I. Jordan, and Pieter Abbeel. Trust Region Policy Optimization. ICML, 2015b. ISSN 2158-3226. doi: 10.1063/1.4927398. URL http: //arxiv.org/abs/1502.05477.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov Openai. Proximal Policy Optimization Algorithms. CoRR, 2017. URL https://arxiv.org/pdf/1707. 06347.pdf.
Bradly C Stadie, Ge Yang, Rein Houthooft, Xi Chen, Yan Duan, Yuhuai Wu, Pieter Abbeel, and Ilya Sutskever. Some Considerations on Learning to Explore via Meta-Reinforcement Learning. Technical report, 2018. URL https://arxiv.org/pdf/1803.01118.pdf.
10

Flood Sung, Li Zhang, Tao Xiang, Timothy Hospedales, and Yongxin Yang. Learning to Learn: Meta-Critic Networks for Sample Efficient Learning. Technical report, 6 2017. URL http: //arxiv.org/abs/1706.09529.
Richard S. Sutton, David Mcallester, Satinder Singh, and Yishay Mansour. Policy Gradient Methods for Reinforcement Learning with Function Approximation. In NIPS, 2000. ISBN 0-262-19450-3. doi: 10.1.1.37.9714.
Sebastian Thrun and Lorien Pratt. Learning to learn. 1998. ISBN 0792380479. URL https: //dl.acm.org/citation.cfm?id=296639.
Emanuel Todorov, Tom Erez, and Yuval Tassa. MuJoCo: A physics engine for model-based control. In IROS, pp. 5026­5033. IEEE, 10 2012. ISBN 978-1-4673-1736-8. doi: 10.1109/IROS.2012. 6386109. URL http://ieeexplore.ieee.org/document/6386109/.
Zhongwen Xu, Hado van Hasselt, and David Silver. Meta-Gradient Reinforcement Learning. Technical report, 5 2018. URL http://arxiv.org/abs/1805.09801.
11

A TWO META-POLICY GRADIENT FORMULATIONS

In this section we discuss two different gradient-based meta-learning formulations, derive their gradients and analyze the differences between them.

A.1 META-POLICY GRADIENT FORMULATION I

The first meta-learning formulation, known as MAML (Finn et al., 2017), views the inner update rule U (, T ) as a mapping from the pre-update parameter  and the task T to an adapted policy parameter
 . The update function can be viewed as stand-alone procedure that encapsulates sampling from the task-specific trajectory distribution PT ( |) and updating the policy parameters. Building on this concept, the meta-objective can be written as

J I () = ET (T ) E PT ( | ) [R( )] The task-specific gradients follow as

with  := U (, T )

(14)

JTI () = E PT ( | ) [R( )] = E PT ( | ) [ log PT ( | )R( )] = E PT ( | ) [ log PT ( | )R( ) ]

(15) (16) (17)

In order to derive the gradients of the inner update  = U (, T ) it is necessary to know the structure of U . The main part of this paper assumes the inner update rule to be a policy gradient
descent step

U (, T ) =   +  E PT ( |) [R( )] = I + 2 E PT ( |) [R( )]

(18) (19)

Thereby the second term in (19) is the local curvature (hessian) of the inner adaptation objective function. The correct hessian of the inner objective can be derived as follows:

2 E PT ( |) [R( )] =  E PT ( |) [ log ( )R( )]

(20)

=  PT ( |) log ( )R( )d

(21)

= PT ( |) log ( ) log( ) R( )+
PT ( |)2 log ( )R( )d = E PT ( |) R( ) 2 log ( ) +  log ( ) log( )

(22)
(23) (24)

A.2 META-POLICY GRADIENT FORMULATION II
The second meta-reinforcement learning formulation views the the inner update  = U (,  1:N ) as a deterministic function of the pre-update policy parameters  and N trajectories  1:N  PT ( 1:N |) sampled from the pre-update trajectory distribution. This formulation was introduced in Al-Shedivat et al. (2018) and further discussed with respect to its exploration properties in Stadie et al. (2018).
Viewing U as a function that adapts the policy parameters  to a specific task T given policy rollouts in this task, the corresponding meta-learning objective can be written as

J II () = ET (T ) E 1:N PT ( 1:N |) E PT ( | ) R( )

with  := U (,  1:N ) (25)

Since the first part of the gradient derivation is agnostic to the inner update rule U (,  1:N ), we only
assume that the inner update function U is differentiable w.r.t. . First we rewrite the meta-objective J() as expectation of task specific objectives JTII () under the task distribution. This allows us to express the meta-policy gradients as expectation of task-specific gradients:

J II () = ET (T ) JTII ()

(26)

12

The task specific gradients can be calculated as follows

JTII () = E PT ( 1:N |) E PT ( | ) R( )

= 

R( ) PT ( | ) PT ( 1:N |) d d

= R( ) PT ( | )  log PT ( 1:N |)PT ( 1:N |)+

R( )  log PT ( | )PT ( | ) PT ( 1:N |) d d

N

= E 1:N PT ( 1:N |) R( )  log PT ( | ) +

 log PT ( (n)|)

 PT ( | )

i=1

N

= E 1:N PT ( 1:N |) R( )  log PT ( | ) +

 log PT ( (n)|)

 PT ( | )

n=1

As in A.1 the structure of U (,  1:N ) must be known in order to derive the gradient  . Since we assume the inner update to be vanilla policy gradient, the respective gradient follows as

U (,  1:N ) = + 1 N

N

 log ( (n)))R( (n))

with

H -1
 log ( ) =  log (at|st)

n=1

t=0

The respective gradient of U (,  1:N ) follows as

U (,  1:N ) = 

1 +
N

N

 log ( (n)))R( (n))

n=1

1 = I +
N

N

2 log ( (n)))R( (n))

n=1

(27) (28)

A.3 COMPARING THE GRADIENTS OF THE TWO FORMULATIONS

In the following we analyze the differences between the gradients derived for the two formulations.
To do so, we begin with JTI () by inserting the gradient of the inner adaptation step (19) into (17):

JTI () = E PT ( | )  log PT ( | )R( ) I + 2 E PT ( |) [R( )]

(29)

We can substitute the hessian of the inner objective by its derived expression from (24) and then

rearrange the terms. Also note that  log PT ( |) =  log ( ) =

H -1 t=1

log



(at

|st

)

where

H is the MDP horizon.

JTI () = E PT ( | )  log PT ( | )R( ) I + E PT ( |) [R( )

(30)

2 log ( ) +  log ( ) log( ) 

(31)

 = E  PT ( |)  log  ( )R( ) I + R( )2 log ( )
 PT ( | ) 
 Jpost( , )

(32) 

+

log  ( )R( )R( ) log ( ) log( )

 

(33)

 JpIre( , )

13

Next, we rearrange the gradient of JII into a similar form as JTI (). For that, we start by inserting (28) for  and replacing the expectation over pre-update trajectories  1:N by the expectation over a single trajectory  .

JTI () =

E  PT ( |) R( ) log ( ) I + R( )2 log ( ))

 PT ( | )

 Jpost( , )

(34)

+R( ) log ( )

(35)

 JpIre( , )
While the first part of the gradients match ((32) and (34)), the second part ((33) and (35)) differs. Since the second gradient term can be viewed as responsible for shifting the pre-update sampling distribution PT ( |) towards higher post-update returns, we refer to it as Jpre( ,  ) . To further analyze the difference between JpIre and JpIrIe we slightly rearrange (33) and put both gradient terms next to each other:


JpIre( ,  ) =  log ( ) ( log ( )R( ))

JpIrIe( ,  ) =  log ( )R( )

 J inner

(

log 

(

)R(

)) 

 J outer

(36) (37)

In the following we interpret and and compare of the derived gradient terms, aiming to provide intuition for the differences between the formulations:

The first gradient term Jpost that matches in both formulations corresponds to a policy gradient step
on the post-update policy  . Since  itself is a function of , the term I + R( )2 log ( )) can be seen as linear transformation of the policy gradient update R( ) log ( ) from the
post-update parameter  into . Although Jpost takes into account the functional relationship between  and , it does not take into account the pre-update sampling distribution PT ( |).

This is where Jpre comes into play: JpIre can be viewed as policy gradient update of the pre-
update policy  w.r.t. to the post-update return R( ). Hence this gradient term aims to shift the pre-update sampling distribution so that higher post-update returns are achieved. However, JpIrIe does not take into account the causal dependence of the post-update policy on the pre-update policy. Thus a change in  due to JpIrIe may counteract the change due to JpIoIst. In contrast, JpIre takes the dependence of the the post-update policy on the pre-update sampling distribution into account.
Instead of simply weighting the gradients of the pre-update policy  log ( ) with R( ) as in JpIost, JpIost weights the gradients with inner product of the pre-update and post-update policy gradients. This inner product can be written as

J inner  J outer = ||J inner||2 · || J outer||2 · cos()

(38)

wherein  denotes the angle between the the inner and outer pre-update and post-update policy gradients. Hence, JpIost steers the pre-update policy towards not only towards larger post-updates returns but also towards larger adaptation steps Jinner, and better alignment of pre- and postupdate policy gradients. This directly optimizes for maximal improvement / adaptation for the
respective task. See Li et al. (2017); Nichol et al. (2018) for a comparable analysis in case of
domain generalization and supervised meta-learning. Also note that (38) allows formulation I to
perform credit assignment on the trajectory level whereas formulation II can only assign credit to entire batches of N pre-update trajectories  1:N .

As a result, we expect the first meta-policy gradient formulation to learn faster and more stably since the respective gradients take the dependence of the pre-update returns on the pre-update sampling distribution into account while this causal link is neglected in the second formulation.

B ESTIMATING THE META-POLICY GRADIENTS
When employing formulation I for gradient-based meta-learning, we aim maximize the loss J () = ET (T ) E PT ( | ) [R( )] with  :=  +  E PT ( |) [R( )] (39)

14

by performing a form of gradient-descent on J(). Note that we, from now on, assume J := JI and
thus omit the superscript indicating the respective meta-learning formulation. As shown in A.2 the gradient can be derived as J () = E(T )(T )[JT ()] with

JT () = E PT ( | )  log PT ( | )R( ) I + 2 E PT ( |) [R( )]

(40)

where 2Jinner() := 2 E PT ( |) [R( )] denotes hessian of the inner adaptation objective w.r.t. . This section concerns the question of how to properly estimate this hessian.

B.1 ESTIMATING GRADIENTS OF THE RL REWARD OBJECTIVE

Since the expectation over the trajectory distribution PT ( |) is in general intractable, the score function trick is typically used to used to produce a Monte Carlo estimate of the policy gradients. Although the gradient estimate can be directly defined, when using a automatic-differentiation toolbox it is usually more convenient to use an objective function whose gradients correspond to the policy gradient estimate. Due to the Policy Gradient Theorem (PGT) Sutton et al. (2000) such a "surrogate" objective can be written as:

J PGT = 1 K

H -1

H

log (at|st)

r(st , at )

k t=0

t =t

1 H-1 t

= K

log (at|st) r(st , at )

k t=0 t =0

k  PT ( ) k  PT ( )

(41) (42)

While (41) and (42) are equivalent (Peters & Schaal, 2006), the more popular formulation formulation (41) can be seen as forward looking credit assignment while (42) can be interpreted as backward looking credit assignment (Foerster et al., 2018). A generalized procedure for constructing "surrogate" objectives for arbitrary stochastic computation graphs can be found in Schulman et al. (2015a).

B.2 A DECOMPOSITION OF THE HESSIAN

Estimating the the hessian of the reinforcement learning objective has been discussed in Furmston et al. (2016) and Baxter & Bartlett (2001) with focus on second order policy gradient methods. In the infinite horizon MDP case, Baxter & Bartlett (2001) derive a decomposition of the hessian. In the following, we extend their finding to the finite horizon case.
Proposition. The hessian of the RL objective can be decomposed into four matrix terms:

E PT ( |) 2Jinner() = H1 + H2 + H12 + H12

where

H1 = E PT ( |) H2 = E PT ( |) H12 = E PT ( |)

H -1

 log (at, st) log (at, st)

t=0

H -1

H -1

2 log (at, st)

r(st , at )

t=0 t =t

H -1
 log (at, st)Qt  (st, at)

t=0

H -1
r(st , at )
t =t

(43)
(44) (45) (46)

Here Qt (st, at) = E t+1:H-1PT (·|)

H -1 t =t

r(st

,

at

)|st,

at

denotes the expected state-action

value function under policy  at time t.

15

Proof. As derived in (24), the hessian of Jinner() follows as:

2Jinner = E PT ( |) R( ) 2 log ( ) +  log ( ) log( )

H -1
= E PT ( |)

t
2 log (at , st ) r(st, at)

t=0 t =0


H-1 t

t

+ E PT ( |) 

 log (at , st )

 log (at , st )

t=0 t =0

t =0

(47) (48)
 r(st, at)
(49)

= E PT ( |)

H -1
2 log (at, st)
t=0

H -1
r(st , at )
t =t

H-1 t t

+ E PT ( |)

 log (at , st ) log (ah, sh)

t=0 t =0 h=0

(50)
r(st, at) (51)

The term in (50) is equal to H2. We continue by showing that the remaining term in (51) is equivalent to H1 + H12 + H12. For that, we split the inner double sum in (51) into three components:

H -1
E PT ( |)
t=0

tt
 log (at, st) log (at, st)
t =0 h=0

r(st , at )

(52)

H-1 t

= E PT ( |)

 log (at , st ) log (at , st ) r(st , at )

t=0 t =0


H-1 t t -1



+ E PT ( |) 



 log (at , st ) log (ah, sh)  r(st , at )

t=0 t =0 h=0

(53) (54)

+ E PT ( |)

H -1 t=0

t h-1
 log (at , st ) log (ah, sh)
h=0 t =0

r(st , at )

(55)

By changing the backward looking summation over outer products into a forward looking summation of rewards, (53) can be shown to be equal to H1:

E PT ( |)
= E PT ( |) = H1

H-1 t

 log (at , st ) log (at , st ) r(st , at )

t=0 t =0

H -1

H -1

 log (at, st) log (at, st)

r(st , at )

t=0 t =t

(56)
(57) (58)

By simply exchanging the summation indices t and h in (55) it is straightforward to show that (55)
is the transpose of (54). Hence it is sufficient to show that (54) is equivalent to H12. However, instead of following the direction of the previous proof we will now start with the definition of H12
and derive the expression in (54).

H -1

H12 = E PT ( |)

 log (at, st)Qt (st, at)

t=0

The gradient of Qt  can be expressed recursively:

 Qt

(st,

at)

=

 E

st+1 at+1

Qt+ 1(st+1, at+1)

= Est+1
at+1

 log (at+1, st+1)Qt+ 1(st+1, at+1) + Qt+ 1(st+1, at+1)

(59) (60)
(61) (62)

16

By induction, it follows that

Qt  (st, at) = E t+1:H-1PT (·|)

H -1
 log (at+1, st+1)
t =t+1

H -1
r(sh, ah)
h=t

(63)

When inserting (63) into (59) and swapping the summation, we are able to show that H12 is equivalent to (54).

H-1 H-1

H -1

H12 = E PT ( |)

 log (at, st) log (at , st )

t=0 t =t+1

r(sh, ah)
h=t


H-1 t t -1



= E PT ( |) 



 log (at , st ) log (ah, sh)  r(st, at)

t=0 t =0 h=0

(64) (65)

This concludes the proof that the hessian of the expected sum of rewards under policy  and an MDP with finite time horizon H can be decomposed into H1 + H2 + H12 + H12.

B.3 ESTIMATING HESSIAN OF THE RL REWARD OBJECTIVE
As pointed out by Al-Shedivat et al. (2018); Stadie et al. (2018) and Foerster et al. (2018), simply differentiating through the gradient of surrogate objective JPGT as done in the original MAML version (Finn et al., 2017) leads to biased hessian estimates. Specifically, when compared with the unbiased estimate, as derived in (24) and decomposed in Appendix B.2, both H1 and H12 + H12 are missing. Thus, Jpre does not appear in the gradients of the meta-objective (i.e. J = Jpost). Only performing gradient descent with Jpost entirely neglects influences of the pre-update sampling distribution. This issue was overseen in the RL-MAML implementation of Finn et al. (2017). As discussed in Stadie et al. (2018) this leads to poor performance in meta-learning problems that require exploration during the pre-update sampling.

B.3.1 THE DICE MONTE-CARLO ESTIMATOR

Addressing the issue of incorrect higher-order derivatives of monte-carlo estimators, Foerster et al. (2018) propose DICE which mainly builds upon an newly introduced MagicBox( ) operator. This operator allows to formulate monte-carlo estimators with correct higher-order derivatives. A DICE formulation of a policy gradient estimator reads as:

H -1

J DICE =

({at t})r(st, at)

t=0

H -1

t

= exp

log (at |st ) - (log (at |st 0)

t=0 t =0

r(st, at)

(66) (67)

In that,  denotes a "stop gradient" operator (i.e. (f(x))  f(x) but (f(x))  0).
Note that  denotes a "evaluates to" and does not necessarily imply equality w.r.t. to gradients.
Hence, JDICE() evaluates to the sum of rewards at 0th order but produces the unbiased gradients nJDICE() when differentiated n-times (see Foerster et al. (2018) for proof). To shed more light on the maverick DICE formulation, we rewrite (67) as follows:

H -1
J DICE =
t=0

t (at |st ) t =0 ((at |st ))

r(st, at)

(68)

Interpreting this novel formulation, the MagicBox operator ({at t}) can be understood as "dry" importance sampling weight. At 0th order it evaluates to 1 and leaves the objective function unaffected, but when differentiated once it yields an estimator for the marginal rate of return due to a change in the policy-implied trajectory distribution.

17

In the following we show that on expectation 1) the gradients of (81) match standard policy gradients and 2) its hessian estimate is equal to the hessian of inner RL objective, derived in B.2.

H -1

J DICE =



t=0

t (at |st ) t =0 ((at |st ))

r(st, at)

H -1
=

t

(at |st )

t=0 t =0 ((at |st ))

t
 log (at |st )
t =0

H-1 t

  log (at |st ) r(st, at)

t=0 t =0

r(st, at)

(69) (70) (71)

Here, (71) corresponds to the backward looking credit assignment formulation of policy gradients JPGT as discussed in B.1. Once again we take the derivative in order to obtain the Hessian of J DICE:

H -1

2J DICE =



t=0

t (at |st ) t =0 ((at |st ))

t
 log (at |st ) r(st, at)
t =0

(72)

+

t (at |st ) t =0 ((at |st ))



t
 log (at |st )
t =0

r(st, at)

(73)

H-1 t
  log (at |st )

t
 log (at |st ) r(st, at)

(74)

t=0 t =0

t =0

t
+ 2 log (at |st ) r(st, at)
t =0

(75)

In expectation E PT ( |)[2J DICE] the DICE monte carlo estimate of the hessian is equivalent to the hessian of the inner objective. To show this, we use the expression of 2Jinner (49):

E PT ( |)[2J DICE]

(76)

= E PT ( |)

H -1 t=0

t
 log (at |st )
t =0

t
 log (at |st )
t =0

(77)

t

r(st, at) +

2 log (at |st ) r(st, at)

t =0

(78)

= H1 + H2 + H12 + H12 = 2Jinner

(79) (80)

B.4 BIAS AND VARIANCE OF THE CURVATURE ESTIMATE

As shown in the previous section, 2JDICE provides an unbiased estimate of the hessian of the inner objective Jinner = E PT ( |) [R( )]. However, recall the DICE objective involves a product of importance weights along the trajectory.

H -1
J DICE =
t=0

t (at |st ) t =0 ((at |st ))

r(st, at)

(81)

Taking the 2nd derivative of this product leads to the outer product of sums in (74) which is of high
variance w.r.t to  . Specifically, this outer product of sums can be decomposed into three terms H1 + H12 + H12 (see Appendix B.2). As noted by Furmston et al. (2016), H12 + H12 is particularly difficult to estimate. In section 7.2 we empirically show that the high variance curvature estimates
obtained with the DICE objective require large batch sizes and impede sample efficient learning.

In the following we develop a low variance curvature (LVC) estimator JLVC which matches JDICE at the gradient level and yields lower-variance estimates of the hessian by neglecting H12 + H12.

18

Before formally introducing JLVC, we motivate such estimator starting with the policy gradient
estimate that was originally derived in Sutton et al. (2000), followed by marginalizing the trajectory level distribution PT ( |) over states st and actions at. Note that we omit reward baselines for notational simplicity.

H -1

H -1

Jinner = E PT ( |)

 log (at|st)

r(st , at )

t=0 t =t

H -1

H -1

= E stpt (st)  log (at|st)

r(st , at )

t=0 at (at|st)

t =t

(82) (83)

obInneitnthhgaeti,nppostltic(aysfttep)radrteasnmtoeetpteessruthn.edesWrtatetheemvpaioskiletiacttyihoensf.irmeInqpultihefnyecignyegnaatesrtasimul mceapsstteieoppnttt,h(isa.ett.)pittshei(nspttrr)aocbitsaabbfiilxleietybduditnedneaspilteoyncdoasfl region of . Since we make this assumption at the gradient level, this corresponds to a 1st order Taylor expansion of pt (st) in . Note that this assumption is also used in the Monotonic Policy Improvement Theory (Kakade & Langford, 2002; Schulman et al., 2015a). Based on this condition,
the hessian follows as derivative of (83) whereby a "stop gradient" expression around the state visitation frequency pt  (st) resembles the 1st order Taylor approximation:

H -1

E 2J LVC = 

Est(pt  (st))

t=0 at (at|st)

 log (at|st)

H -1
r(st , at )
t =t

H -1

H -1

= Est(pt (st))  log (at|st) log (at|st)
t=0 at (at|st)

r(st , at )
t =t

H -1

+ 2 log (at|st)

r(st , at )

t =t

(84) (85) (86)

Since the expectation in (84) is intractable it must be evaluated by a monte carlo estimate. However, simply replacing the expectation with an average of samples trajectories induces a wrong hessian that does not correspond to (86) since outer product of log-gradients would be missing when differentiated. To ensure that automatic differentiation still yields the correct hessian, we add a "dry" importance weight comparable to DICE:

J LVC

=

H -1 t=0

 (at |st ) ( (at |st ))



log

 (at |st )

H -1
r(st , at )
t =t

When integrated this resembles the LVC "surrogate" objective JLVC.

  PT ( |)

(87)

J LVC

=

H -1 t=0

 (at |st ) ( (at |st ))

H -1
r(st , at )
t =t

  PT ( |)

The gradients of JLVC match JDICE and resemble an unbiased policy gradient estimate:

J LVC

=

H -1 t=0

  (at |st ) ( (at |st ))

H -1
r(st , at )
t =t

=

H -1 t=0

 (at |st ) ( (at |st ))



log

 (at |st )

H -1
r(st , at )
t =t

H -1

H -1

  log (at|st)

r(st , at )

t=0 t =t

(88)
(89) (90) (91)

19

The respective Hessian can be obtained by differentiating (90):

2J LVC

=



H -1 t=0

 (at |st ) ( (at |st ))



log (at|st)

H -1
r(st , at )
t =t

=

H -1 t=0

 (at |st ) ( (at |st ))



log

 (at |st )

log

 (at |st )

H -1
r(st , at )
t =t

+

 (at |st ) ( (at |st ))

2

log

 (at |st )

H -1
r(st , at )
t =t

H -1

H -1

  log (at|st) log (at|st)

r(st , at )

t=0 t =t

H -1

+ 2 log (at|st)

r(st , at )

t =t

H-1 t

=  log (at |st ) log (at|st) r(st, at)

t=0 t =0

t
+ 2 log (at |st ) r(st, at)

t =0

(92) (93) (94) (95) (96) (97) (98)

In expectation 2J LVC is equivalent to H1 + H2:

E PT ( |) J LVC = E PT ( |)

H -1 t=0

t
 log (at |st ) log (at|st)
t =0

+ E PT ( |) = H1 + H2

H -1 t=0

t
2 log (at |st )
t =0

r(st, at)

r(st, at) (99) (100) (101)

The Hessian 2J LVC no longer provides an unbiased estimate of 2Jinner since neglects the matrix
term H12 + H12. This approximation is based on the assumption that the state visitation distribution is locally unaffected by marginal changes in  and leads to a substantial reduction of variance in

the hessian estimate. Furmston et al. (2016) show that under certain conditions (i.e. infinite horizon

MD. PG,isvuefnficthieantttlhyericcohnpdoitliiocnyspharoalmd,ettheirsisiamtipolnie)sthtehatetrEmH[122J+LHVC1]2

vanishes around a local optimum  E [2J DICE] as   , i.e.

the bias of the LCV estimator becomes negligible close to the local optimum. The experiments

in section 7.2 confirm this theoretical argument empirically and show that using the low variance

curvature estimates obtained through JLVC improve the sample-efficiency of meta-learning by a

significant margin.

C PROXIMAL POLICY SEARCH METHODS
C.1 MONOTONIC POLICY IMPROVEMENT THEORY
In this section provides a brief introduction to policy performance bounds and the theory of monotonic policy improvement in the setting of reinforcement learning. While Section 6 discusses the extension of this theory to meta learning, the following explanations assume a standard RL setting where T is exogenously given. Hence, we will omit mentioning dependence on T for notational brevity. Since monotonic policy improvement frameworks relies on infinite-time horizion MDPs, we assume H   for the remainder of this chapter.

20

In addition to the expected reward J() under policy , we will use the state value function V, the state-action value function Q as well as the advantage function A:



V (s) = Ea0,s1,...

tr(st, at) st = s

t=0



Q(s, a) = Es1,a1,...

tr(st, at) st = s, a0 = a

t=0

A(s, a) = Q(s, a) - V (s)

= r(s, a) + Es p(s |s,a) [V(s )]

with at  (at|st) and st+1  p(st+1|st, at).
The expected return under a policy ~ can be expressed as the sum of the expected return of another policy  and the expected discounted advantage of ~ over  (see Schulman et al. (2015a) for proof).

J (~) = J () + E P ( ,~)


tA(st, at)
t=0

Let d denote the discounted state visitation frequency:


d(s) = t p(st = s|)
t=0

We can use d to express the expectation over trajectories   p( ) in terms of states and actions:

J (~) = J () + Esd~ (s) [A(s, a)]
a~(a|s)

(102)

Local policy search aims to find a policy update   ~ in the proximity of  so that J(~) is maximized. Since J() is not affected by the policy update   ~, it is sufficient to maximize the expected advantage under ~. However, the complex dependence of d~(s) on ~ makes it hard to directly maximize the objective in (102). Using a local approximation of (102) where it is assumed that the state visitation frequencies d and d~ are identical, the optimization can be phrased as

J~(~) = J () + Esd(s) [A(s, a)] = J () + Esd(s)

a~(a|s)

a(a|s)

~(a|s) A(s, a) (a|s)

(103)

In the following we refer to J~(~) as surrogate objective. It can be shown that the surrogate objective J~ matches J to first order when  = ~ (see Kakade & Langford (2002)). If  is a parametric and differentiable function with parameter vector , this means that for any o:

J~o (o ) = Jo (o ) and J~o () o = Jo () o

(104)

When  = ~, an approximation error of the surrogate objective J~ w.r.t. to the true objective J is introduced. Achiam et al. (2017) derive a lower bound for the true expected return of ~:

J (~)  J(~) - C Esd [DKL[~(·|s)||(·|s)]] = J(~) - C



with C

=

2 1-

maxs |Ea~(a,s)[A(s, a)]|

D¯KL[~||]

(105)

C.2 TRUST REGION POLICY OPTIMIZATION (TRPO)

Trust region policy optimization (TPRO) (Schulman et al., 2015a) attempts to approximate the bound in (105) by phrasing local policy search as a constrained optimization problem:

arg max


Esdo (s)
ao (a|s)

(a|s) Ao (s, a) o (a|s)

s.t. D¯KL[o ||]  

(106)

21

Thereby the KL-constraint  induces a local trust region around the current policy o . A practical implementation of TPRO uses a quadratic approximation of the KL-constraint which leads to the
following update rule:

   + 2 F -1g g Fg

(107)

with g := Esdo (s)

 (a|s) o (a|s)

Ao

(s,

a)

being the gradient of the objective and F

=

2D¯KL[o ||]

ao (a|s)
the Fisher information

matrix

of

the

current

policy

o .

In

order

to

avoid

the

cubic

time complexity that arise when inverting F , the Conjugate Gradient (CG) algorithm is typically

used to approximate the Hessian vector product F -1g.

C.3 PROXIMAL POLICY OPTIMIZATION (PPO)

While TPRO is framed as constrained optimization, the theory discussed in Appendix C.1 suggest to optimize the lower bound. Based on this insight, Schulman et al. (2017) propose adding a KL penalty to the objective and solve the following unconstrained optimization problem:

arg max


Esdo (s)
ao (a|s)

 (a|s) o (a|s)

Ao

(s,

a)

-



DKL

[o

(·|s)||

(·|s)]

(108)

However, they also show that it is not sufficient to set a fixed penalty coefficient  and propose two alternative methods, known as Proximal Policy Optimization (PPO) that aim towards alleviating this issue:

1) Adapting the KL coefficient  so that a desired target KL-divergence D¯KL[o ||] between the policy before and after the parameter update is achieved

2) Clipping the likelihood ratio so that the optimization has no incentive to move the policy  too far away from the original policy o . A corresponding optimization objective reads as:

J CLIP = Esdo (s) min
ao (a|s)

(a|s) Ao (s, a) o (a|s)

,

clip11-+

(a|s) Ao (s, a) o (a|s)

(109)

Empirical results show that the latter approach leads to better learning performance (Schulman et al., 2017).

Since PPO objective keeps  in proximity of o , it allows to perform multiple gradient steps without re-sampling trajectories from the updated policy. This property substantially improves the
data-efficiency of PPO over vanilla policy gradient methods which need to re-estimate the gradients
after each step.

D EXPERIMENTS
D.1 HYPERPARAMETER CHOICE
The optimal hyperparameter for each algorithm was determined using parameter sweeps. Table 1 contains the hyperparameter settings used for the different algorithms. Any environment specific modifications are noted in the respective paragraph describing the environment.
D.2 ENVIRONMENT SPECIFICATIONS PointEnv (used in the experiment in 7.3)

· Trajectory Length : 100 · Num Adapt Steps : 3

22

All Algorithms Policy Hidden Layer Sizes
Num Adapt Steps Inner Step Size  Tasks Per Iteration Trajectories Per Task
ProMP Outer Learning Rate  Grad Steps Per ProMP Iteration Outer Clip Ratio KL Penalty Coef. 
MAML-TRPO Trust Region Size
MAML-VPG Outer Learning Rate 

(64, 64) (128, 128) for Humanoid
1 0.01 40 20
0.001 5 0.3
0.0005
0.01
0.001

Table 1: Hyperparameter settings used in each algorithm

In this environment, each task corresponds to one corner of the area. The point mass must reach the goal by applying directional forces. The agent only experiences a reward when within a certain radius of the goal, and the magnitude of the reward is equal to the distance to the goal. HalfCheetahFwdBack, AntFwdBack, WalkerFwdBack, HumanoidFwdBack
· Trajectory Length : 100 (HalfCheetah, Ant); 200 (Humanoid, Walker) · Num Adapt Steps: 1
The task is chosen between two directions - forward and backward. Each agent must run along the goal direction as far as possible, with reward equal to average velocity minus control costs. AntRandDirec, HumanoidRandDirec
· Trajectory Length : 100 (Ant); 200 (Humanoid) · Num Adapt Steps: 1
Each task corresponds to a random direction in the XY plane. As above, each agent must learn to run in that direction as far as possible, with reward equal to average velocity minus control costs. AntRandGoal
· Trajectory Length : 200 · Num Adapt Steps: 2
In this environment, each task is a location randomly chosen from a circle in the XY plane. The goal is not given to the agent - it must learn to locate, approach, and stop at the target. The agent receives a penalty equal to the distance from the goal. HopperRandParams, WalkerRandParams
· Trajectory Length : 200 · Inner LR : 0.05 · Num Adapt Steps: 1
The agent must move forward as quickly as it can. Each task is a different randomization of the simulation parameters, including friction, joint mass, and inertia. The agent receives a reward equal to its velocity.
23

Average return

D.3 FURTHER EXPERIMENTS RESULTS

In addition to the six environments displayed in 2, we ran experiments on the other four continuous control environments described above. The results are displayed in 6.

275 AntFwdBack
250

600

225 200

500

175 150

400

125 300 100

0 1 AnT2tiRmaenstdeGpsoa3l 4 1e7 0.0

HumanoidFwdBack

0.8 1.6 2.4
WalkerRandVel

1e38.2

250 300

2000

350 1500 400

450 1000

500 550

500

0.0 0.5 1.0 1.5 2.0 1e8 0.0 0.8 1.6 2.4 3.2 1e47.0
ProMP (ours) MAML E-MAML-TRPO LVC-VPG E-MAML-VPG

Figure 6: Meta-learning curves of ProMP and four other gradient-based meta-learning algorithms in four new Mujoco environments

In addition to the improved sample complexity and better asymptotic performance, another advantage of ProMP is its computation time. Figure 7 shows the average time spent per iteration throughout the learning process in the humanoid environment differences of ProMP, LVC-VPG, and MAML-TRPO. Due to the expensive conjugate gradient steps used in TRPO, MAML takes far longer than either first order method. Since ProMP takes multiple stochastic gradient descent steps per iteration, it leads to longer outer update times compared to VPG, but in both cases the update time is a fraction of the time spent sampling from the environment.
The difference in sampling time is due to the reset process: resetting the environment when the agent "dies" is an expensive operation. ProMP acquires better performance quicker, and as a result the agent experiences longer trajectories and the environment is reset less often. In our setup, instances of the environment are run in parallel and performing a reset blocks all environments.

ProMP (ours)

Average Iteration Time

LVC-VPG

MAML-TRPO 0

20

Time-Sampling

40 6T0ime (s8e0cond1s0/i0tr) 120

Time-SampleProc

Time-InnerStep

140 160
Time-OuterStep

Figure 7: Comparison of wall clock time with different algorithms on HumanoidRandDirec, averaged over all iterations

24

