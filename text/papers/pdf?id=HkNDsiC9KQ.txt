Under review as a conference paper at ICLR 2019
LEARNING UNSUPERVISED LEARNING RULES
Anonymous authors Paper under double-blind review
ABSTRACT
A major goal of unsupervised learning is to discover data representations that are useful for subsequent tasks, without access to supervised labels during training. Typically, this goal is approached by minimizing a surrogate objective, such as the negative log likelihood of a generative model, with the hope that representations useful for subsequent tasks will arise incidentally. In this work, we propose instead to directly target a later desired task by meta-learning an unsupervised learning rule, which leads to representations useful for that task. Here, our desired task (meta-objective) is the performance of the representation on semi-supervised classification, and we meta-learn an algorithm ­ an unsupervised weight update rule ­ that produces representations that perform well under this meta-objective. Additionally, we constrain our unsupervised update rule to a be a biologicallymotivated, neuron-local function, which enables it to generalize to novel neural network architectures. We show that the meta-learned update rule produces useful features and sometimes outperforms existing unsupervised learning techniques. We further show that the meta-learned unsupervised update rule generalizes to train networks with different widths, depths, and nonlinearities. It also generalizes to train on data with randomly permuted input dimensions and even generalizes from image datasets to a text task.
1 INTRODUCTION
Supervised learning has proven extremely effective for many problems where large amounts of labeled training data are available. There is a common hope that unsupervised learning will prove similarly powerful in situations where labels are expensive, impractical to collect, or where the prediction target is unknown during training. Unsupervised learning however has yet to fulfill this promise. One explanation for this failure is that unsupervised representation learning algorithms are typically mismatched to the target task. Ideally, learned representations should linearly expose high level attributes of data (e.g. object identity) and perform well in semi-supervised settings. Many current unsupervised objectives, however, optimize for objectives such as log-likelihood of a generative model or reconstruction error and produce useful representations only as a side effect.
Unsupervised representation learning seems uniquely suited for meta-learning (Hochreiter et al., 2001; Schmidhuber, 1995). Unlike most tasks where meta-learning is applied, unsupervised learning does not define an explicit objective, which makes it impossible to phrase the task as a standard optimization problem. It is possible, however, to directly express a meta-objective that captures the quality of representations produced by an unsupervised update rule by evaluating the usefulness of the representation for candidate tasks, e.g. semi-supervised classification. In this work, we propose to meta-learn an unsupervised update rule by meta-training on a meta-objective that directly optimizes the utility of the unsupervised representation. Unlike hand-designed unsupervised learning rules, this meta-objective directly targets the usefulness of a representation generated from unlabeled data for later supervised tasks.
By recasting unsupervised representation learning as meta-learning, we treat the creation of the unsupervised update rule as a transfer learning problem. Instead of learning transferable features, we learn a transferable learning rule which does not require access to labels and generalizes across both data domains and neural network architectures. Although we focus on the meta-objective of semi-supervised classification here, in principle a learning rule could be optimized to generate representations for any subsequent task.
1

Under review as a conference paper at ICLR 2019
2 RELATED WORK
2.1 UNSUPERVISED REPRESENTATION LEARNING
There is no single accepted definition of unsupervised learning, and it is a topic of broad and diverse interest. Here we briefly present several techniques that can lead to a useful latent representation of a dataset. In contrast to our work, each method imposes a manually defined training algorithm or loss function to optimize whereas we learn the algorithm that creates useful representations as determined by a meta-objective.
Autoencoders (Hinton and Salakhutdinov, 2006) work by first compressing and optimizing reconstruction loss. Extensions have been made to de-noise data (Vincent et al., 2008; 2010), as well as compress information in an information theoretic way (Kingma and Welling, 2013). Le et al. (2011) further explored scaling up these unsupervised methods to large image datasets.
Generative adversarial networks (Goodfellow et al., 2014) take another approach to unsupervised feature learning. Instead of a loss function, an explicit min-max optimization is defined to learn a generative model of a data distribution. Recent work has shown that this training procedure can learn unsupervised features useful for few shot learning (Radford et al., 2015; Donahue et al., 2016; Dumoulin et al., 2016).
Other techniques rely on self-supervision where labels are easily generated to create a non-trivial `supervised' loss. Domain knowledge of the input is often necessary to define these losses. Noroozi and Favaro (2016) use unscrambling jigsaw-like crops of an image. Techniques like Misra et al. (2016) and Sermanet et al. (2017) rely on using temporal ordering from videos.
Another approach to unsupervised learning relies on feature space design such as clustering. Coates and Ng (2012) showed that k-means can be used for feature learning. Xie et al. (2016) jointly learn features and cluster assignments. Bojanowski and Joulin (2017) develop a scalable technique to cluster by predicting noise. Other techniques such as Schmidhuber (1992), Hochreiter and Schmidhuber (1999), and Olshausen and Field (1997) define various desirable properties about the latent representation of the input, such as predictability, complexity of encoding mapping, independence, or sparsity, and optimize to achieve these properties.
2.2 META LEARNING
Most meta-learning algorithms consist of two levels of learning, or `loops' of computation: an inner loop, where some form of learning occurs (e.g. an optimization process), and an outer loop or meta-training loop, which optimizes some aspect of the inner loop. We call the aspects of the inner loop modified by the outer loop meta-parameters. The performance of the inner loop computation is quantified by a meta-objective. Meta-optimization is then the process of adjusting the meta-parameters so that the inner loop performs well on this meta-objective. Meta-learning approaches differ by the computation performed in the inner loop, the domain, the choice of meta-parameters, and the method of optimizing the outer loop.
Some of the earliest work in meta-learning includes (Schmidhuber, 1987) which explores a variety of meta-learning and self-referential algorithms. Similarly to our algorithm Bengio et al. (1990; 1992) propose to learn a neuron local learning rule, though their approach differs in task and problem formulation. Additionally, Runarsson and Jonsson (2000) meta-learn supervised learning rules which mix local and global network information. A number of papers propose meta-learning for few shot learning (Vinyals et al., 2016; Ravi and Larochelle, 2016; Mishra et al., 2017; Finn et al., 2017; Snell et al., 2017), though these do not take advantage of unlabeled data. In (Garg and Kalai, 2017) meta-learning is used for unsupervised learning, primarily in the context of clustering and with a small number of meta-parameters. To allow easy comparison against other existing approaches, we present a more extensive survey of previous work in meta-learning in table form in Appendix A, highlighting differences in choice of task, structure of the meta-learning problem, choice of meta-architecture, and choice of domain.
To our knowledge, we are the first meta-learning approach to tackle the problem of unsupervised representation learning, where the inner loop consists of unsupervised learning. This contrasts with transfer learning, where a neural network is instead trained on a similar dataset, and then fine tuned or
2

Under review as a conference paper at ICLR 2019

Figure 1: Left: Schematic for meta-learning an unsupervised learning algorithm. The inner loop computation consists of iteratively applying the UnsupervisedUpdate to a base model. During metatraining the UnsupervisedUpdate (parameterized by ) is itself updated by gradient descent on the MetaObjective. Right: Schematic of the base model and UnsupervisedUpdate. Unlabeled input data, x0, is passed through the base model, which is parameterised by W and colored green. The goal of the UnsupervisedUpdate is to modify W to achieve a top layer representation xL which performs well at few-shot learning. In order to train the base model, information is propagated backwards by the UnsupervisedUpdate in a manner analogous to backprop. Unlike in backprop however, the backward weights V are decoupled from the forward weights W , and there is no explicit error signal. Instead at each layer, and for each neuron, a learning signal is injected by a meta-learned MLP parameterized by , with hidden state h. Weight updates are again analogous to those in backprop, and depend on the hidden state of the pre- and post- synaptic neurons for each weight.

otherwise post-processed on the target dataset. We additionally believe we are the first representation meta-learning approach to generalize across input data modalities as well as datasets, the first to generalize across permutation of the input dimensions, and the first to generalize across neural network architectures (e.g. layer width, network depth, activation function).

3 MODEL DESIGN

We consider a multilayer perceptron (MLP) f (·; t), with parameters t, as the base model. The inner loop of our meta-learning process trains this base model via iterative application of our learned
optimizer. See Figure 1 for a schematic illustration and Appendix B for a more detailed diagram.

In standard supervised learning, the `learned' optimizer is stochastic gradient descent (SGD). A

supervised loss l (x, y) is associated with this model, where x is a minibatch of inputs, and y

are the corresponding labels. The parameters t of the base model are then updated iteratively

by

performing

SGD

using

the

gradient

l(x,y) t

.

This supervised update rule can be written as

t+1 = SupervisedUpdate(t, xt, yt; ). Here  are the meta-parameters of the optimizer, which

consist of hyper-parameters such as learning rate and momentum.

In this work, our learned optimizer is a parametric update process which does not depend on label information, t+1 = UnsupervisedUpdate(t, xt; ). This form of the update rule is general. It encompasses many unsupervised learning algorithms and all methods in Section 2.1.

In traditional unsupervised learning algorithms, expert knowledge or a simple hyper-parameter search determines , which consists of a handful of meta-parameters such as learning rate and regularization constants. In contrast, our update rule will have orders of magnitude more meta-parameters, including the weights of a neural network. We train these meta-parameters by performing SGD on the sum of the MetaObjective over the course of (inner loop) training in order to find optimal parameters ,

 = argmin Etask

MetaObjective(t ()) ,

t

that minimize the meta-objective over a set of training tasks.

(1)

In the following sections, we briefly review the main functional pieces to this model: the base model f (·, ), the UnsupervisedUpdate, and the MetaObjective. See the Appendix for a complete specification. Additionally, code and meta-trained parameters  for our meta-learned UnsupervisedUpdate will be available.

3

Under review as a conference paper at ICLR 2019

3.1 BASE MODEL: f (·; )
Our base model consists of a standard fully connected multi-layer perceptron (MLP), with batch normalization (Ioffe and Szegedy, 2015), and ReLU nonlinearities. We chose this as opposed to a convolutional model to limit the inductive bias hard-coded in favor of learned behavior from the UnsupervisedUpdate. We call the pre-nonlinearity activations z1, · · · , zL, and post-nonlinearity activations x0, · · · , xL, where L is the total number of layers, and x0  x is the network input (raw data). The parameters are  = W 1, b1, V 1, · · · , W L, bL, V L , where W l and bl are the weights and biases (applied after batch norm) for layer l, and V l are the corresponding weights used in the backward pass.

3.2 LEARNED UPDATE RULE: UNSUPERVISEDUPDATE(·; )

We wish for our update rule to generalize across architectures with different widths, depths, or even network topologies. To achieve this, we design our update rule to be neuron-local, so that updates are a function of pre- and post- synaptic neurons in the base model, and are defined for any base model architecture. This has the added benefit that it makes the weight updates more similar to synaptic updates in biological neurons, which depend almost exclusively on the pre- and post-synaptic neurons for each synapse (Whittington and Bogacz, 2017).

To build these updates, each neuron i in every layer l in the base model has an MLP, referred to as an update network, associated with it, with output hli (·; ). All update networks share meta-parameters , and hil (·; ) is evaluated only during unsupervised training as the update networks are part of the UnsupervisedUpdate, and not part of the base model. Evaluating the statistics of unit activation over
a batch of data has proven helpful in supervised learning (Ioffe and Szegedy, 2015). It has similarly
proven helpful in hand-designed unsupervised learning rules, such as sparse coding and clustering. We therefore allow hil (·; ) to accumulate statistics across examples in each training minibatch.
During an unsupervised training step, the base model is first run in a standard feed-forward fashion, populating xlib, zilb, where b is the training minibatch index. As in supervised learning, an error signal ilb is then propagated backwards through the network. Unlike in supervised backprop however, this error signal is generated by the corresponding update network for each unit, ilb  hli (·; ), and propogated backward using a set of learned `backward weights' (V l)T , as opposed to the transpose of the forward weights (W l)T as would be the case in backprop. Pictorially this can be seen in Figure 1.

Again as in supervised learning, the weight updates are a product of pre- and post-synaptic signals.
Unlike in supervised learning however, these signals are generated by the per-neuron update networks: Wilj = b clibdlj-b 1, where {clib, dilb}  hil (·; ).

The inputs to the update network consists of unit pre- and post-activations, and backwards propagated

error signal: hli xil·, zil·,

V l+1 T l+1 ;  . The backward weights also are updated with the
i·

same update network. For more information on the structure of hil, see Appendix F.

3.3 METAOBJECTIVE ()

The meta-objective determines the quality of the unsupervised representations. In order to meta-train via SGD, this loss must be differentiable. The meta-objective we use in this work is based on fitting a linear regression to labeled examples with a small number of data points. In order to encourage the learning of features that generalize well, we estimate the linear regression weights on one minibatch {xa, ya} of K data points, and evaluate the classification performance on a second minibatch {xb, yb} also with K datapoints,

v^ = argmin ya - vT ua 2 +  v 2 ,
v

MetaObjective(·; ) = CosDist yb, v^T ub , (2)

where ua, ub are features extracted from the base model on data xa, xb, respectively. The target labels ya, yb consist of one hot encoded labels and potentially also regression targets from data augmentation (e.g. rotation angle, see Section 4.2). We found that using a cosine distance, CosDist,
rather than unnormalized squared error improved stability. Note this meta-objective is only used

4

Under review as a conference paper at ICLR 2019

during meta-training and not used when applying the learned update rule. The inner loop computation is performed without labels.

4 TRAINING THE UPDATE RULE

4.1 APPROXIMATE GRADIENT BASED TRAINING

We choose to meta-optimize via SGD as opposed to reinforcement learning or other black box method,

due to the superior convergence properties of SGD in high dimensions, and the high dimensional

nature of . Training and computing derivatives through long recurrent computation of this form is

notoriously difficult (Pascanu et al., 2013). To improve stability and reduce the computational cost we

approximate

the

gradients

[MetaObjective] 

via

truncated

backprop

through

time.

Many

additional

design

choices were also crucial to achieving stability and convergence in meta-learning, including the

use of batch norm, and restricting the norm of the UnsupervisedUpdate update step. Meta-learning

practitioners may find the discussion of these and other choices in Appendix C valuable.

4.2 META-TRAINING DISTRIBUTION AND GENERALIZATION
Generalization in our learned optimizer comes from both the form of the UnsupervisedUpdate (Section 3.2), and from the meta-training distribution. Our meta-training distribution is composed of both datasets and base model architectures.
We construct a set of training tasks consisting of CIFAR10 (Krizhevsky and Hinton, 2009) and multi-class classification from subsets of classes from Imagenet (Russakovsky et al., 2015) as well as from a dataset consisting of rendered fonts. We find that increased training dataset variation actually improves the meta-optimization process. To reduce computation we restrict the input data to 16x16 pixels or less during meta-training, and resize all datasets accordingly. For evaluation, we use MNIST(LeCun et al., 1998), Fashion MNIST(Xiao et al., 2017), IMDB(Maas et al., 2011), and a hold-out set of Imagenet classes. We additionally sample the base model architecture. We sample number of layers between 2-5 and the number of units per layer between 64 to 512.
As part of preprocessing, we additionally permute all inputs along the feature dimension, so that the UnsupervisedUpdate must learn a permutation invariant learning rule. Unlike other work, we focus explicitly on learning a learning algorithm as opposed to the discovery of fixed feature extractors that generalize across similar tasks. This makes the learning task much harder, as the UnsupervisedUpdate has to discover the relationship between pixels based solely on their joint statistics, and cannot "cheat" and memorize pixel identity. To provide further dataset variation, we additionally augment the data with shifts, rotations, and noise. We add these augmentation coefficients as additional regression targets for the meta-objective ­ e.g. rotate the image and predict the rotation angle as well as the image class. For additional details, see Appendix I.1.1.

4.3 DISTRIBUTED IMPLEMENTATION
We implement the above models in distributed Tensorflow (Abadi et al., 2016). Training uses 512 workers, each of which performs a sequence of partial unrolls of the inner loop UnsupervisedUpdate, and computes gradients of the meta-objective asynchronously. Training takes 8 days, and consists of 200 thousand updates to  with minibatch size 256. Additional details are in Appendix D.

5 EXPERIMENTAL RESULTS
First, we examine limitations of existing unsupervised and meta learning methods, next we show metatraining and generalization properties of our learned optimizer. Finally we conclude by exploring how our learned optimizer functions. For details of experimental setup, see Appendix I.
5.1 OBJECTIVE FUNCTION MISMATCH AND EXISTING META-LEARNING METHODS
To illustrate the negative consequences of objective function mismatch in unsupervised learnin algorithms, we train a variational autoencoder on 16x16 CIFAR10. Over the course of training we

5

Under review as a conference paper at ICLR 2019
evaluate classification performance from few shot classification using the learned latent representations. Training curves can be seen in Figure 2. Despite continuing to improve the VAE objective throughout training (not shown here), the classification accuracy decreases sharply later in training. To demonstrate the reduced generalization that results from learning transferable features rather than an update algorithm, we train a prototypical network with and without the input shuffling described in Section 4.2. Due to the transferable features structure of prototypical network, performance is significantly hampered by input shuffling. Results are in Figure 2.
Figure 2: Left: Standard unsupervised learning approaches suffer from objective function missmatch. Continuing to optimize a variational auto-encoder (VAE) hurts few-shot accuracy after some number of steps (dashed line). Right: Prototypical networks transfer features rather than a learning algorithm, and perform poorly if tasks don't have consistent data structure. Training a prototypical network with a fully connected architecture (same as our base model) on a miniImagenet 10-way classification task with either intact inputs (light purple) or by permuting the pixels before every training and testing task (dark purple). Performance with permuted inputs is greatly reduced (gray line). Our performance is invariant to pixel permutation.
Figure 3: Training curves for the training and evaluation task distributions. Our train set consists of Mini Imagenet, Alphabet, and MiniCIFAR. Our test sets are Mini Imagenet Test, Tiny Fashion MNIST, Tiny MNIST and IMDB. Error bars denote standard deviation of evaluations with a fixed window of samples evaluated from a single model. Dashed line at 200 hours indicates model used for remaining experiments unless otherwise stated. For a bigger version, see Appendix F. 5.2 META-OPTIMIZATION While training, we monitor a rolling average of the meta-objective averaged across all datasets, model architectures, and the number of unrolling steps performed. In Figure 3 the training loss is continuing to decrease after 200 hours of training, which suggests that the approximate training techniques still produce effective learning. In addition to this global number, we measure performance obtained by rolling out the UnsupervisedUpdate on various training and testing datasets. We see that on held out image datasets, such as MNIST and Fashion Mnist, the evaluation loss is still decreasing. However, for datasets in a different domain, such as IMDB sentiment prediction (Maas et al., 2011), we start to see over-fitting. For all remaining experimental results, unless otherwise stated, we use meta-parameters, , for the UnsupervisedUpdate resulting from 200 hours of meta-training. 5.3 GENERALIZATION The goal of this work is to learn a general purpose unsupervised representation learning algorithm. As such, this algorithm must be able to generalize across a wide range of scenarios, including tasks that are not sampled iid from the meta-training distribution. In the following sections, we explore a subset of the factors we seek to generalize over.
6

Under review as a conference paper at ICLR 2019

Generalizing over datasets and domains
In Figure 4, we compare performance on few shot classification with 10 examples per class. We evaluate test performance on holdout datasets of MNIST and Fashion MNIST at 2 resolutions: 14×14 and 28×28 (larger than any dataset experienced in meta-training). On the same base model architecture, our learned UnsupervisedUpdate leads to performance better than a variational autoencoder, supervised learning on the labeled examples, and random initialization with trained readout layer.

Accuracy
Accuracy

0.8

Initialization Supervised

0. 60

0.6

VAE Learned (ours)

30 hours

0.4 0. 55 200 hours

0.2

0.0 TinyMnist TinyFashionMnist Mnist FashionMnist

0. 50 0

1000 2000 3000 4000 5000
Training Steps

Figure 4: Left: The learned UnsupervisedUpdate generalizes to unseen datasets. Our learned

update rule produces representations more suitable for few shot classification than those from random

initialization or a variational autoecoder and outperforms fully supervised learning on the same labeled

examples. Error bars show standard error. Right: Early in meta-training, the UnsupervisedUpdate is

able to learn useful features on a 2 way text classification data set, IMDB, despite being trained only

from image datasets. Later in meta-training performance drops due to the domain mismatch. Error

bars show standard error across 10 runs.

To further explore generalization limits, we test our learned optimizer on data from a vastly different domain. We train on a binary text classification dataset: IMDB movie reviews (Maas et al., 2011), encoded by computing a bag of words with 1K words. We evaluate using a model 30 hours and 200 hours into meta-training (see Figure 4). Despite being trained exclusively on image datasets, the 30 hour learned optimizer improves upon the random initialization by almost 10%. When metatraining for longer, however, the learned optimizer "over-fits" to the image domain resulting in poor performance. This performance is quite low in an absolute sense. Nevertheless, we find this result very exciting as we are unaware of any work showing this kind of transfer of learned rules from images to text.
Generalizing over network architectures
We train models of varying depths and unit counts with our learned optimizer and compare results at different points in training (Figure 5). We find that despite only training on networks with 2 to 5 layers and 64 to 512 units per layer, the learned rule generalizes to 11 layers and 10,000 units per layer.

0.8

0 steps 100 steps

1000 steps

0.6 10000 steps

Accuracy

0.4

0.2

0.0

ReLU ELU Swish Step

Leaky ReLU

Softplus

Tanh

Figure 5: Left: The learned UnsupervisedUpdate is capable of optimizing base models with hidden sizes and depths outside the meta-training regime. As we increase the number of units per layer, the learned model can make use of this additional capacity despite never having experienced it during meta-training. Right: The learned UnsupervisedUpdate generalizes across many different activation functions not seen in training. We show accuracy over the course of training on 14x14 MNIST.

Next we look at generalization over different activation functions. We apply our learned optimizer on base models with a variety of different activation functions. Performance evaluated at different points in training (Figure 5). Despite training only on ReLU activations, our learned optimizer is able

7

Under review as a conference paper at ICLR 2019
to improve on random initializations in all cases. For certain activations, leaky ReLU (Maas et al., 2013) and Swish (Ramachandran et al., 2017), there is little to no decrease in performance. Another interesting case is the step activation function. These activations are traditionally challenging to train as there is no useful gradient signal. Despite this, our learned UnsupervisedUpdate is capable of optimizing as it does not use base model gradients, and achieves performance double that of random initialization.
5.4 HOW IT LEARNS AND HOW IT LEARNS TO LEARN
To analyze how our learned optimizer functions, we analyze the first layer filters over the course of meta-training. Despite the permutation invariant nature of our data (enforced by shuffling input image pixels before each unsupervised training run), the base model learns features such as those shown in Figure 6, which appear template-like for MNIST, and local-feature-like for CIFAR10. Early in training, there are coarse features, and a lot of noise. As the meta-training progresses, more interesting and local features emerge. In an effort to understand what our algorithm learns to do, we fed it data from the two moons dataset. We find that despite being a 2D dataset, dissimilar from the image datasets used in meta-training, the learned model is still capable of manipulating and partially separating the data manifold in a purely unsupervised manner (Figure 6). We also find that almost all the variance in the embedding space is dominated by a few dimensions. As a comparison, we do the same analysis on MNIST. In this setting, the explained variance is spread out over more of the principal components. This makes sense as the generative process contains many more latent dimensions ­ at least enough to express the 10 digits.
Figure 6: Left: From left to right we show first layer base model receptive fields produced by our learned UnsupervisedUpdate rule over the course of meta-training. Each pane consists of first layer filters extracted from  after 10k applications of UnsupervisedUpdate on MNIST (top) and CIFAR10 (bottom). For MNIST, the optimizer learns image-template-like features. For CIFAR10, low frequency features evolve into higher frequency and more spatially localized features. For more filters, see Appendix E. Center: Visualization of learned representations before (left) and after (right) training a base model with our learned UnsupervisedUpdate for two moons (top) and MNIST (bottom). The UnsupervisedUpdate is capable of manipulating the data manifold, without access to labels, to separate the data classes. Visualization shows a projection of the 32-dimensional represnetation of the base network onto the top three principal components. Right: Cumulative variance explained using principal components analysis (PCA) on the learned representations. The representation for two moons data (red) is much lower dimensional than MNIST (blue), although both occupy a fraction of the full 32-dimensional space.
6 DISCUSSION
In this work we meta-learn an unsupervised representation learning update rule. We show performance that matches or exceeds existing unsupervised learning on held out tasks. Additionally, the update rule can train models of varying widths, depths, and activation functions. More broadly, we demonstrate an application of meta-learning for learning complex optimization tasks where no objective is explicitly defined. Analogously to how increased data and compute have powered supervised learning, we believe this work is a proof of principle that the same can be done with algorithm design ­ replacing the hand designed techniques with architectures designed for learning and learned from data via meta-learning techniques.
8

Under review as a conference paper at ICLR 2019
REFERENCES
Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent. In International Conference on Artificial Neural Networks, pages 87­94. Springer, 2001.
Juergen Schmidhuber. On learning how to learn learning strategies. 1995.
Geoffrey E Hinton and Ruslan R Salakhutdinov. Reducing the dimensionality of data with neural networks. science, 313(5786):504­507, 2006.
Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol. Extracting and composing robust features with denoising autoencoders. In Proceedings of the 25th international conference on Machine learning, pages 1096­1103. ACM, 2008.
Pascal Vincent, Hugo Larochelle, Isabelle Lajoie, Yoshua Bengio, and Pierre-Antoine Manzagol. Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion. Journal of Machine Learning Research, 11(Dec):3371­3408, 2010.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.
Quoc V Le, Marc'Aurelio Ranzato, Rajat Monga, Matthieu Devin, Kai Chen, Greg S Corrado, Jeff Dean, and Andrew Y Ng. Building high-level features using large scale unsupervised learning. arXiv preprint arXiv:1112.6209, 2011.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural information processing systems, pages 2672­2680, 2014.
Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. arXiv preprint arXiv:1511.06434, 2015.
Jeff Donahue, Philipp Krähenbühl, and Trevor Darrell. Adversarial feature learning. arXiv preprint arXiv:1605.09782, 2016.
Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Alex Lamb, Martin Arjovsky, Olivier Mastropietro, and Aaron Courville. Adversarially learned inference. arXiv preprint arXiv:1606.00704, 2016.
Mehdi Noroozi and Paolo Favaro. Unsupervised learning of visual representations by solving jigsaw puzzles. In European Conference on Computer Vision, pages 69­84. Springer, 2016.
Ishan Misra, C Lawrence Zitnick, and Martial Hebert. Shuffle and learn: unsupervised learning using temporal order verification. In European Conference on Computer Vision, pages 527­544. Springer, 2016.
Pierre Sermanet, Corey Lynch, Jasmine Hsu, and Sergey Levine. Time-contrastive networks: Self-supervised learning from multi-view observation. arXiv preprint arXiv:1704.06888, 2017.
Adam Coates and Andrew Y Ng. Learning feature representations with k-means. In Neural networks: Tricks of the trade, pages 561­580. Springer, 2012.
Junyuan Xie, Ross Girshick, and Ali Farhadi. Unsupervised deep embedding for clustering analysis. In International conference on machine learning, pages 478­487, 2016.
Piotr Bojanowski and Armand Joulin. Unsupervised learning by predicting noise. arXiv preprint arXiv:1704.05310, 2017.
Jürgen Schmidhuber. Learning factorial codes by predictability minimization. Neural Computation, 4(6): 863­879, 1992.
Sepp Hochreiter and Jürgen Schmidhuber. Feature extraction through lococode. Neural Computation, 11(3): 679­714, 1999.
Bruno A Olshausen and David J Field. Sparse coding with an overcomplete basis set: A strategy employed by v1? Vision research, 37(23):3311­3325, 1997.
Jürgen Schmidhuber. Evolutionary principles in self-referential learning, or on learning how to learn: the meta-meta-... hook. PhD thesis, Technische Universität München, 1987.
Yoshua Bengio, Samy Bengio, and Jocelyn Cloutier. Learning a synaptic learning rule. Université de Montréal, Département d'informatique et de recherche opérationnelle, 1990.
9

Under review as a conference paper at ICLR 2019
Samy Bengio, Yoshua Bengio, Jocelyn Cloutier, and Jan Gecsei. On the optimization of a synaptic learning rule. In Preprints Conf. Optimality in Artificial and Biological Neural Networks, pages 6­8. Univ. of Texas, 1992.
Thomas Philip Runarsson and Magnus Thor Jonsson. Evolution and design of distributed learning rules. In Combinations of Evolutionary Computation and Neural Networks, 2000 IEEE Symposium on, pages 59­63. IEEE, 2000.
Oriol Vinyals, Charles Blundell, Tim Lillicrap, koray kavukcuoglu, and Daan Wierstra. Matching networks for one shot learning. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems 29, pages 3630­3638. Curran Associates, Inc., 2016. URL http:// papers.nips.cc/paper/6385-matching-networks-for-one-shot-learning.pdf.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. International Conference on Learning Representations, 2016.
Nikhil Mishra, Mostafa Rohaninejad, Xi Chen, and Pieter Abbeel. Meta-learning with temporal convolutions. arXiv preprint arXiv:1707.03141, 2017.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep networks. In Doina Precup and Yee Whye Teh, editors, Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of Machine Learning Research, pages 1126­1135, International Convention Centre, Sydney, Australia, 06­11 Aug 2017. PMLR. URL http://proceedings.mlr. press/v70/finn17a.html.
Jake Snell, Kevin Swersky, and Richard Zemel. Prototypical networks for few-shot learning. In Advances in Neural Information Processing Systems, pages 4080­4090, 2017.
Vikas K Garg and Adam Kalai. Supervising unsupervised learning. arXiv preprint arXiv:1709.05262, 2017.
Donald R Jones. A taxonomy of global optimization methods based on response surfaces. Journal of global optimization, 21(4):345­383, 2001.
Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine learning algorithms. In Advances in neural information processing systems, pages 2951­2959, 2012.
James S Bergstra, Rémi Bardenet, Yoshua Bengio, and Balázs Kégl. Algorithms for hyper-parameter optimization. In Advances in neural information processing systems, pages 2546­2554, 2011.
James Bergstra and Yoshua Bengio. Random search for hyper-parameter optimization. Journal of Machine Learning Research, 13(Feb):281­305, 2012.
Kenneth O Stanley and Risto Miikkulainen. Evolving neural networks through augmenting topologies. Evolutionary computation, 10(2):99­127, 2002.
Barret Zoph and Quoc V. Le. Neural architecture search with reinforcement learning. International Conference on Learning Representations, 2017. URL https://arxiv.org/abs/1611.01578.
Bowen Baker, Otkrist Gupta, Nikhil Naik, and Ramesh Raskar. Designing neural network architectures using reinforcement learning. International Conference on Learning Representations, 2017.
Barret Zoph, Vijay Vasudevan, Jonathon Shlens, and Quoc V Le. Learning transferable architectures for scalable image recognition. Proceedings of the IEEE conference on computer vision and pattern recognition.
Esteban Real, Sherry Moore, Andrew Selle, Saurabh Saxena, Yutaka Leon Suematsu, Quoc Le, and Alex Kurakin. Large-scale evolution of image classifiers. arXiv preprint arXiv:1703.01041, 2017.
Dougal Maclaurin, David Duvenaud, and Ryan Adams. Gradient-based hyperparameter optimization through reversible learning. In International Conference on Machine Learning, pages 2113­2122, 2015.
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, and Nando de Freitas. Learning to learn by gradient descent by gradient descent. In Advances in Neural Information Processing Systems, pages 3981­3989, 2016.
Yutian Chen, Matthew W Hoffman, Sergio Gómez Colmenarejo, Misha Denil, Timothy P Lillicrap, Matt Botvinick, and Nando de Freitas. Learning to learn without gradient descent by gradient descent. arXiv preprint arXiv:1611.03824, 2016.
Ke Li and Jitendra Malik. Learning to optimize. International Conference on Learning Representations, 2017.
10

Under review as a conference paper at ICLR 2019
Olga Wichrowska, Niru Maheswaranathan, Matthew W Hoffman, Sergio Gomez Colmenarejo, Misha Denil, Nando de Freitas, and Jascha Sohl-Dickstein. Learned optimizers that scale and generalize. International Conference on Machine Learning, 2017.
Irwan Bello, Barret Zoph, Vijay Vasudevan, and Quoc Le. Neural optimizer search with reinforcement learning. 2017. URL https://arxiv.org/pdf/1709.07417.pdf.
Rein Houthooft, Richard Y Chen, Phillip Isola, Bradly C Stadie, Filip Wolski, Jonathan Ho, and Pieter Abbeel. Evolved policy gradients. arXiv preprint arXiv:1802.04821, 2018.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Francis Bach and David Blei, editors, Proceedings of the 32nd International Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pages 448­456, Lille, France, 07­09 Jul 2015. PMLR. URL http://proceedings.mlr.press/v37/ioffe15. html.
James CR Whittington and Rafal Bogacz. An approximation of the error backpropagation algorithm in a predictive coding network with local hebbian synaptic plasticity. Neural computation, 29(5):1229­1262, 2017.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural networks. In International Conference on Machine Learning, pages 1310­1318, 2013.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. ImageNet Large Scale Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 115(3):211­252, 2015. doi: 10.1007/s11263-015-0816-y.
Yann LeCun, Léon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278­2324, 1998.
Han Xiao, Kashif Rasul, and Roland Vollgraf. Fashion-mnist: a novel image dataset for benchmarking machine learning algorithms, 2017.
Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. Learning word vectors for sentiment analysis. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 142­150, Portland, Oregon, USA, June 2011. Association for Computational Linguistics. URL http://www.aclweb.org/anthology/ P11-1015.
Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irving, Michael Isard, et al. Tensorflow: A system for large-scale machine learning. In OSDI, volume 16, pages 265­283, 2016.
Andrew L Maas, Awni Y Hannun, and Andrew Y Ng. Rectifier nonlinearities improve neural network acoustic models. In Proc. icml, volume 30, page 3, 2013.
Prajit Ramachandran, Barret Zoph, and Quoc Le. Searching for activation functions. 2017.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. Understanding the exploding gradient problem. CoRR, abs/1211.5063, 2012.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.
Barak Pearlmutter. An investigation of the gradient descent process in neural networks. PhD thesis, Carnegie Mellon University Pittsburgh, PA, 1996.
Samuel S Schoenholz, Justin Gilmer, Surya Ganguli, and Jascha Sohl-Dickstein. Deep information propagation. arXiv preprint arXiv:1611.01232, 2016.
11

Under review as a conference paper at ICLR 2019

A META-LEARNING COMPARISONS TABLE

Method
Hyper parameter optimization Jones (2001); Snoek et al. (2012); Bergstra et al. (2011); Bergstra and Bengio (2012) Neural architecture search Stanley and Miikkulainen (2002); Zoph and Le (2017); Baker et al. (2017); Zoph et al.; Real et al. (2017) Task-specific optimizer (eg for quadratic function identification) (Hochreiter et al., 2001) Learned optimizers Jones (2001); Maclaurin et al. (2015); Andrychowicz et al. (2016); Chen et al. (2016); Li and Malik (2017); Wichrowska et al. (2017); Bello et al. (2017) Prototypical networks Snell et al. (2017)
MAML Finn et al. (2017)
Evolved Policy Gradient Houthooft et al. (2018)
Few shot learning (Vinyals et al., 2016; Ravi and Larochelle, 2016; Mishra et al., 2017) Meta-unsupervised learning for clustering Garg and Kalai (2017)
Learning synaptic learning rules (Bengio et al., 1990; 1992)
Our work -- metalearning for unsupervised representation learning

Inner loop updates
many steps of optimization
supervised SGD training using meta-learned architecture adjustment of model weights by an LSTM many steps of optimization of a fixed loss function
apply a feature extractor to a batch of data and use soft nearest neighbors to compute class probabilities one step of SGD on training loss starting from a meta-learned network
performing gradient descent on a learned loss
application of a recurrent model, e.g. LSTM, Wavenet. run clustering algorithm or evaluate binary similarity function
run a synapse-local learning rule
many applications of an unsupervised update rule

Outer loop updates, meta-

parameters optimization hyperparameters
architecture

objective training or validation set loss
validation set loss

optimizer Baysian methods, random search, etc RL or evolution

Generalizes to
nothing, or test set within fixed dataset
test loss within similar datasets

LSTM weights task loss

SGD

parametric optimizer

average or final loss

SGD or RL

similar domain tasks
new loss functions (mixed success)

weights of the feature extractor

few shot

SGD

performance

new image classes within similar dataset

initial weights of neural network
parameters of a learned loss function
recurrent model weights
clustering algorithm + hyperparameters, binary similarity function parametric learning rule
parametric update rule

reward or training loss
reward
test loss on training tasks empirical risk minimization
supervised loss, or similarity to biologicallymotivated network few shot classification after unsupervised pretraining

SGD

new goals,

similar task

regimes with

same input

domain

Evolutionary new

Strategies environment

configurations,

both in and not

in meta-training

distribution.

SGD

new image

classes within

similar dataset.

varied

new clustering

or similarity

measurement

tasks

gradient descent, simulated annealing, genetic algorithms SGD

similar domain tasks
new base models (width, depth, nonlinearity), new datasets, new data modalities

Table 1: A comparison of published meta-learning approaches. 12

Under review as a conference paper at ICLR 2019

B MORE DETAILED SYSTEM DIAGRAM

a.) Meta-Training / Outer Loop

0 SGD 1

t

SGD

t+1

b.) Meta-Objective Calculation
t MetaObjective(, Labeled Data)

0 1

t

t+1

T

UnsupervisedUpdate( · ; t)

c.) Inner Loop Training ­ No Labels Used

_ t+1 [MetaObjective]


t Unlabeled
Data

Forward Pass

+
 Backward
Pass

t+1

d.) Forward and Backward Pass Details
t1 t2

x0 x1

x2

t3 x3

+

h0 0
Weight Update
() t1

h1

1
Backward ()
t2

h2 2

h3

t3

e.) Parameterization of the Weight Updates

From upper layer

Activations Upper Error
Signal Other

x1 2

Convolutional Neural Network

h2 h1

t2 1

To lower layer

Figure App.1: Schematic for meta-learning an unsupervised learning algorithm. a) Meta-training, where the meta-parameters, , are updated via our meta-optimizer (SGD). b) The gradients of the MetaObjective with respect to  are computed by backpropagation through the unrolled application of the UnsupervisedUpdate. c) UnsupervisedUpdate updates the base model parameters () using a minibatch of data. d) Each application of UnsupervisedUpdate involves computing a forward and "backward" pass through the base model. The base model itself is a fully connected network producing hidden states xl for each layer l. The "backward" pass through the base model uses an error signal from the layer above, , which is generated by a meta-learned function. e.) The weight updates  are computed using a convolutional network, using  and x from the pre- and post-synaptic neurons, along with several other terms discussed in the text.
C STABILIZING GRADIENT BASED META-LEARNING TRAINING
Training and computing derivatives through recurrent computation of this form is notoriously difficult Pascanu et al. (2013). Training parameters of recurrent systems in general can lead to chaos. We used the usual techniques such as gradient clipping (Pascanu et al., 2012), small learning rates, and adaptive learning rate methods (in our case Adam (Kingma and Ba, 2014)), but in practice this was not enough to train most UnsupervisedUpdate architectures. In this section we address other techniques needed for stable convergence.
13

Under review as a conference paper at ICLR 2019

When training with truncated backprop the problem shifts from pure optimization to something more like optimizing on a Markov Decision Process where the state space is the base-model weights, , and the `policy' is the learned optimizer. While traversing these states, the policy is constantly meta-optimized and changing, thus changing the distribution of states the optimizer reaches. This type of non-i.i.d training has been discussed at great length with respect to on and off-policy RL training algorithms (Mnih et al., 2013). Other works cast optimizer meta-learning as RL (Li and Malik, 2017) for this very reason, at a large cost in terms of gradient variance. In this work, we partially address this issue by training a large number of workers in parallel, to always maintain a diverse set of states when computing gradients.
For similar reasons, the number of steps per truncation, and the total number of unsupervised training steps, are both sampled in an attempt to limit the bias introduced by truncation.
We found restricting the maximum inner loop step size to be crucial for stability. Pearlmutter (1996) studied the effect of learning rates with respect to the stability of optimization and showed that as the learning rate increases gradients become chaotic. This effect was later demonstrated with respect to neural network training in Maclaurin et al. (2015). If learning rates are not constrained, we found that they rapidly grew and entered this chaotic regime.
Another technique we found useful in addressing these problems is the use of batch norm in both the base model and in the UnsupervisedUpdate rule. Multi-layer perceptron training traditionally requires very precise weight initialization for learning to occur. Poorly scaled initialization can make learning impossible (Schoenholz et al., 2016). When applying a learned optimizer, especially early in meta-training of the learned optimizer, it is very easy for the learned optimizer to cause high variance weights in the base model, after which recovery is difficult. Batch norm helps solve this issues by making more of the weight space usable.

D DISTRIBUTED IMPLEMENTATION

We implement the described models in distributed Tensorflow (Abadi et al., 2016). We construct a

cluster of 512 workers, each of which computes gradients of the meta-objective asynchronously. Each

worker trains on one task by first sampling a dataset, architecture, and a number of training steps.

Next, each worker samples k unrolling steps, does k applications of the UnsupervisedUpdate(·; ),

computes

the

MetaObjective

on

each

new

state,

computes

[MetaObjective] 

and

pushes

it

to

a

parameter

server. The final base-model state, , is then used as the starting point for the next unroll until the

specified number of steps is reached. These gradients from different workers are batched and  is

updated with asynchronous SGD. By batching gradients as workers complete unrolls, we eliminate

most gradient staleness while retaining the compute efficiency of asynchronous workers, especially

given heterogeneous workloads which arise from dataset and model size variation. An overview of

our training can be seen in algorithm G. Due to the small base models and the sequential nature of our

compute workloads, we use multi core CPUs as opposed to GPUs. Training occurs over the course of

8 days with 200 thousand updates to  with minibatch size 256.

14

Under review as a conference paper at ICLR 2019
E MORE FILTERS OVER META-TRAINING
Figure App.2: More filters extracted over the course of meta-training. Note, due to implementation reasons, the columns do not represent the same point / same iteration of . Each filter is extracted after 10k inner loop optimization steps, at 10k. From top to bottom we show: MNIST, Tiny MNIST, Alphabet, CIFAR10, and Mini CIFAR10. Filters shift from noise at initialization to more local features later in meta-training.
15

Under review as a conference paper at ICLR 2019
F META-TRAINING CURVES

Figure App.3: Training curves for the training and evaluation task distributions. Our train set consists of Mini Imagenet, Alphabet, and MiniCIFAR10. Our test sets are Mini Imagenet Test, Tiny Fashion MNIST, Tiny MNIST and IMDB. Error bars denote standard deviation of evaluations with a fixed window of samples evaluated from a single model.

G LEARNING ALGORITHM

Initialize UnsupervisedUpdates parameters, 0. Initialize meta-training step count v  0.

Initialize shared gradient state S

Initialize V to be max meta-training steps.

while v < V on 512 workers in parallel do

Sample base model f (·; ) and initialize 0 Sample supervised task, D

Sample K truncated steps

Initialize learner iteration count t  0

for k = 1 to K do

Sample U unroll steps.

for u = 1 to U do

Sample data, x, from D

t+1 = UnsupervisedUpdate(x, t; ) tt+1

end for

Sample 2 batches of data, x,x , and labels, y,y from D.

J = MetaObjective(x, y, x m, y , t)

Compute

J v

for the last U

steps and store in S

if size of S > mini batch size then

take averaged batch of gradients G from S.

v+1 = v - ADAM (G) v  v+1

end if

end for

end while

Algorithm 1: Distributed Training Algorithm

H MODEL SPECIFICATION
In this section we describe the details of our base model and learned optimizer. First, we describe the inner loop, and then we describe the meta-training procedure in more depth.

16

Under review as a conference paper at ICLR 2019

In the following sections, name denotes a hyper-parameter for the learned update rule.
The design goals of this system are stated in the text body. At the time of writing, we were unaware of any similar systems, so as such the space of possible architectures was massive. Future work consists of simplifying and improving abstractions around algorithmic components.
Opensource implementation of the UnsupervisedUpdate can be found at https://not_a_real_ url.com.

H.1 INNER LOOP

The inner loop computation consists of iterative application of the UnsupervisedUpdate on a Base Model parameterized by ,

t+1 = UnsupervisedUpdate(t),

(App.1)

where  consists of weights and biases, W l, bl, parameterizing a multi-layer perceptron.

This can be broken down further as a forward pass on an unlabeled batch of data,

x0  D {x1..xL, z1..zL} = f (x; t),

(App.2) (App.3)

where zl, and xl are the pre- and post-activations on layer l, and then a function to compute weight updates:

{(W 1···L )t, (b1···L )t} = computeDeltaW eight(x0 · · · xL, z1 · · · zL, t; )

(App.4)

Finally, the next set of  weights and biases, W l, bl, are computed. We use an SGD like update but with the addition of a decay term. Equivalently, this can be seen as setting the weights and biases to an exponential moving average of the W and b terms.

Wtl+1 = Wtl(1 - lr) -  Wflinal lr blt+1 = btl (1 - lr) - bl lr

(App.5) (App.6)

We use lr = 3e - 4 in our work.
In the following sections, we describe the functional form of the base model, f , as well as the functional form of computeDeltaW eight (·).

H.2 BASE MODEL
The base model, the model our learned update rule is training, is an L layer multi layer perception with batchnorm. We define  as this model's parameters, consisting of weights and biases. We define N 1..N L to be the sizes of the layers of the base model.

 = {W 1..W L, b1..bL},

(App.7)

where

RW 1 Nx,Ninner

W  R2:L-1

Ninner ,Ninner

Rb1 · · · bL-1  Ninner

W  RL Ninner ,Nembedding

b  RL Nembedding

(App.8) (App.9) (App.10) (App.11) (App.12)

and Ninner is the hidden size of the network, Nx is the input size of data, and Nembedding is the size of the output embedding. In this work, we fix this: Nembedding = 32.

17

Under review as a conference paper at ICLR 2019

The forward computation parameterized by , consumes batches of unlabeled data from a dataset D:

x0  D, x0  RB,Nx
zl = BatchNorm xl-1W l + bl xl = Relu(zl)

(App.13) (App.14) (App.15)

for l = 1..L.

We define f (x; ) as a function that returns the set of internal pre- and post-activation function hidden states as well as f^(x; ) as the function returning the final hidden state:

f (x, ) = {z1...zL, x0..xL, } f^(x, ) = xL

(App.16) (App.17)

H.3 METAOBJECTIVE

We define the MetaObjective to be a few shot linear regression. To increase stability and avoid undesirable loss landscapes, we additionally center the prediction targets, as well as normalize the predicted target before doing the loss computation. The full computation is as follows:

MetaObjective(x,

y,

x

,

y

,

)

::

R R( , ,B,N0

B,N classes

RB,N0 ,

RB ,

R ,N ydim

)



R1

(App.18)

First, the inputs are converted to embeddings with the base model,

ua = f (xa; ) u a = f (x a; )

(App.19) (App.20)

Next, we center and normalize the prediction targets. We show this for y, but y is processed identically.

y¯i = Ea [yai]

y^ai =

y¯ai

Eb

y¯b

2 2

(App.21) (App.22)

We then solve for the linear regression weights in closed form with features: u and targets: y^. We account for a bias by concatenating a 1's vector to the features.

A = [u; 1]
T = (AtA) + Iridge C = T -1AT y^

(App.23) (App.24) (App.25)

We then use these inferred regression weights C to make a prediction on the second batch of data, normalize the resulting prediction, and compute a final loss,

p = C[u ; 1]

p p^a = pa 2

MetaObjective(·) = Ea

p^a - y^b

2 2

.

(App.26) (App.27)
(App.28)

Note that due to the normalization of predictions and targets, this corresponds to a cosine distance (up to an offset and multiplicative factor).

H.4 UNSUPERVISEDUPDATE
The learned update rule is parameterized by . In the following section, we denote all instances of  with a subscript to be separate named learnable parameters of the UnsupervisedUpdate.  is

18

Under review as a conference paper at ICLR 2019

shared across all instantiations of the unsupervised learning rule. It is this weight sharing that lets us generalize across different network architectures.
The computation is split into a few main components: first, there is the forward pass, defined in f (x; ). Next, there is a "backward" pass, which operates on the hidden states in a reverse order to propagate an error signal l back down the network. In this process, a hidden state hl is created for each layer. Weight updates to W l and bl are then readout from these hl and other signals found locally.

H.4.1 BACKWARD ERROR PROPAGATION

In backprop, there exists a single scalar error signal that gets backpropagated back down the network.
In our work, this error signal does not exist as there is no loss being optimized. Instead we have a learned top-down signal, dL, at the top of the network. Because we are no longer restricted to the
form of backprop, we make this quantity a vector for each unit in the network, rather than a scalar,

x0  D, x0  RB,Nx
{z1...zL, x0..xL, } = f (x, ) dL = topD(xL; topD)

(App.29) (App.30) (App.31) (App.32)

where dl  RB,Nl,deltadims. The architecture of topD is a neural network that operates along every
dimension of xL. The specification can be found in H.7.
We structure our error propagation similarly to the structure of the backpropagated error signal in a standard MLP with contributions to the error at every layer in the network,

iljd = dil+jd1

Nl

(zilj+d1) +

(errorP rop W )dk hli+jk1 + errorP rop bd

k

(App.33)

where l has the same shape as dl.

In a similar way to backprop, we move this signal down the network via multiplying by a backward weight matrix. We do not use the previous weight matrix transpose as done in backprop, instead we learn a separate set of weights that are not tied to the forward weights and updated along with the forward weights as described in H.5. Additionally, we normalize the signal to have fixed second moment,

N l+1

d~limd =

iljd(V l+1)mj

j

dilmd = d^limd

BN ldeltadims d~l

1/2

2

(App.34) (App.35)

The internal hl  RB,Nl,hsize vectors are computed via:
hl = computeH dl, xl, zl; computeH

(App.36)

The architecture of computeH is a neural network that operates on every dimension of all the inputs. It can be found in H.8. These definitions are recursive, and are computed in order: hL, hL-1 · · · h1, h0. With these computed, weight updates can be read out.

H.5 WEIGHT UPDATES
For a given layer, l, our weight updates are a mixture of multiple low rank readouts from hl and hl-1. These terms are then added together with a learnable weight, in  to form a final update. The final update is then normalized mixed with the previous weights. We update both the forward, W l, and the

19

Under review as a conference paper at ICLR 2019

backward, V l, using the same update rule parameters . We show the forward weight update rule here, and drop the backward for brevity.
For convenience, we define a low rank readout function lowRR that takes hl like tensors, and outputs a single lower rank tensor.

lowRR (ha, hb; ) ::

R R R, B,Na,hsize B,Nb,hsize

Na ,Nb

(App.37) (App.38)

Here, , is a placehoder for the parameters of the given readout. lowRR is defined as:

 = {V t, V b}

riajp =

hiaj k Vktp

k

ribjp =

hiaj k Vktp

k

lowRR (·) =

B k

gradC i

ribj k riapk

1 BgradC

(App.39) (App.40) (App.41)
(App.42)

H.5.1 LOCAL TERMS
This sequence of terms allow the weight to be adjusted as a function of state in the pre- and postsynaptic neurons. They should be viewed as a basis function representation of the way in which the weight changes as a function of pre- and post-synaptic neurons, and the current weight value. We express each of these contributions to the weight update as a sequence of weight update planes, with
the ith plane written Wi  R :Nl-1×Nl

W^ l =

Wl
Ei [((W l)i)2]

W1l = W^ l

W2l = (W^ l)2sign(W^ l)

W3l = lowRR(hl-1, hl; zero)

W4l = exp(-(W^ bl)2) lowRR(hl-1, hl; rbf )

W5l = Wbl lowRR(hl-1, hl; first)

W6l = Eb xlb-1 - Eb xbl-1 T xlb - Eb xlb

T

(App.43)
(App.44) (App.45) (App.46) (App.47) (App.48) (App.49)

H.5.2 DECORRELATION TERMS
Additional weight update planes are designed to aid units in remaining decorrelated from each other's activity, and in decorrelating their receptive fields. Without terms like this, a common failure mode is for many units in a layer to develop near-identical representations. Here, Si indicates a scratch matrix
20

Under review as a conference paper at ICLR 2019

associated with weight update layer i.

S7

=

1

(N

l-1

)

1 2

lowRR(h1-1, hl-1, linLowerSymm)

W7l

=

1 2

S7 + S7T

(1 - I) W l

S8 =

1 1 lowRR(h1-1, hl-1, sqrLowerSymm)

(N l-1) 2

W8l

=

1 2

S8 + S8T

(1 - I)

1 + (W l)2 - 1

S9 = 1 1 lowRR(h1, hl, linUpperSymm) (N l) 2

W9l

=

1 W l 2

S9 + S9T

(1 - I)

S10 = 1 1 lowRR(h1-1, hl-1, sqrUpperSymm) (N l) 2

W1l0

=

1 2

1 + (W l)2 - 1 S10 + S1T0 (1 - I)

(App.50) (App.51) (App.52) (App.53) (App.54) (App.55) (App.56) (App.57) (App.58)

H.6 APPLICATION OF THE WEIGHT TERMS IN THE OPTIMIZER

We then normalize, reweight, and merge each of these weight update planes into a single term, which will be used in the weight update step,

W~ il =

Wil

1 + Emn

Wil

2 mn

(App.59)

(Wml erge) = Ei mergeWi W~ il

(App.60)

To prevent pathologies during training, we perform two post processing steps to prevent the learned optimizer from cheating, and increasing its effective learning rate, leading to instability. We only allow updates which do not decrease the weight matrix magnitude,

Wolrth = Wml erge - W^ l Relu(Wmerge · W^ l),

(App.61)

where W^ l is W l scaled to have unit norm, and we normalize the length of the update,

(Wfinal) =

Wolrth

1 + Emn

Wolrth

2 mn

(App.62)

To compute changes in the biases, we do a readout from hl. We put some constraints on this update to prevent the biases from pushing all units into the linear regime, and minimizing learning. We found this to be a possible pathology.

bbl ase =

hsize
(Breadout )khiljk

ik

bcl onstrained = blbase - max Ei bbl ase i

(App.63) (App.64)

H.7 topD

This function performs various convolutions over the batch and data dimension. For ease of notation, we use m as an intermediate variable. Additionally, we drop all convolution and batchnorm

21

Under review as a conference paper at ICLR 2019

parameterizations. They are all separate elements of topD. We define the S argument to be size of hidden units, and the K argument to be the kernel size of the 1D convolutions. Additionally, we set
the second argument of BatchN orm to be the axies normalized over.

R RtopD xL; topD :: B,NL  B,NL,deltadims

(App.65)

In this work, we set deltadims = 32. First, we reshape to add another dimension to the end of XL, in pseudocode:

m0 = [xL]

(App.66)

Next, a convolution is performed on the batch dimension with a batchnorm and a relu non linearity. This starts to pull information from around the batch into these channels.

m1 = ConvBatch (m0, S = topdeltasize, K = 5) m2 = relu (BatchN orm (m1, [0, 1]))

(App.67) (App.68) (App.69)

We set topdeltasize = 64. Next, a series of unit convolutions (convolutions over the last dimension) are performed. These act as compute over information composed from the nearby elements of the batch. These unit dimensions effectively rewrite the batch dimension. This restricts the model to operate on a fixed size batch.

m3 = ConvU nit (m2, S = B, K = 3) m4 = relu(BatchN orm (m3, [0, 1]) m5 = ConvU nit (m4, S = B, K = 3) m6 = relu (BatchN orm (m5, [0, 1]))

(App.70) (App.71) (App.72) (App.73)

Next a series of 1D convolutions are performed over the batch dimension for more compute capacity.

m7 = ConvBatch (m6, S = topdeltasize, K = 3) m8 = relu (BatchN orm (m7, [0, 1])) m9 = ConvBatch (m8, S = topdeltasize, K = 3) m10 = relu (BatchN orm (m9, [0, 1]))

(App.74) (App.75) (App.76) (App.77)

Finally, we convert the representations to the desired dimensions and output.
m11 = ConvBatch (m10, S = deltadims, K = 3) topD xL; topD = m11

(App.78) (App.79)

H.8 computeH

This is the main computation performed while transfering signals down the network and the output is directly used for weight updates. It is defined as:

computeH dl, xl, zl, wl-1, wl, bl; computeH ::

R R R R R R R, , , , , B,Nl,deltadims

B,N l

B,N l

N l-1,N l

N l,N l+1

Nl

B,N l,hdims

(App.80)

The outputs of the base model, (xl, zl), plus an additional positional embeddings are stacked then
concatenated with d, to form a tensor in RB,Nl,5+deltadims :

2i (p0)ij = sin( N l )
2i (p1)ij = cos( N l )
m0 = [xl, zl, p0, p1]

(App.81) (App.82) (App.83)

m1 = [m0; dl]

(App.84)

22

Under review as a conference paper at ICLR 2019

Statistics across the batch and unit dimensions, 0 and 1, are computed. We define a Statsi function bellow. We have 2 instances for both the zeroth and the first index, shown bellow is the zeroth index
and the first is omitted.

Stats0 (w) :: RK0,K1  RK0

1 K0

sl1 = K0

abs(wij)
i

(App.85) (App.86)

sl2 =

1 K0

K0
(wij)2
i

1 K0

sµ = K0

wij
i

(App.87) (App.88)

s = Stats0 (w) = [sl1, sl2, sµ, s]

1 K0

K0
((sµ)i - wij)2
i

(App.89) (App.90)

We the compute statistics of the weight matrix below, and above. We tile the statistics to the appropriate dimensions and concatenate with normalized inputs as well as with the bias (also tiled appropriately).

(s0)ijk = (Stats0 wl-1, 0 )j (s1)ijk = (Stats1 wl, 1 )i
m2 = BatchN orm(m1, [0, 1]) ^bijk = blj m3 = [s0; s1; m2; ^b]

(App.91) (App.92) (App.93) (App.94) (App.95)

With the inputs prepared, we next perform a series of convolutions on batch and unit dimensions, (0, 1).

m4 = ConvBatch (m3, S = computehsize, K = 3) m5 = relu (BatchN orm (m4, [0, 1])) m6 = ConvU nit (m5, S = computehsize, K = 3) m7 = relu (BatchN orm (m6, [0, 1])) m8 = ConvBatch (m7, S = computehsize, K = 3) m9 = relu (BatchN orm (m8, [0, 1])) m10 = ConvU nit (m9, S = computehsize, K = 3) m11 = relu (BatchN orm (m10, [0, 1]))

(App.96) (App.97) (App.98) (App.99) (App.100) (App.101) (App.102) (App.103)

The result is then output.

We set computehsize = 64.

computeH (·; computeH ) = m11

(App.104)

I EXPERIMENTAL DETAILS
I.1 META TRAINING
I.1.1 TRAINING DATA DISTRIBUTION We trained on a data distribution consisting of tasks sampled uniformly over the following datasets. Half of our training tasks where constructed off of a dataset consisting of 1000 font rendered

23

Under review as a conference paper at ICLR 2019
characters. We resized these to 14x14 black and white images. We call this the glyph dataset. "Alphabet" is an example of such a dataset consisting of alphabet characters. We used a mixture 10, 13, 14, 17, 20, and 30 way classification problems randomly sampled, as well as sampling from three 10-way classification problems sampled from specific types of images: letters of the alphabet, math symbols, and currency symbols. For half of the random sampling and all of the specialized selection we apply additional augmentation. This augmentation consists of random rotations (up to 360 degrees) and shifts up to +-5 pixels in the x and y directions. The parameters of the augmentation were inserted into the regression target of the MetaObjective as a curriculum of sorts and to provide diverse training signal.
In addition to the the glyph set, we additionally used Cifar10, resized to 16x16, as well as 10, 15, 20, and 25 way classification problems from imagenet. Once again we resized to 16x16 for compute reasons.
With a dataset selected, we apply additional augmentation with some probability consisting of the following augmentations. A per task dropout mask (fixed mask across all images in that task). A per example dropout mask (a random mask per image). A permutation sampled from a fixed number of pre created permutations per class. A per image random shift in the x direction each of image. All of these additional augmentations help with larger domain transfer.
I.2 META-OPTIMIZATION
We employ Adam Kingma and Ba (2014) as our meta-optimizer. We use a learning rate schedule of 3e-4 for the first 100k steps, then 1e-4 for next 50k steps, then 2e-5 for remainder of meta-training. We use gradient clipping of norm 5 on minibatchs of size 256.
We compute our meta-objective by averaging 5 evaluation of the linear regression. We use a ridge penalty of 0.1 for all this work.
When computing truncated gradients, we initially sample the number of unrolled applications of the UnsupervisedUpdate in a uniform distribution of [2,4]. Over the course of 50k steps we uniformly increase this to [8,15]. This increases meta-training speed and stability as large unrolls early in training can be unstable and don't seem to provide any value.
For sampling the number of truncated steps, we use a shifted normal distribution ­ a normal distribution with the same mean and std. We chose this based on the expected distribution of the training step,  iteration, across the cluster of workers. We initially set the STD low, 20, but slowly increased it over the course of 5000 steps to 20k steps. This slow increase also improved stability and training speed.
I.3 EXPERIMENTAL SETUP
For each experimental figure, we document the details.
I.3.1 OBJECTIVE FUNCTION MISMATCH
The VAE we used consists of 3 layers, size 128, with ReLU activations and batch norm between each layer. We then learn a projection to mean and log std of size 32. We sample, and use the inverse architecture to decode back to images. We use a quantized normal distribution (once again parameterized as mean and log std) as a posterior. We train with Adam with a learning rate of 1e-4. To isolate the effects of objective function mismatch and overfitting, we both train on the unlabeled training set and evaluate on the labeled training set instead of a validation set.
I.3.2 GENERALIZATION: DATASET AND DOMAIN
We use a 4 layer, size 128 unit architecture with a 32 layer embedding for all models. We select performance at 100k training steps for the VAE, and 3k for our learned optimizer.
Our supervised learning baseline consists of the same architecture for the base model but with an additional layer that outputs log probabilities. We train with cross entropy loss on a dataset consisting of only 10 examples per class (to match the other numbers). Surprisingly, the noise from batch norm acts as a regularizer, and allowing us to avoid needing a complex early stopping scheme as test set
24

Under review as a conference paper at ICLR 2019
performance simply plateaus over the course of 10k steps. We train with Adam with a learning rate of 3e-3, selected via a grid over learning rate on test set performance. In this setting, having a true validation set would dramatically lower the amount of labeled data available (only 100 labeled examples) and using the test set only aids in the this baseline's performance. For the IMDB experiments, we tokenized and selected the top 1K words with an additional set of tokens for unknown, sentence start, and sentence end. Our encoding consisted of a 1 if the word is present, otherwise 0. We used the same 4 layer, 128 hidden units with an addition layer outputting a 32 dimensional embedding. I.3.3 GENERALIZATION: NETWORK ARCHITECTURE We used ReLU activations and 4 layers of size 128 with an additional layer to 32 units unless otherwise specified by the specific experiment. I.3.4 EXISTING META LEARNING MODELS We trained prototypical networks Snell et al. (2017) on either intact or shuffled mini-Imagenet images. For shuffled images, we generated a fixed random permutation for the inputs independently for every instantiation of the base network (or 'episode' in the meta-learning literature Vinyals et al. (2016); Ravi and Larochelle (2016)). The purpose of shuffling was to demonstrate the inductive bias of this type of meta-learning, namely that they do not generalize across data domain. Note that the base network trained was the same fully connected architecture like that used in this paper (3 layers, size 128, with ReLU activations and batch normalization between layers). Though the original paper used a convolutional architecture, here we swapped it with the fully connected architecture because the tied weights in a convolutional model do not make sense with shuffled pixels.
25

